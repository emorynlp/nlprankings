



















































A* CCG Parsing with a Supertag-factored Model


Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 990–1000,
October 25-29, 2014, Doha, Qatar. c©2014 Association for Computational Linguistics

A∗ CCG Parsing with a Supertag-factored Model

Mike Lewis
School of Informatics

University of Edinburgh
Edinburgh, EH8 9AB, UK
mike.lewis@ed.ac.uk

Mark Steedman
School of Informatics

University of Edinburgh
Edinburgh, EH8 9AB, UK

steedman@inf.ed.ac.uk

Abstract

We introduce a new CCG parsing model
which is factored on lexical category as-
signments. Parsing is then simply a de-
terministic search for the most probable
category sequence that supports a CCG
derivation. The parser is extremely simple,
with a tiny feature set, no POS tagger, and
no statistical model of the derivation or
dependencies. Formulating the model in
this way allows a highly effective heuris-
tic for A∗ parsing, which makes parsing
extremely fast. Compared to the standard
C&C CCG parser, our model is more ac-
curate out-of-domain, is four times faster,
has higher coverage, and is greatly simpli-
fied. We also show that using our parser
improves the performance of a state-of-
the-art question answering system.

1 Introduction

CCG is a strongly lexicalized grammatical formal-
ism, in which the vast majority of the decisions
made during interpretation involve choosing the
correct definitions of words. We explore the ef-
fect of modelling this explicitly in a parser, by
only using a probabilistic model of lexical cate-
gories (based on a local context window), rather
than modelling the derivation or dependencies.

Existing state-of-the-art CCG parsers use com-
plex pipelines of POS-tagging, supertagging and
parsing—each with its own feature sets and pa-
rameters (and sources of error)—together with fur-
ther parameters governing their integration (Clark
and Curran, 2007). We show that much simpler
models can achieve high performance. Our model
predicts lexical categories based on a tiny fea-
ture set of word embeddings, capitalization, and 2-
character suffixes—with no parsing model beyond
a small set of CCG combinators, and no POS-

tagger. Simpler models are easier to implement,
replicate and extend.

Another goal of our model is to parse CCG
optimally and efficiently, without using excessive
pruning. CCG’s large set of lexical categories,
and generalized notion of constituency, mean that
sentences can have a huge number of potential
parses. Fast existing CCG parsers rely on aggres-
sive pruning—for example, the C&C parser uses
a supertagger to dramatically cut the search space
considered by the parser. Even the loosest beam
setting for their supertagger discards the correct
parse for 20% of sentences. The structure of our
model allows us to introduce a simple but power-
ful heuristic for A∗ parsing, meaning it can parse
almost 50 sentences per second exactly, with no
beam-search or pruning. Adding very mild prun-
ing increases the speed to 186 sentences per sec-
ond with minimal loss of accuracy.

Our approach faces two obvious challenges.
Firstly, categories are assigned based on a local
window, which may not contain the necessary con-
text for resolving some attachment decisions. For
example, in I saw a squirrel 2 weeks ago with a
nut, the model cannot make an informed decision
on whether to assign with an adverbial or adnomi-
nal preposition category, as the crucial words saw
and squirrel fall outside the local context window.
Secondly, even if the supertagger makes all lexical
category decisions correctly, then the parser can
still make erroneous decisions. One example is
in coordination-scope ambiguities, such as clever
boys and girls, where the two interpretations use
the same assignment of categories.

We hypothesise that such decisions are rela-
tively rare, and are challenging for any parsing
model, so a weak model is unlikely to result in
substantially lower accuracy. Our implementation
of this model1, which we call EASYCCG, has high

1Available from https://github.com/
mikelewis0/easyccg

990



accuracy—suggesting that most parsing decisions
can be made accurately based on a local context
window.

Of course, there are many parsing decisions that
can only be made accurately with more complex
models. However, exploring the power and lim-
itations of simpler models may help focus future
research on the more challenging cases.

2 Background

2.1 Combinatory Categorial Grammar

CCG (Steedman, 2000) is a strongly lexicalized
grammatical formalism. Words have categories
representing their syntactic role, which are either
atomic, or functions from one category to another.

Phrase-structure grammars have a relatively
small number of lexical categories types (e.g.
POS-tags), and a large set of rules used to build
a syntactic analysis of a complete sentence (e.g.
an adjective and noun can combine into a noun).
In contrast, CCG parsing has many lexical cate-
gory types (we use 425), but a small set of combi-
natory rule types (we use 10 binary and 13 unary
rule schemata). This means that, aside from the
lexicon, the grammar is small enough to be hand-
coded—which allows us, in this paper, to confine
the entire statistical model to the lexicon.

CCG’s generalized notion of constituency
means that many derivations are possible for
a given a set of lexical categories. However,
most of these derivations will be semantically
equivalent—for example, deriving the same de-
pendency structures—in which case the actual
choice of derivation is unimportant. Such ambi-
guity is often called spurious.

2.2 Existing CCG Parsing Models

The seminal C&C parser is by far the most pop-
ular choice of CCG parser (Clark and Curran,
2007). It showed that it was possible to parse to
an expressive linguistic formalism with high speed
and accuracy. The performance of the parser has
enabled large-scale logic-based distributional re-
search (Harrington, 2010; Lewis and Steedman,
2013a; Lewis and Steedman, 2013b; Reddy et al.,
2014), and it is a key component of Boxer (Bos,
2008).

The C&C parser uses CKY chart parsing, with a
log-linear model to rank parses. The vast number
of possible parses means that computing the com-
plete chart is impractical. To resolve this prob-

lem, a supertagger is first run over the sentence to
prune the set of lexical categories considered by
the parser for each word. The initial beam out-
puts an average of just 1.2 categories per word,
rather than the 425 possible categories—making
the standard CKY parsing algorithm very efficient.
If the parser fails to find any analysis of the com-
plete sentence with this set of supertags, the su-
pertagger re-analyses the sentence with a more re-
laxed beam (adaptive supertagging).

2.3 A∗ Parsing

Klein and Manning (2003a) introduce A∗ parsing
for PCFGs. The parser maintains a chart and an
agenda, which is a priority queue of items to add to
the chart. The agenda is sorted based on the items’
inside probability, and a heuristic upper-bound on
the outside probability—to give an upper bound
on the probability of the complete parse. The chart
is then expanded in best-first order, until a com-
plete parse for the sentence is found.

Klein and Manning calculate an upper bound on
the outside probability of a span based on a sum-
mary of the context. For example, the summary
for the SX heuristic is the category of the span, and
the number of words in the sentence before and af-
ter the span. The value of the heuristic is the prob-
ability of the best possible sentence meeting these
restrictions. These probabilities are pre-computed
for every non-terminal symbol and for every pos-
sible number of preceding and succeeding words,
leading to large look-up tables.

Auli and Lopez (2011b) find that A∗ CCG pars-
ing with this heuristic is very slow. However,
they achieve a modest 15% speed improvement
over CKY when A∗ is combined with adaptive su-
pertagging. One reason is that the heuristic esti-
mate is rather coarse, as it deals with the best pos-
sible outside context, rather than the actual sen-
tence. We introduce a new heuristic which gives a
tighter upper bound on the outside probability.

3 Model

3.1 Lexical Category Model

As input, our parser takes a distribution over all
CCG lexical categories for each word in the sen-
tence. These distributions are assigned using
Lewis and Steedman (2014)’s semi-supervised su-
pertagging model. The supertagger is a unigram
log-linear classifier that uses features of the ±3
word context window surrounding a word. The

991



key feature is word embeddings, initialized with
the 50-dimensional embeddings trained in Turian
et al. (2010), and fine-tuned during supervised
training. The model also uses 2-character suffixes
and capitalization features.

The use of word embeddings, which are trained
on a large unlabelled corpus, allows the supertag-
ger to generalize well to words not present in the
labelled data. It does not use a POS-tagger, which
avoids problems caused by POS-tagging errors.

Our methods could be applied to any supertag-
ging model, but we find empirically that this
model gives higher performance than the C&C su-
pertagger.

3.2 Parsing Model

Let a CCG parse y of a sentence S be a list of
lexical categories c1 . . . cn and a derivation. If we
assume all derivations licensed by our grammar
are equally likely, and that lexical category assign-
ments are conditionally independent given the sen-
tence, we can compute the optimal parse ŷ as:
ŷ = argmaxy

∏n
i=1 p(ci|S)

As discussed in Section 2.1, many derivations
are possible given a sequence of lexical categories,
some of which may be semantically distinct. How-
ever, our model will assign all of these an equal
score, as they use the same sequence of lexical
categories. Therefore we extend our model with
a simple deterministic heuristic for ranking parses
that use the same lexical categories. Given a set of
derivations with equal probability, we output the
one maximizing the sums of the length of all arcs
in the corresponding dependency tree.

The effect of this heuristic is to prefer non-
local attachments in cases of ambiguity, which
we found worked better on development data than
favouring local attachments. In cases of spurious
ambiguity, all parses will have the same value of
this heuristic, so one is chosen arbitrarily. For
example, one of the parses in Figures 1a and 1b
would be selected over the parse in Figure 1c.

Of course, we could use any function of the
parses in place of this heuristic, for example a
head-dependency model. However, one aim of
this paper is to demonstrate that an extremely sim-
ple parsing model can achieve high performance,
so we leave more sophisticated alternatives to fu-
ture work.

a house in Paris in France

NP (NP\NP)/NP NP (NP\NP)/NP NP
> >

NP\NP NP\NP
<

NP
<

NP

(a) A standard derivation of a house in Paris in France, with a
dependency from in France to house

a house in Paris in France

NP (NP\NP)/NP NP (NP\NP)/NP NP
> >

NP\NP NP\NP
>B

NP\NP
<

NP

(b) A derivation of a house in Paris in France, which is spu-
riously equivalent to Figure 1a. A composition combinator is
used to compose the predicates in Paris and in France, creating
a constituent which creates dependencies to its argument from
both in Paris and in France.

a house in Paris in France

NP (NP\NP)/NP NP (NP\NP)/NP NP
>

NP\NP
<

NP
>

NP\NP
<

NP

(c) A derivation of a house in Paris in France, which yields
different dependencies to Figures 1a and 1b: here, there is a
dependency from in France to Paris, not house.

Figure 1: Three CCG parses of a house in Paris
in France, given the same set of supertags. The
first two are spuriously equivalent, but the third is
semantically distinct.

3.3 A∗ Search

For parsing, we use an A∗ search for the most-
probable complete CCG derivation of a sentence.
A key advantage of A∗ parsing over CKY parsing
is that it does not require us to prune the search
space first with a supertagger, allowing the parser
to consider the complete distribution of 425 cate-
gories for each word (in contrast to an average of
3.57 categories per word considered by the C&C
parser’s most relaxed beam). This is possible be-
cause A∗ only searches for the Viterbi parse of
a sentence, rather than building a complete chart
with every possible category per word (another al-
ternative, used by Hockenmaier (2003), is to use a
highly aggressive beam search in the parser).

In A∗ parsing, items on the agenda are sorted by
their cost; the product of their inside probability
and an upper bound on their outside probability.

992



For a span wi . . . wj with lexical categories
ci . . . cj in a sentence S = w1 . . . wn, the inside
probability is simply:

∏j
k=i p(ck|S)

The factorization of our model lets us give the
following upper-bound on the outside probability:
h(wi . . . wj) =

∏k<i
k=1maxckp(ck|S)×∏k≤n
k=j+1maxckp(ck|S)

This heuristic assumes that all words outside the
span will take their highest-probability supertag.
Because the model is factored on lexical cate-
gories, this estimate is clearly an upper bound.
As supertagging is over 90% accurate, the upper
bound will often be exact, and in Section 4.3 we
show empirically that it is extremely efficient. The
values of the heuristic can be computed once for
each sentence and cached.

To implement the preference for non-local at-
tachment described in Section 3.2, if two agenda
items have the same cost, the one with the longer
dependencies is preferred.

Intuitively, the parser first attempts to find a
parse for the sentence using the 1-best category for
each word, by building as complete a chart as pos-
sible. If it fails to find a parse for the complete
sentence, it adds one more supertag to the chart
(choosing the most probable tag not already in the
chart), and tries again. This strategy allows the
parser to consider an unbounded number of cate-
gories for each word, as it does not build a com-
plete chart with all supertags.

3.4 Grammar

Here, we describe the set of combinators and
unary rules in the EASYCCG grammar. Because
we do not have any probabilistic model of the
derivation, all rules can apply with equal probabil-
ity. This means that some care needs to be taken
in designing the grammar to ensure that all the
rules are generally applicable. We also try to limit
spurious ambiguity, and build derivations which
are compatible with the C&C parser’s scripts for
extracting dependencies (for evaluation). We de-
scribe the grammar in detail, to ensure replicabil-
ity.

Our parser uses the following binary combi-
nators from Steedman (2012): forward applica-
tion, backward application, forward composition,
backward crossed composition, generalized for-
ward composition, generalized backward crossed
composition. These combinators are posited to
be linguistically universal. The generalized rules

Initial Result Usage
N NP Bare

noun
phrases

NP S/(S\NP ) Type
NP (S\NP )/((S\NP )/NP ) raising
PP (S\NP )/((S\NP )/PP )
Spss\NP NP\NP
Sng\NP NP\NP Reduced
Sadj\NP NP\NP relative
Sto\NP NP\NP clauses
Sto\NP N\N
Sdcl/NP NP\NP
Spss\NP S/S VP
Sng\NP S/S Sentence
Sto\NP S/S Modifiers

Table 1: Set of unary rules used by the parser.

are generalized to degree 2. Following Steedman
(2000) and Clark and Curran (2007), backward
composition is blocked where the argument of the
right-hand category is anN orNP . The unhelpful
[nb] feature is ignored.

As in the C&C parser, we add a special Con-
junction rule:

Y X
>

X \X
Where Y ∈ {conj, comma, semicolon}. We

block conjunctions where the right-hand category
is type-raised, punctuation, N , or NP\NP . This
rule (and the restrictions) could be removed by
changing CCGBank to analyse conjunctions with
(X\X)/X categories.

We also add syntagmatic rules for removing any
punctuation to the right, and for removing open-
brackets and open-quotes to the left

The grammar also contains 13 unary rules,
listed in Table 1. These rules were chosen based
on their frequency in the training data, and their
clear semantic interpretations.

Following Clark and Curran (2007), we also add
a (switchable) constraint that only category com-
binations that have combined in the training data
may combine in the test data. We found that this
was necessary for evaluation, as the C&C conver-
sion tool for extracting predicate-argument depen-
dencies had relatively low coverage on the CCG
derivations produced by our parser. While this
restriction is theoretically inelegant, we found it
did increase parsing speed without lowering lexi-

993



cal category accuracy.
We also use Eisner Normal Form Constraints

(Eisner, 1996), and Hockenmaier and Bisk’s
(2010) Constraint 5, which automatically rule out
certain spuriously equivalent derivations, improv-
ing parsing speed.

We add a hard constraint that the root category
of the sentence must be a declarative sentence, a
question, or a noun-phrase.

This grammar is smaller and cleaner than that
used by the C&C parser, which uses 32 unary
rules (some of which are semantically dubious,
such as S[dcl]→ NP\NP ), and non-standard bi-
nary combinators such as merging two NP s into
an NP . The C&C parser also has a large num-
ber of special case rules for handling punctua-
tion. Our smaller grammar reduces the grammar
constant, eases implementation, and simplifies the
job of building downstream semantic parsers such
as those of Bos (2008) or Lewis and Steedman
(2013a) (which must implement semantic analogs
of each syntactic rule).

3.5 Extracting Dependency Structures
The parsing model defined in Section 3.2 re-
quires us to compute unlabelled dependency trees
from CCG derivations (to prefer non-local attach-
ments). It is simple to extract an unlabelled depen-
dency tree from a CCG parse, by defining one ar-
gument of each binary rule instantiation to be the
head. For forward application and (generalized)
forward composition, we define the head to be the
left argument, unless the left argument is an endo-
centric head-passing modifier category X/X . We
do the inverse for the corresponding ‘backward’
combinators. For punctuation rules, the head is the
argument which is not punctuation, and the head
of a Conjunction rule is the right-hand argument.

The standard CCG parsing evaluation uses a
different concept of dependencies, correspond-
ing to the predicate-argument structure defined by
CCGBank. These dependencies capture a deeper
information—for example by assigning both boy
and girl as subjects of talk in a boy and a girl
talked. We extract these dependencies using
the generate program supplied with the C&C
parser.

3.6 Pruning
Our parsing model is able to efficiently and op-
timally search for the best parse. However,
we found that over 80% of the run-time of our

pipeline was spent during supertagging. Naively,
the log-linear model needs to output a probability
for each of the 425 categories. This is expensive
both in terms of the number of dot products re-
quired, and the cost of building the initial priority-
queue for the A∗ parsing agenda. It is also largely
unnecessary—for example, periods at the end of
sentences always have the same category, but our
supertagger calculates a distribution over all pos-
sible categories.

Note that the motivation for introducing prun-
ing here is fundamentally different from for the
C&C pipeline. The C&C supertagger prunes the
the categories so that the parser can build the com-
plete set of derivations given those categories. In
contrast, our parser can efficiently search large (or
infinite) spaces of categories, but pruning is help-
ful for making supertagging itself more efficient,
and for building the initial agenda.

We therefore implemented the following strate-
gies to improve efficiency:

• Only allowing at most 50 categories per
word. The C&C parser takes on average 1.27
tags per word (and an average of 3.57 at its
loosest beam setting), so this restriction is a
very mild one. Nevertheless, it considerably
reduces the potential size of the agenda.

• Using a variable-width beam β which prunes
categories less likely than β times the prob-
ability of the best category. We set β =
0.00001, which is two orders-of-magnitude
smaller than the equivalent C&C beam.
Again, this heuristic is useful for reducing the
length of the agenda.

• Using a tag dictionary of possible categories
for each word, so that weights are only cal-
culated for a subset of the categories. Unlike
the other methods, this approach does affect
the probabilities which are calculated, as the
normalizing constant is only computed for a
subset of the categories. However, the proba-
bility mass contained in the pruned categories
is small, and it only slightly decreases pars-
ing accuracy. To build the tag dictionary, we
parsed 42 million sentences of Wikipedia us-
ing our parser, and for all words occurring at
least 500 times, we stored the set of observed
word-category combinations. When parsing
new sentences, these words are only allowed
to occur with one of these categories.

994



Supertagger Parser CCGBank Wikipedia Bioinfer
F1 COV F1 Time F1 COV F1 F1 COV F1
(cov) (all) (cov) (all) (cov) (all)

C&C C&C 85.47 99.63 85.30 54s 81.19 99.0 80.64 76.08 97.2 74.88
EASYCCG EASYCCG 83.37 99.96 83.37 13s 81.75 100 81.75 77.24 100 77.24
EASYCCG C&C 86.14 99.96 86.11 69s 82.46 100 82.46 78.00 99.8 77.88

Table 2: Parsing F1-scores for labelled dependencies across a range of domains. F1 (cov) refers to
results on sentences which the parser is able to parse, and F1 (all) gives results over all sentences. For
the EASYCCG results, scores are only over parses where the C&C dependency extraction script was
successful, which was 99.3% on CCGBank, 99.5% on Wikipedia, and 100% on Bioinfer.

4 Experiments

4.1 Experimental Setup
We trained our model on Sections 02-21 of CCG-
Bank (Hockenmaier and Steedman, 2007), using
Section 00 for development. For testing, we used
Section 23 of CCGBank, a Wikipedia corpus an-
notated by Honnibal and Curran (2009), and the
Bioinfer corpus of biomedical abstracts (Pyysalo
et al., 2007). The latter two are out-of-domain, so
are more challenging for the parsers.

We compare the performance of our model
against both the C&C parser, and the system de-
scribed in Lewis and Steedman (2014). This
model uses the same supertagger as used in EASY-
CCG, but uses the C&C parser for parsing, using
adaptive supertagging with the default values.

All timing experiments used the same 1.8Ghz
AMD machine.

4.2 Parsing Accuracy
Results are shown in Table 2. Our parser per-
forms competitively with a much more complex
parsing model, and outperforms the C&C pipeline
on both out-of-domain datasets. This result con-
firms our hypothesis that the majority of parsing
decisions can be made accurately with a simple
tagging model and a deterministic parser.

We see that the combination of the EASYCCG
supertagger and the C&C parser achieves the best
accuracy across all domains. This result shows
that, unsurprisingly, there is some value to hav-
ing a statistical model of the dependencies that the
parser is evaluated on. However, the difference is
not large, particularly out-of-domain, considering
that a sophisticated and complex statistical parser
is being compared with a deterministic one. Our
parser is also far faster than this baseline.

It is interesting that the performance gap is

Speed (sentences/second)
System Tagger Parser Total
C&C 343 52 45
EASYCCG tagger +
C&C parser

299 58 49

EASYCCG baseline 56 222 45
+Tag Dictionary 185 217 99
+Max 50 tags/word 238 345 141
+β=0.00001 299 493 186
EASYCCG — null
heuristic

300 221 127

Table 3: Effect of our optimizations of parsing
speed.

much lower on out-of-domain datasets (2.8 points
in domain, but only 0.65-0.75 out-of-domain),
suggesting that much of the C&C parser’s depen-
dency model is domain specific, and does not gen-
eralize well to other domains.

We also briefly experimented using the C&C
supertagger (with a beam of β = 10−5) with the
EASYCCG parser. Performance was much worse,
with an F-score of 79.63% on the 97.8% of sen-
tences it parsed on CCGBank Section 23. This
shows that our model is reliant on the accuracy of
the supertagger.

4.3 Parsing Speed

CCG parsers have been used in distributional
approaches to semantics (Lewis and Steedman,
2013a; Lewis and Steedman, 2013b), which bene-
fit from large corpora. However, even though the
C&C parser is relatively fast, it will still take over
40 CPU-days to parse the Gigaword corpus on our
hardware, which is slow enough to be an obstacle
to scaling distributional semantics to larger cor-

995



0 20 40 60 80 100

10

20

30

40

50

Sentence Length

A
ve

ra
ge

Pa
rs

e
Ti

m
e

(m
s)

Figure 2: Average parse times in milliseconds, by
sentence length.

pora such as ClueWeb. Therefore, it is important
to be able to parse sentences at a high speed.

We measured parsing times on Section 23 of
CCGBank (after developing against Section 00),
using the optimizations described in Section 4.3.
We also experimented with the null heuristic,
which always estimates the outside probability as
being 1.0. Times exclude the time taken to load
models.

Results are shown in Table 3. The best EASY-
CCG model is roughly four times faster than the
C&C parser2. Adding the tag dictionary caused
accuracy to drop slightly from 83.46 to 83.37, and
meant the parser failed to parse a single sentence
in the test set (“Among its provisions :”) but other
changes did not affect accuracy. The pruning in
the supertagger improves parsing speed, by limit-
ing the length of the priority queue it builds for the
agenda. Of course, we could use a backoff model
to ensure full coverage (analogously to adaptive
supertagging), but we leave that to future work.
Using our A∗ heuristic doubles the speed of pars-
ing (excluding supertagging).

To better understand the properties of our
model, we also investigate how parsing time varies
with sentence length. Unlike the cubic CKY al-
gorithm typically used by chart parsers, our A∗

search potentially takes exponential time in the
sentence length. For this experiment, we used the
Sections 02-21 of CCGBank. Sentences were di-
vided into bins of width 10, and we calculated the
average parsing time for sentences in each bin.

Results are shown in Figure 2, and demon-

2It is worth noting that the C&C parser code is written in
highly-optimized C++, compared to our simple Java imple-
mentation. It seems likely that our parser could be made sub-
stantially faster with a similar level of engineering effort.

strate that while parsing is highly efficient for sen-
tences of up to 50 words (over 95% of CCGBank),
it scales super-linearly with long sentences. In
fact, Section 00 contains a sentence of 249 words,
which took 37 seconds to parse (3 times longer
than the other 1912 sentences put together). In
practice, this scaling is unlikely to be problematic,
as long sentences are typically filtered when pro-
cessing large corpora.

4.4 Semantic Parsing

A major motivation for CCG parsing is to exploit
its transparent interface to the semantics, allowing
syntactic parsers to do much of the work of seman-
tic parsers. Therefore, perhaps the most relevant
measure of the performance of a CCG parser is its
effect on the accuracy of downstream applications.

We experimented with a supervised version
of Reddy et al. (2014)’s model for question-
answering on Freebase (i.e. without using Reddy
et al.’s lexicon derived from unlabelled text), us-
ing the WEBQUESTIONS dataset (Berant et al.,
2013)3. The model learns to map CCG parses to
database queries. We compare the performance of
the QA system using both our parser and C&C,
taking the 10-best parses from each parser for
each sentence. Syntactic question parsing models
were trained from the combination of 10 copies
of Rimell and Clark (2008)’s question dataset and
one copy of the CCGBank

The accuracy of Reddy et al. (2014)’s model
varies significantly between iterations of the train-
ing data. Rather than tune the number of iterations,
we instead measure the accuracy after each iter-
ation. We experimented with the models’ 1-best
answers, and the oracle accuracy of their 100 best
answers. The oracle accuracy gives a better indi-
cation of the performance of the parser, by miti-
gating errors caused by the semantic component.

Results are shown in Figure 3, and demonstrate
that using EASYCCG can lead to better down-
stream performance than the C&C parser. The im-
provement is particularly large on oracle accuracy,
increasing the upper bound on the performance of
the semantic parser by around 4 points.

5 Related Work

CCG parsing has been the subject of much re-
search. We have already described the C&C pars-

3Using the Business, Film and People domains, with 1115
questions for training and 570 for testing.

996



2 4 6 8 10
40

42

44

46

48

50

Iteration

F1
-s

co
re

C&C
EASYCCG

2 4 6 8 10
54

56

58

60

62

64

Iteration

10
0-

be
st

O
ra

cl
e

F1
-s

co
re

C&C
EASYCCG

Figure 3: Question Answering accuracy per iteration of Reddy et al. (2014)’s supervised model.

ing model. Kummerfeld et al. (2010) showed that
the speed of the C&C parser can be improved
with domain-specific self-training—similar im-
provements may be possible applying this tech-
nique to our model. Auli and Lopez (2011a)
have achieved the best CCG parsing accuracy, by
allowing the parser and supertagger to perform
joint inference (though there is a significant speed
penalty). Auli and Lopez (2011b) were the first to
use A∗ parsing for CCG, but their system is both
much slower and less accurate than ours (due to a
different model and a different A∗ heuristic). Kr-
ishnamurthy and Mitchell (2014) show how CCG
parsing can be improved by jointly modelling the
syntax and semantics. Fowler and Penn (2010)
apply the Petrov parser to CCG, making a small
improvement in accuracy over the C&C parser,
at the cost of a 300-fold speed decrease. Zhang
and Clark (2011) and Xu et al. (2014) explored
shift-reduce CCG parsing, but despite the use of a
linear-time algorithm, parsing speed in practice is
significantly slower than the C&C parser.

Parsers based on supertagging models have pre-
viously been applied to other strongly lexical-
ized formalisms, such as to LTAG (Bangalore and
Joshi, 1999) and to HPSG (Ninomiya et al., 2006).
A major contribution of our work over these is
showing that factoring models on lexical cate-
gories allows fast and exact A∗ parsing, without
the need for beam search. Our parsing approach
could be applied to any strongly lexicalized for-
malism.

Our work fits into a tradition of attempting to
simplify complex models without sacrificing per-
formance. Klein and Manning (2003b) showed
that unlexicalized parsers were only slightly less
accurate than their lexicalized counterparts. Col-

lobert et al. (2011) showed how a range of NLP
tagging tasks could be performed at high accu-
racy using a small feature set based on vector-
space word embeddings. However, the extension
of this work to phrase-structure parsing (Collobert,
2011) required a more complex model, and did not
match the performance of traditional parsing tech-
niques. We achieve state-of-the-art results using
the same feature set and a simpler model by ex-
ploiting CCG’s lexicalized nature, which makes it
more natural to delegate parsing decisions to a tag-
ging model.

Other parsing research has focused on build-
ing fast parsers for web-scale processing, typically
using dependency grammars (e.g. Nivre (2003)).
CCG has some advantages over dependency gram-
mars, such as supporting surface-compositional
semantics. The fastest dependency parsers use
an easy-first strategy, in which edges are added
greedily in order of their score, with O(nlog(n))
complexity (Goldberg and Elhadad, 2010; Tratz
and Hovy, 2011). This strategy is reminiscent of
our A∗ search, which expands the chart in a best-
first order. A∗ has higher asymptotic complexity,
but finds a globally optimal solution.

6 Future Work

We believe that our model opens several interest-
ing directions for future research.

One interesting angle would be to increase the
amount of information in CCGBank’s lexical en-
tries, to further reduce the search space for the
parser. For example, PP categories could be dis-
tinguished with the relevant preposition as a fea-
ture; punctuation and coordination could be given
more detailed categories to avoid needing their
own combinators, and slashes could be extended

997



with Baldridge and Kruijff (2003)’s multi-modal
extensions to limit over-generation. Honnibal and
Curran (2009) show how unary rules can be lexi-
calized in CCG. Such improvements may improve
both the speed and accuracy of our model.

Because our parser is factored on a unigram tag-
ging model, it can be trained from isolated anno-
tated words, and does not require annotated parse
trees or full sentences. Reducing the requirements
for training data eases the task for human annota-
tors. It may also make the model more amenable
to semi-supervised approaches to CCG parsing,
which have typically focused on extending the lex-
icon (Thomforde and Steedman, 2011; Deoskar et
al., 2014). Finally, it may make it easier to convert
other annotated resources, such as UCCA (Abend
and Rappoport, 2013) or AMR (Banarescu et al.,
2013), to CCG training data—as only specific
words need to be converted, rather than full sen-
tences.

Our model is weak at certain kinds of deci-
sions, e.g. coordination-scope ambiguities or non-
local attachments. Incorporating specific models
for such decisions may improve accuracy, while
still allowing fast and exact search—for example,
we intend to try including Coppola et al. (2011)’s
model for prepositional phrase attachment.

7 Conclusions

We have shown that a simple, principled, deter-
ministic parser combined with a tagging model
can parse an expressive linguistic formalism with
high speed and accuracy. Although accuracy
is not state-of-the-art on CCGBank, our model
gives excellent performance on two out-of-domain
datasets, and improves the accuracy of a question-
answering system. We have shown that this model
allows an efficient heuristic for A∗ parsing, which
makes parsing extremely fast, and may enable
logic-based distributional semantics to scale to
larger corpora. Our methods are directly applica-
ble to other lexicalized formalisms, such as LTAG,
LFG and HPSG.

Acknowledgments

We would like to thank Tejaswini Deoskar, Bharat
Ram Ambati, Michael Roth and the anonymous
reviewers for helpful feedback on an earlier ver-
sion of this paper, and Siva Reddy for running the
semantic parsing experiments.

References
Omri Abend and Ari Rappoport. 2013. Universal con-

ceptual cognitive annotation (ucca). In Proceedings
of ACL.

Michael Auli and Adam Lopez. 2011a. A compari-
son of loopy belief propagation and dual decompo-
sition for integrated CCG supertagging and parsing.
In Proceedings of the 49th Annual Meeting of the
Association for Computational Linguistics: Human
Language Technologies-Volume 1, pages 470–480.
Association for Computational Linguistics.

Michael Auli and Adam Lopez. 2011b. Efficient CCG
parsing: A* versus adaptive supertagging. In Pro-
ceedings of the 49th Annual Meeting of the Associ-
ation for Computational Linguistics: Human Lan-
guage Technologies-Volume 1, pages 1577–1585.
Association for Computational Linguistics.

Jason Baldridge and Geert-Jan M Kruijff. 2003. Multi-
modal combinatory categorial grammar. In Pro-
ceedings of the tenth conference on European chap-
ter of the Association for Computational Linguistics-
Volume 1, pages 211–218. Association for Compu-
tational Linguistics.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract Meaning Representation
for sembanking. In Proceedings of the 7th Linguis-
tic Annotation Workshop and Interoperability with
Discourse, Sofia, Bulgaria, August. Association for
Computational Linguistics.

Srinivas Bangalore and Aravind K Joshi. 1999. Su-
pertagging: An approach to almost parsing. Com-
putational linguistics, 25(2):237–265.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on freebase from
question-answer pairs. In Proceedings of EMNLP.

Johan Bos. 2008. Wide-coverage semantic analy-
sis with boxer. In Johan Bos and Rodolfo Del-
monte, editors, Semantics in Text Processing. STEP
2008 Conference Proceedings, Research in Compu-
tational Semantics, pages 277–286. College Publi-
cations.

Stephen Clark and James R Curran. 2007. Wide-
coverage efficient statistical parsing with CCG
and log-linear models. Computational Linguistics,
33(4):493–552.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
scratch. The Journal of Machine Learning Re-
search, 12:2493–2537.

Ronan Collobert. 2011. Deep learning for efficient dis-
criminative parsing. In International Conference on
Artificial Intelligence and Statistics, number EPFL-
CONF-192374.

998



Gregory F Coppola, Alexandra Birch, Tejaswini De-
oskar, and Mark Steedman. 2011. Simple semi-
supervised learning for prepositional phrase attach-
ment. In Proceedings of the 12th International Con-
ference on Parsing Technologies, pages 129–139.
Association for Computational Linguistics.

Tejaswini Deoskar, Christos Christodoulopoulos,
Alexandra Birch, and Mark Steedman. 2014.
Generalizing a Strongly Lexicalized Parser using
Unlabeled Data. In Proceedings of the 14th Con-
ference of the European Chapter of the Association
for Computational Linguistics. Association for
Computational Linguistics.

Jason Eisner. 1996. Efficient normal-form parsing for
combinatory categorial grammar. In Proceedings of
the 34th annual meeting on Association for Com-
putational Linguistics, pages 79–86. Association for
Computational Linguistics.

Timothy AD Fowler and Gerald Penn. 2010. Accu-
rate context-free parsing with combinatory catego-
rial grammar. In Proceedings of the 48th Annual
Meeting of the Association for Computational Lin-
guistics, pages 335–344. Association for Computa-
tional Linguistics.

Yoav Goldberg and Michael Elhadad. 2010. An effi-
cient algorithm for easy-first non-directional depen-
dency parsing. In Human Language Technologies:
The 2010 Annual Conference of the North American
Chapter of the Association for Computational Lin-
guistics, pages 742–750. Association for Computa-
tional Linguistics.

Brian Harrington. 2010. A semantic network ap-
proach to measuring relatedness. In Proceedings
of the 23rd International Conference on Compu-
tational Linguistics: Posters, COLING ’10, pages
356–364. Association for Computational Linguis-
tics.

Julia Hockenmaier and Mark Steedman. 2007. CCG-
bank: a corpus of CCG derivations and dependency
structures extracted from the Penn Treebank. Com-
putational Linguistics, 33(3):355–396.

Julia Hockenmaier. 2003. Data and models for statis-
tical parsing with combinatory categorial grammar.

Matthew Honnibal and James R Curran. 2009. Fully
lexicalising CCGbank with hat categories. In Pro-
ceedings of the 2009 Conference on Empirical Meth-
ods in Natural Language Processing: Volume 3-
Volume 3, pages 1212–1221. Association for Com-
putational Linguistics.

Dan Klein and Christopher D Manning. 2003a. A*
parsing: fast exact viterbi parse selection. In
Proceedings of the 2003 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics on Human Language Technology-
Volume 1, pages 40–47. Association for Computa-
tional Linguistics.

Dan Klein and Christopher D Manning. 2003b. Ac-
curate unlexicalized parsing. In Proceedings of the
41st Annual Meeting on Association for Computa-
tional Linguistics-Volume 1, pages 423–430. Asso-
ciation for Computational Linguistics.

Jayant Krishnamurthy and Tom M Mitchell. 2014.
Joint syntactic and semantic parsing with combina-
tory categorial grammar. June.

Jonathan K. Kummerfeld, Jessika Roesner, Tim Daw-
born, James Haggerty, James R. Curran, and
Stephen Clark. 2010. Faster parsing by supertag-
ger adaptation. In Proceedings of the 48th Annual
Meeting of the Association for Computational Lin-
guistics, ACL ’10, pages 345–355. Association for
Computational Linguistics.

Mike Lewis and Mark Steedman. 2013a. Combined
Distributional and Logical Semantics. Transactions
of the Association for Computational Linguistics,
1:179–192.

Mike Lewis and Mark Steedman. 2013b. Unsuper-
vised induction of cross-lingual semantic relations.
In Proceedings of the 2013 Conference on Empiri-
cal Methods in Natural Language Processing, pages
681–692, Seattle, Washington, USA, October. Asso-
ciation for Computational Linguistics.

Mike Lewis and Mark Steedman. 2014. Improved
CCG parsing with Semi-supervised Supertagging.
Transactions of the Association for Computational
Linguistics (to appear).

Takashi Ninomiya, Takuya Matsuzaki, Yoshimasa Tsu-
ruoka, Yusuke Miyao, and Jun’ichi Tsujii. 2006.
Extremely lexicalized models for accurate and fast
hpsg parsing. In Proceedings of the 2006 Confer-
ence on Empirical Methods in Natural Language
Processing, EMNLP ’06, pages 155–163, Strouds-
burg, PA, USA. Association for Computational Lin-
guistics.

Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
8th International Workshop on Parsing Technologies
(IWPT.

Sampo Pyysalo, Filip Ginter, Juho Heimonen, Jari
Björne, Jorma Boberg, Jouni Järvinen, and Tapio
Salakoski. 2007. Bioinfer: a corpus for information
extraction in the biomedical domain. BMC bioinfor-
matics, 8(1):50.

Siva Reddy, Mirella Lapata, and Mark Steedman.
2014. Large-scale Semantic Parsing without
Question-Answer Pairs. Transactions of the Asso-
ciation for Computational Linguistics (to appear).

Laura Rimell and Stephen Clark. 2008. Adapt-
ing a lexicalized-grammar parser to contrasting do-
mains. In Proceedings of the Conference on Em-
pirical Methods in Natural Language Processing,
pages 475–484. Association for Computational Lin-
guistics.

999



Mark Steedman. 2000. The Syntactic Process. MIT
Press.

Mark Steedman. 2012. Taking Scope: The Natural
Semantics of Quantifiers. MIT Press.

Emily Thomforde and Mark Steedman. 2011. Semi-
supervised CCG lexicon extension. In Proceedings
of the Conference on Empirical Methods in Natu-
ral Language Processing, pages 1246–1256. Asso-
ciation for Computational Linguistics.

Stephen Tratz and Eduard Hovy. 2011. A fast, effec-
tive, non-projective, semantically-enriched parser.
In Proceedings of EMNLP.

Joseph Turian, Lev Ratinov, and Yoshua Bengio. 2010.
Word representations: a simple and general method
for semi-supervised learning. In Proceedings of the
48th Annual Meeting of the Association for Compu-
tational Linguistics, pages 384–394. Association for
Computational Linguistics.

Wenduan Xu, Stephen Clark, and Yue Zhang. 2014.
Shift-reduce ccg parsing with a dependency model.
In Proceedings of the 52nd Annual Meeting of
the Association for Computational Linguistics (ACL
2014). Association for Computational Linguistics,
June.

Yue Zhang and Stephen Clark. 2011. Shift-reduce
CCG parsing. In Proceedings of the 49th Annual
Meeting of the Association for Computational Lin-
guistics: Human Language Technologies-Volume 1,
pages 683–692. Association for Computational Lin-
guistics.

1000


