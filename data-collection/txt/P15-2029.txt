



















































Dependency-based Convolutional Neural Networks for Sentence Embedding


Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics
and the 7th International Joint Conference on Natural Language Processing (Short Papers), pages 174–179,

Beijing, China, July 26-31, 2015. c©2015 Association for Computational Linguistics

Dependency-based Convolutional Neural Networks
for Sentence Embedding∗

Mingbo Ma† Liang Huang† ‡
†Graduate Center & Queens College

City University of New York
{mma2,lhuang}gc.cuny.edu

Bing Xiang‡ Bowen Zhou‡
‡IBM Watson Group

T. J. Watson Research Center, IBM
{lhuang,bingxia,zhou}@us.ibm.com

Abstract

In sentence modeling and classification,
convolutional neural network approaches
have recently achieved state-of-the-art re-
sults, but all such efforts process word vec-
tors sequentially and neglect long-distance
dependencies. To combine deep learn-
ing with linguistic structures, we pro-
pose a dependency-based convolution ap-
proach, making use of tree-based n-grams
rather than surface ones, thus utlizing non-
local interactions between words. Our
model improves sequential baselines on all
four sentiment and question classification
tasks, and achieves the highest published
accuracy on TREC.

1 Introduction
Convolutional neural networks (CNNs), originally
invented in computer vision (LeCun et al., 1995),
has recently attracted much attention in natural
language processing (NLP) on problems such as
sequence labeling (Collobert et al., 2011), seman-
tic parsing (Yih et al., 2014), and search query
retrieval (Shen et al., 2014). In particular, recent
work on CNN-based sentence modeling (Kalch-
brenner et al., 2014; Kim, 2014) has achieved ex-
cellent, often state-of-the-art, results on various
classification tasks such as sentiment, subjectivity,
and question-type classification. However, despite
their celebrated success, there remains a major
limitation from the linguistics perspective: CNNs,
being invented on pixel matrices in image process-
ing, only consider sequential n-grams that are con-
secutive on the surface string and neglect long-
distance dependencies, while the latter play an im-
portant role in many linguistic phenomena such as
negation, subordination, and wh-extraction, all of
which might dully affect the sentiment, subjectiv-
ity, or other categorization of the sentence.

∗ This work was done at both IBM and CUNY, and was supported in
part by DARPA FA8750-13-2-0041 (DEFT), and NSF IIS-1449278. We thank
Yoon Kim for sharing his code, and James Cross and Kai Zhao for discussions.

Indeed, in the sentiment analysis literature, re-
searchers have incorporated long-distance infor-
mation from syntactic parse trees, but the results
are somewhat inconsistent: some reported small
improvements (Gamon, 2004; Matsumoto et al.,
2005), while some otherwise (Dave et al., 2003;
Kudo and Matsumoto, 2004). As a result, syn-
tactic features have yet to become popular in the
sentiment analysis community. We suspect one
of the reasons for this is data sparsity (according
to our experiments, tree n-grams are significantly
sparser than surface n-grams), but this problem
has largely been alleviated by the recent advances
in word embedding. Can we combine the advan-
tages of both worlds?

So we propose a very simple dependency-based
convolutional neural networks (DCNNs). Our
model is similar to Kim (2014), but while his se-
quential CNNs put a word in its sequential con-
text, ours considers a word and its parent, grand-
parent, great-grand-parent, and siblings on the de-
pendency tree. This way we incorporate long-
distance information that are otherwise unavail-
able on the surface string.

Experiments on three classification tasks
demonstrate the superior performance of our
DCNNs over the baseline sequential CNNs. In
particular, our accuracy on the TREC dataset
outperforms all previously published results
in the literature, including those with heavy
hand-engineered features.

Independently of this work, Mou et al. (2015,
unpublished) reported related efforts; see Sec. 3.3.

2 Dependency-based Convolution

The original CNN, first proposed by LeCun et
al. (1995), applies convolution kernels on a se-
ries of continuous areas of given images, and was
adapted to NLP by Collobert et al. (2011). Fol-
lowing Kim (2014), one dimensional convolution
operates the convolution kernel in sequential order
in Equation 1, where xi ∈ Rd represents the d di-
mensional word representation for the i-th word in

174



Despite the film ’s shortcomings the stories are quietly moving .

ROOT

Figure 1: Running example from Movie Reviews dataset.

mensional word representation for the i-th word in
the sentence, and ⊕ is the concatenation operator.
Therefore x̃i,j refers to concatenated word vector
from the i-th word to the (i + j)-th word:

x̃i,j = xi ⊕ xi+1 ⊕ · · · ⊕ xi+j (1)
Sequential word concatenation x̃i,j works as

n-gram models which feeds local information into
convolution operations. However, this setting can
not capture long-distance relationships unless we
enlarge the window indefinitely which would in-
evitably cause the data sparsity problem.

In order to capture the long-distance dependen-
cies we propose the dependency tree-based con-
volution model (DTCNN). Figure 1 illustrates an
example from the Movie Reviews (MR) dataset
(Pang and Lee, 2005). The sentiment of this sen-
tence is obviously positive, but this is quite dif-
ficult for sequential CNNs because many n-gram
windows would include the highly negative word
“shortcomings”, and the distance between “De-
spite” and “shortcomings” is quite long. DTCNN,
however, could capture the tree-based bigram
“Despite – shortcomings”, thus flipping the senti-
ment, and the tree-based trigram “ROOT – moving
– stories”, which is highly positive.

2.1 Convolution on Ancestor Paths
We define our concatenation based on the depen-
dency tree for a given modifier xi:

xi,k = xi ⊕ xp(i) ⊕ · · · ⊕ xpk−1(i) (2)
where function pk(i) returns the i-th word’s k-th
ancestor index, which is recursively defined as:

pk(i) =

{
p(pk−1(i)) if k > 0
i if k = 0

(3)

Figure 2 (left) illustrates ancestor paths patterns
with various orders. We always start the convo-
lution with xi and concatenate with its ancestors.
If the root node is reached, we add “ROOT” as
dummy ancestors (vertical padding).

For a given tree-based concatenated word se-
quence xi,k, the convolution operation applies a
filter w ∈ Rk×d to xi,k with a bias term b de-
scribed in equation 4:

ci = f(w · xi,k + b) (4)

where f is a non-linear activation function such as
rectified linear unit (ReLu) or sigmoid function.
The filter w is applied to each word in the sen-
tence, generating the feature map c ∈ Rl:

c = [c1, c2, · · · , cl] (5)
where l is the length of the sentence.

2.2 Max-Over-Tree Pooling and Dropout
The filters convolve with different word concate-
nation in Eq. 4 can be regarded as pattern detec-
tion: only the most similar pattern between the
words and the filter could return the maximum ac-
tivation. In sequential CNNs, max-over-time pool-
ing (Collobert et al., 2011; Kim, 2014) operates
over the feature map to get the maximum acti-
vation ĉ = max c representing the entire feature
map. Our DTCNNs also pool the maximum ac-
tivation from feature map to detect the strongest
activation over the whole tree (i.e., over the whole
sentence). Since the tree no longer defines a se-
quential “time” direction, we refer to our pooling
as “max-over-tree” pooling.

In order to capture enough variations, we ran-
domly initialize the set of filters to detect different
structure patterns. Each filter’s height is the num-
ber of words considered and the width is always
equal to the dimensionality d of word representa-
tion. Each filter will be represented by only one
feature after max-over-tree pooling. After a series
of convolution with different filter with different
heights, multiple features carry different structural
information become the final representation of the
input sentence. Then, this sentence representation
is passed to a fully connected soft-max layer and
outputs a distribution over different labels.

Neural networks often suffer from overtrain-
ing. Following Kim (2014), we employ random
dropout on penultimate layer (Hinton et al., 2012).
in order to prevent co-adaptation of hidden units.
In our experiments, we set our drop out rate as 0.5
and learning rate as 0.95 by default. Following
Kim (2014), training is done through stochastic
gradient descent over shuffled mini-batches with
the Adadelta update rule (Zeiler, 2012).

2.3 Convolution on Siblings
Ancestor paths alone is not enough to capture
many linguistic phenomena such as conjunction.

Figure 1: Dependency tree of an example sentence from the Movie Reviews dataset.

the sentence, and ⊕ is the concatenation operator.
Therefore x̃i,j refers to concatenated word vector
from the i-th word to the (i + j)-th word:

x̃i,j = xi ⊕ xi+1 ⊕ · · · ⊕ xi+j (1)
Sequential word concatenation x̃i,j works as

n-gram models which feeds local information into
convolution operations. However, this setting can
not capture long-distance relationships unless we
enlarge the window indefinitely which would in-
evitably cause the data sparsity problem.

In order to capture the long-distance dependen-
cies we propose the dependency-based convolu-
tion model (DCNN). Figure 1 illustrates an exam-
ple from the Movie Reviews (MR) dataset (Pang
and Lee, 2005). The sentiment of this sentence
is obviously positive, but this is quite difficult for
sequential CNNs because many n-gram windows
would include the highly negative word “short-
comings”, and the distance between “Despite” and
“shortcomings” is quite long. DCNN, however,
could capture the tree-based bigram “Despite –
shortcomings”, thus flipping the sentiment, and
the tree-based trigram “ROOT – moving – sto-
ries”, which is highly positive.

2.1 Convolution on Ancestor Paths
We define our concatenation based on the depen-
dency tree for a given modifier xi:

xi,k = xi ⊕ xp(i) ⊕ · · · ⊕ xpk−1(i) (2)
where function pk(i) returns the i-th word’s k-th
ancestor index, which is recursively defined as:

pk(i) =

{
p(pk−1(i)) if k > 0
i if k = 0

(3)

Figure 2 (left) illustrates ancestor paths patterns
with various orders. We always start the convo-
lution with xi and concatenate with its ancestors.
If the root node is reached, we add “ROOT” as
dummy ancestors (vertical padding).

For a given tree-based concatenated word se-
quence xi,k, the convolution operation applies a
filter w ∈ Rk×d to xi,k with a bias term b de-
scribed in equation 4:

ci = f(w · xi,k + b) (4)

where f is a non-linear activation function such as
rectified linear unit (ReLu) or sigmoid function.
The filter w is applied to each word in the sen-
tence, generating the feature map c ∈ Rl:

c = [c1, c2, · · · , cl] (5)

where l is the length of the sentence.

2.2 Max-Over-Tree Pooling and Dropout

The filters convolve with different word concate-
nation in Eq. 4 can be regarded as pattern detec-
tion: only the most similar pattern between the
words and the filter could return the maximum ac-
tivation. In sequential CNNs, max-over-time pool-
ing (Collobert et al., 2011; Kim, 2014) operates
over the feature map to get the maximum acti-
vation ĉ = max c representing the entire feature
map. Our DCNNs also pool the maximum activa-
tion from feature map to detect the strongest ac-
tivation over the whole tree (i.e., over the whole
sentence). Since the tree no longer defines a se-
quential “time” direction, we refer to our pooling
as “max-over-tree” pooling.

In order to capture enough variations, we ran-
domly initialize the set of filters to detect different
structure patterns. Each filter’s height is the num-
ber of words considered and the width is always
equal to the dimensionality d of word representa-
tion. Each filter will be represented by only one
feature after max-over-tree pooling. After a series
of convolution with different filter with different
heights, multiple features carry different structural
information become the final representation of the
input sentence. Then, this sentence representation
is passed to a fully connected soft-max layer and
outputs a distribution over different labels.

Neural networks often suffer from overtrain-
ing. Following Kim (2014), we employ random
dropout on penultimate layer (Hinton et al., 2014).
in order to prevent co-adaptation of hidden units.
In our experiments, we set our drop out rate as 0.5
and learning rate as 0.95 by default. Following
Kim (2014), training is done through stochastic
gradient descent over shuffled mini-batches with
the Adadelta update rule (Zeiler, 2012).

175



ancestor paths siblings
n pattern(s) n pattern(s)

3
m h g

2
s m

4
m h g g2

3
s m h t s m

5
m h g g2 g3

4
t s m h s m h g

Table 1: Tree-based convolution patterns. Word concatenation always starts with m, while h, g, and g2

denote parent, grand parent, and great-grand parent, etc., and “ ” denotes words excluded in convolution.

2.3 Convolution on Siblings
Ancestor paths alone is not enough to capture
many linguistic phenomena such as conjunction.
Inspired by higher-order dependency parsing (Mc-
Donald and Pereira, 2006; Koo and Collins, 2010),
we also incorporate siblings for a given word in
various ways. See Table 1 (right) for details.

2.4 Combined Model
Powerful as it is, structural information still does
not fully cover sequential information. Also, pars-
ing errors (which are common especially for in-
formal text such as online reviews) directly affect
DTCNN performance while sequential n-grams
are always correctly observed. To best exploit
both information, we want to combine both mod-
els. The easiest way of combination is to con-
catenate these representations together, then feed
into fully connected soft-max neural networks. In
these cases, combine with different feature from
different type of sources could stabilize the perfor-
mance. The final sentence representation is thus:

ĉ = [ĉ(1)a , ..., ĉ
(Na)
a︸ ︷︷ ︸

ancestors

; ĉ(1)s , ..., ĉ
(Ns)
s︸ ︷︷ ︸

siblings

; ĉ(1), ..., ĉ(N)︸ ︷︷ ︸
sequential

]

where Na, Ns, and N are the number of ancestor,
sibling, and sequential filters. In practice, we use
100 filters for each template in Table 1. The fully
combined representation is 1100-dimensional by
contrast to 300-dimensional for sequential CNN.

3 Experiments
We implement our DTCNN on top of the open
source CNN code by Kim (2014).1 Table 2
summarizes our results in the context of other
high-performing efforts in the literature. We use
three benchmark datasets in two categories: senti-
ment analysis on both Movie Review (MR) (Pang
and Lee, 2005) and Stanford Sentiment Treebank

1https://github.com/yoonkim/CNN sentence

(SST-1) (Socher et al., 2013) datasets, and ques-
tion classification on TREC (Li and Roth, 2002).

For all datasets, we first obtain the dependency
parse tree from Stanford parser (Manning et al.,
2014).2 Different window size for different choice
of convolution are shown in Table 1. For the
dataset without a development set (MR), we ran-
domly choose 10% of the training data to indicate
early stopping. In order to have a fare compari-
son with baseline CNN, we also use 3 to 5 as our
window size. Most of our results are generated
by GPU due to its efficiency, however CPU poten-
tially could generate better results.3 Our imple-
mentation can be found on Github.4

3.1 Sentiment Analysis
Both sentiment analysis datasets (MR and SST-
1) are based on movie reviews. The differences
between them are mainly in the different num-
bers of categories and whether the standard split
is given. There are 10,662 sentences in the MR
dataset. Each instance is labeled positive or neg-
ative, and in most cases contains one sentence.
Since no standard data split is given, following the
literature we use 10 fold cross validation to include
every sentence in training and testing at least once.
Concatenating with sibling and sequential infor-
mation obviously improves tree-based CNNs, and
the final model outperforms the baseline sequen-
tial CNNs by 0.4, and ties with Zhu et al. (2015).

Different from MR, the Stanford Sentiment
Treebank (SST-1) annotates finer-grained labels,
very positive, positive, neutral, negative and very
negative, on an extension of the MR dataset. There
are 11,855 sentences with standard split. Our
model achieves an accuracy of 49.5 which is sec-
ond only to Irsoy and Cardie (2014). We set batch
size to 100 for this task.

2The phrase-structure trees in SST-1 are actually automat-
ically parsed, and thus can not be used as gold-standard trees.

3GPU only supports float32 while CPU supports float64.
4https://github.com/cosmmb/DTCNN

Figure 2: Convolution patterns on trees. Word concatenation always starts with m, while h, g, and g2

denote parent, grand parent, and great-grand parent, etc., and “ ” denotes words excluded in convolution.

2.3 Convolution on Siblings
Ancestor paths alone is not enough to capture
many linguistic phenomena such as conjunction.
Inspired by higher-order dependency parsing (Mc-
Donald and Pereira, 2006; Koo and Collins, 2010),
we also incorporate siblings for a given word in
various ways. See Figure 2 (right) for details.

2.4 Combined Model
Powerful as it is, structural information still does
not fully cover sequential information. Also, pars-
ing errors (which are common especially for in-
formal text such as online reviews) directly affect
DCNN performance while sequential n-grams are
always correctly observed. To best exploit both in-
formation, we want to combine both models. The
easiest way of combination is to concatenate these
representations together, then feed into fully con-
nected soft-max neural networks. In these cases,
combine with different feature from different type
of sources could stabilize the performance. The
final sentence representation is thus:

ĉ = [ĉ(1)a , ..., ĉ
(Na)
a︸ ︷︷ ︸

ancestors

; ĉ(1)s , ..., ĉ
(Ns)
s︸ ︷︷ ︸

siblings

; ĉ(1), ..., ĉ(N)︸ ︷︷ ︸
sequential

]

where Na, Ns, and N are the number of ancestor,
sibling, and sequential filters. In practice, we use
100 filters for each template in Figure 2 . The fully
combined representation is 1,100-dimensional by
contrast to 300-dimensional for sequential CNN.

3 Experiments
Table 1 summarizes results in the context of other
high-performing efforts in the literature. We use
three benchmark datasets in two categories: senti-
ment analysis on both Movie Review (MR) (Pang
and Lee, 2005) and Stanford Sentiment Treebank
(SST-1) (Socher et al., 2013) datasets, and ques-
tion classification on TREC (Li and Roth, 2002).

For all datasets, we first obtain the dependency
parse tree from Stanford parser (Manning et al.,
2014).1 Different window size for different choice
of convolution are shown in Figure 2. For the
dataset without a development set (MR), we ran-
domly choose 10% of the training data to indicate
early stopping. In order to have a fare compari-
son with baseline CNN, we also use 3 to 5 as our
window size. Most of our results are generated by
GPU due to its efficiency, however CPU could po-
tentially get better results.2 Our implementation,
on top of Kim (2014)’s code,3 will be released.4

3.1 Sentiment Analysis
Both sentiment analysis datasets (MR and SST-
1) are based on movie reviews. The differences
between them are mainly in the different num-
bers of categories and whether the standard split
is given. There are 10,662 sentences in the MR
dataset. Each instance is labeled positive or neg-
ative, and in most cases contains one sentence.
Since no standard data split is given, following the
literature we use 10 fold cross validation to include
every sentence in training and testing at least once.
Concatenating with sibling and sequential infor-
mation obviously improves DCNNs, and the final
model outperforms the baseline sequential CNNs
by 0.4, and ties with Zhu et al. (2015).

Different from MR, the Stanford Sentiment
Treebank (SST-1) annotates finer-grained labels,
very positive, positive, neutral, negative and very
negative, on an extension of the MR dataset. There
are 11,855 sentences with standard split. Our
model achieves an accuracy of 49.5 which is sec-
ond only to Irsoy and Cardie (2014).

1The phrase-structure trees in SST-1 are actually automatically parsed,
and thus can not be used as gold-standard trees.

2GPU only supports float32 while CPU supports float64.
3
https://github.comw/yoonkim/CNN_sentence

4
https://github.com/cosmmb/DCNN

176



Category Model MR SST-1 TREC TREC-2

This work
DCNNs: ancestor 80.4† 47.7† 95.4† 88.4†

DCNNs: ancestor+sibling 81.7† 48.3† 95.6† 89.0†
DCNNs: ancestor+sibling+sequential 81.9 49.5 95.4† 88.8†

CNNs
CNNs-non-static (Kim, 2014) – baseline 81.5 48.0 93.6 86.4∗

CNNs-multichannel (Kim, 2014) 81.1 47.4 92.2 86.0∗

Deep CNNs (Kalchbrenner et al., 2014) - 48.5 93.0 -

Recursive NNs
Recursive Autoencoder (Socher et al., 2011) 77.7 43.2 - -
Recursive Neural Tensor (Socher et al., 2013) - 45.7 - -
Deep Recursive NNs (Irsoy and Cardie, 2014) - 49.8 - -

Recurrent NNs LSTM on tree (Zhu et al., 2015) 81.9 48.0 - -
Other deep learning Paragraph-Vec (Le and Mikolov, 2014) - 48.7 - -
Hand-coded rules SVMS (Silva et al., 2011) - 95.0 90.8

Table 1: Results on Movie Review (MR), Stanford Sentiment Treebank (SST-1), and TREC datasets.
TREC-2 is TREC with fine grained labels. †Results generated by GPU (all others generated by CPU).
∗Results generated from Kim (2014)’s implementation.

3.2 Question Classification
In the TREC dataset, the entire dataset of 5,952
sentences are classified into the following 6 cate-
gories: abbreviation, entity, description, location
and numeric. In this experiment, DCNNs easily
outperform any other methods even with ancestor
convolution only. DCNNs with sibling achieve the
best performance in the published literature. DC-
NNs combined with sibling and sequential infor-
mation might suffer from overfitting on the train-
ing data based on our observation. One thing
to note here is that our best result even exceeds
SVMS (Silva et al., 2011) with 60 hand-coded
rules.

The TREC dataset also provides subcategories
such as numeric:temperature, numeric:distance,
and entity:vehicle. To make our task more real-
istic and challenging, we also test the proposed
model with respect to the 50 subcategories. There
are obvious improvements over sequential CNNs
from the last column of Table 1. Like ours, Silva
et al. (2011) is a tree-based system but it uses
constituency trees compared to ours dependency
trees. They report a higher fine-grained accuracy
of 90.8 but their parser is trained only on the Ques-
tionBank (Judge et al., 2006) while we used the
standard Stanford parser trained on both the Penn
Treebank and QuestionBank. Moreover, as men-
tioned above, their approach is rule-based while
ours is automatically learned.

3.3 Discussions and Examples
Compared with sentiment analysis, the advantage
of our proposed model is obviously more substan-
tial on the TREC dataset. Based on our error anal-
ysis, we conclude that this is mainly due to the

Category Model MR SST-1 TREC TREC-2

This work
DTCNNs: ancestor 80.4† 47.7† 95.4† 88.4†

DTCNNs: ancestor+sibling 81.7† 48.3† 95.6† 89.0†
DTCNNs: ancestor+sibling+sequential 81.9 49.5 95.4† 88.8†

CNNs
CNNs-non-static (Kim, 2014) – baseline 81.5 48.0 93.6 86.4∗

CNNs-multichannel (Kim, 2014) 81.1 47.4 92.2 86.0∗

Deep CNNs (Kalchbrenner et al., 2014) - 48.5 93.0 -

Recursive NNs
Recursive Autoencoder (Socher et al., 2011) 77.7 43.2 - -
Recursive Neural Tensor (Socher et al., 2013) - 45.7 - -
Deep Recursive NNs (Irsoy and Cardie, 2014) - 49.8 - -

Recurrent NNs LSTM on tree (Zhu et al., 2015) 81.9 48.0 - -
Other deep learning Paragraph-Vec (Le and Mikolov, 2014) - 48.7 - -
Hand-coded rules SVMS (Silva et al., 2011) - 95.0 90.8

Table 2: Results on Movie Review (MR), Stanford Sentiment Treebank (SST-1), and TREC datasets.
TREC-2 is TREC with fine grained labels. †Results generated by GPU (all others generated by CPU).
∗Results generated from Kim (2014)’s implementation.

What is Hawaii ’s state flower ?

root

(a) enty⇒ loc

What is natural gas composed of ?

root

(b) enty⇒ desc

What does a defibrillator do ?

root

(c) desc⇒ enty

Nothing plot wise is worth emailing home about

root

(d) mild negative⇒ mild positive

What is the temperature at the center of the earth ?

root

(e) NUM:temp⇒ NUM:dist

What were Christopher Columbus ’ three ships ?

root

(f) ENTY:veh⇒ LOC:other
Figure 2: Examples from TREC (a–c), SST-1 (d)
and TREC with fine-grained label (e–f) that are
misclassified by the baseline CNN but correctly
labeled by our DTCNN. For example, (a) should
be entity but is labeled location by CNN.

3.2 Question Classification
In the TREC dataset, the entire dataset of 5,952
sentences are classified into the following 6 cate-
gories: abbreviation, entity, description, location
and numeric. In this experiment, DTCNNs eas-
ily outperform any other methods even with an-
cestor convolution only. DTCNNs with sibling
achieve the best performance in the published lit-
erature. DTCNNs combined with sibling and se-
quential information might suffer from overfitting
on the training data based on our observation. One
thing to note here is that our best result even ex-
ceeds SVMS (Silva et al., 2011) with 60 hand-
coded rules. We set batch size to 210 for this task.

The TREC dataset also provides subcategories
such as numeric:temperature, numeric:distance,
and entity:vehicle. To make our task more real-
istic and challenging, we also test the proposed
model with respect to the 50 subcategories. There
are obvious improvements over sequential CNNs
from the last column of Table 2. Like ours, Silva
et al. (2011) is a tree-based system but it uses
constituency trees compared to ours dependency
trees. They report a higher fine-grained accuracy
of 90.8 but their parser is trained only on the Ques-
tionBank (Judge et al., 2006) while we used the
standard Stanford parser trained on both the Penn
Treebank and QuestionBank. Moreover, as men-
tioned above, their approach is rule-based while
ours is automatically learned. For this task, we set
batch size to 30.

3.3 Discussions and Examples
Compared with sentiment analysis, the advantage
of our proposed model is obviously more substan-
tial on the TREC dataset. Based on our error anal-

Figure 3: Examples from TREC (a–c), SST-1 (d)
and TREC with fine-grained label (e–f) that are
misclassified by the baseline CNN but correctly
labeled by our DCNN. For example, (a) should be
entity but is labeled location by CNN.

177



What is the speed hummingbirds fly ?
(noun)

root

(a) num⇒ enty

What body of water are the Canary Islands in ?

root

(b) loc⇒ enty

What position did Willie Davis play in baseball ?

root

(c) hum⇒ enty

Figure 3: Examples from TREC datasets that are
misclassified by DTCNN but correctly labeled by
baseline CNN. For example, (a) should be numer-
ical but is labeled entity by DTCNN.

ysis, we conclude that this is mainly due to the
difference of the parse tree quality between the
two tasks. In sentiment analysis, the dataset is
collected from the Rotten Tomatoes website which
includes many irregular usage of language. Some
of the sentences even come from languages other
than English. The errors in parse trees inevitably
affect the classification accuracy. However, the
parser works substantially better on the TREC
dataset since all questions are in formal written
English, and the training set for Stanford parser5

already includes the QuestionBank (Judge et al.,
2006) which includes 2,000 TREC sentences.

Figure 2 visualizes examples where CNN errs
while DTCNN does not. For example, CNN la-
bels (a) as location due to “Hawaii” and “state”,
while the long-distance backbone “What – flower”
is clearly asking for an entity. Similarly, in (d),
DTCNN captures the obviously negative tree-
based trigram “Nothing – worth – emailing”. Note
that our model also works with non-projective de-
pendency trees such as the one in (b). The last
two examples in Figure 2 visualize cases where
DTCNN outperforms the baseline CNNs in fine-
grained TREC. In example (e), the word “temper-
ature” is at second from the top and is root of a
8 word span “the ... earth”. When we use a win-
dow of size 5 for tree convolution, every words
in that span get convolved with “temperature” and
this should be the reason why DTCNN get correct.

5http://nlp.stanford.edu/software/parser-faq.shtml

What is the melting point of copper ?

root

(a) num⇒ enty and desc

What did Jesse Jackson organize ?

root

(b) hum⇒ enty and enty

What is the electrical output in Madrid , Spain ?

root

(c) enty⇒ num and num

Figure 4: Examples from TREC datasets that are
misclassified by both DTCNN and baseline CNN.
For example, (a) should be numerical but is la-
beled entity by DTCNN and description by CNN.

Figure 3 showcases examples where baseline
CNNs get better results than DTCNNs. Exam-
ple (a) is misclassified as entity by DTCNN due
to parsing/tagging error (the Stanford parser per-
forms its own part-of-speech tagging). The word
“fly” at the end of the sentence should be a verb
instead of noun, and “hummingbirds fly” should
be a relative clause modifying “speed”.

There are some sentences that are misclassified
by both the baseline CNN and DTCNN. Figure 4
shows three such examples. Example (a) is not
classified as numerical by both methods due to the
ambiguous meaning of the word “point” which is
difficult to capture by word embedding. This word
can mean location, opinion, etc. Apparently, the
numerical aspect is not captured by word embed-
ding. Example (c) might be an annotation error.

From the mistakes made by DTCNNs, we find
the performance of DTCNN is mainly limited by
two factors: the accuracy of the parser and the
quality of word embedding. Future work will fo-
cus on these two issues.

4 Conclusions and Future Work

We have presented a very simple dependency tree-
based convolution framework which outperforms
sequential CNN baselines on various classification
tasks. Extensions of this model would consider
dependency labels and constituency trees. Also,
we would evaluate on gold-standard parse trees.

Figure 4: Examples from TREC datasets that are
misclassified by DCNN but correctly labeled by
baseline CNN. For example, (a) should be numer-
ical but is labeled entity by DCNN.

difference of the parse tree quality between the
two tasks. In sentiment analysis, the dataset is
collected from the Rotten Tomatoes website which
includes many irregular usage of language. Some
of the sentences even come from languages other
than English. The errors in parse trees inevitably
affect the classification accuracy. However, the
parser works substantially better on the TREC
dataset since all questions are in formal written
English, and the training set for Stanford parser5

already includes the QuestionBank (Judge et al.,
2006) which includes 2,000 TREC sentences.

Figure 3 visualizes examples where CNN errs
while DCNN does not. For example, CNN la-
bels (a) as location due to “Hawaii” and “state”,
while the long-distance backbone “What – flower”
is clearly asking for an entity. Similarly, in (d),
DCNN captures the obviously negative tree-based
trigram “Nothing – worth – emailing”. Note that
our model also works with non-projective depen-
dency trees such as the one in (b). The last two ex-
amples in Figure 3 visualize cases where DCNN
outperforms the baseline CNNs in fine-grained
TREC. In example (e), the word “temperature” is
at second from the top and is root of a 8 word span
“the ... earth”. When we use a window of size 5
for tree convolution, every words in that span get
convolved with “temperature” and this should be
the reason why DCNN get correct.

Figure 4 showcases examples where baseline
CNNs get better results than DCNNs. Example
(a) is misclassified as entity by DCNN due to pars-
ing/tagging error (the Stanford parser performs its

5
http://nlp.stanford.edu/software/parser-faq.shtml

What is the speed hummingbirds fly ?
(noun)

root

(a) num⇒ enty

What body of water are the Canary Islands in ?

root

(b) loc⇒ enty

What position did Willie Davis play in baseball ?

root

(c) hum⇒ enty

Figure 3: Examples from TREC datasets that are
misclassified by DTCNN but correctly labeled by
baseline CNN. For example, (a) should be numer-
ical but is labeled entity by DTCNN.

ysis, we conclude that this is mainly due to the
difference of the parse tree quality between the
two tasks. In sentiment analysis, the dataset is
collected from the Rotten Tomatoes website which
includes many irregular usage of language. Some
of the sentences even come from languages other
than English. The errors in parse trees inevitably
affect the classification accuracy. However, the
parser works substantially better on the TREC
dataset since all questions are in formal written
English, and the training set for Stanford parser5

already includes the QuestionBank (Judge et al.,
2006) which includes 2,000 TREC sentences.

Figure 2 visualizes examples where CNN errs
while DTCNN does not. For example, CNN la-
bels (a) as location due to “Hawaii” and “state”,
while the long-distance backbone “What – flower”
is clearly asking for an entity. Similarly, in (d),
DTCNN captures the obviously negative tree-
based trigram “Nothing – worth – emailing”. Note
that our model also works with non-projective de-
pendency trees such as the one in (b). The last
two examples in Figure 2 visualize cases where
DTCNN outperforms the baseline CNNs in fine-
grained TREC. In example (e), the word “temper-
ature” is at second from the top and is root of a
8 word span “the ... earth”. When we use a win-
dow of size 5 for tree convolution, every words
in that span get convolved with “temperature” and
this should be the reason why DTCNN get correct.

5http://nlp.stanford.edu/software/parser-faq.shtml

What is the melting point of copper ?

root

(a) num⇒ enty and desc

What did Jesse Jackson organize ?

root

(b) hum⇒ enty and enty

What is the electrical output in Madrid , Spain ?

root

(c) enty⇒ num and num

Figure 4: Examples from TREC datasets that are
misclassified by both DTCNN and baseline CNN.
For example, (a) should be numerical but is la-
beled entity by DTCNN and description by CNN.

Figure 3 showcases examples where baseline
CNNs get better results than DTCNNs. Exam-
ple (a) is misclassified as entity by DTCNN due
to parsing/tagging error (the Stanford parser per-
forms its own part-of-speech tagging). The word
“fly” at the end of the sentence should be a verb
instead of noun, and “hummingbirds fly” should
be a relative clause modifying “speed”.

There are some sentences that are misclassified
by both the baseline CNN and DTCNN. Figure 4
shows three such examples. Example (a) is not
classified as numerical by both methods due to the
ambiguous meaning of the word “point” which is
difficult to capture by word embedding. This word
can mean location, opinion, etc. Apparently, the
numerical aspect is not captured by word embed-
ding. Example (c) might be an annotation error.

From the mistakes made by DTCNNs, we find
the performance of DTCNN is mainly limited by
two factors: the accuracy of the parser and the
quality of word embedding. Future work will fo-
cus on these two issues.

4 Conclusions and Future Work

We have presented a very simple dependency tree-
based convolution framework which outperforms
sequential CNN baselines on various classification
tasks. Extensions of this model would consider
dependency labels and constituency trees. Also,
we would evaluate on gold-standard parse trees.

Figure 5: Examples from TREC datasets that are
misclassified by both DCNN and baseline CNN.
For example, (a) should be numerical but is la-
beled entity by DCNN and description by CNN.

own part-of-speech tagging). The word “fly” at
the end of the sentence should be a verb instead of
noun, and “hummingbirds fly” should be a relative
clause modifying “speed”.

There are some sentences that are misclassified
by both the baseline CNN and DCNN. Figure 5
shows three such examples. Example (a) is not
classified as numerical by both methods due to the
ambiguous meaning of the word “point” which is
difficult to capture by word embedding. This word
can mean location, opinion, etc. Apparently, the
numerical aspect is not captured by word embed-
ding. Example (c) might be an annotation error.

Shortly before submitting to ACL 2015 we
learned Mou et al. (2015, unpublished) have inde-
pendently reported concurrent and related efforts.
Their constituency model, based on their unpub-
lished work in programming languages (Mou et
al., 2014),6 performs convolution on pretrained re-
cursive node representations rather than word em-
beddings, thus baring little, if any, resemblance to
our dependency-based model. Their dependency
model is related, but always includes a node and
all its children (resembling Iyyer et al. (2014)),
which is a variant of our sibling model and always
flat. By contrast, our ancestor model looks at the
vertical path from any word to its ancestors, being
linguistically motivated (Shen et al., 2008).

4 Conclusions
We have presented a very simple dependency-
based convolution framework which outperforms
sequential CNN baselines on modeling sentences.

6Both their 2014 and 2015 reports proposed (independently of each other
and independently of our work) the term “tree-based convolution” (TBCNN).

178



References
R. Collobert, J. Weston, L. Bottou, M. Karlen,

K. Kavukcuoglu, and P. Kuksa. 2011. Natural lan-
guage processing (almost) from scratch. Journal of
Machine Learning Research, 12.

Kushal Dave, Steve Lawrence, and David M Pennock.
2003. Mining the peanut gallery: Opinion extraction
and semantic classification of product reviews. In
Proceedings of World Wide Web.

Michael Gamon. 2004. Sentiment classification on
customer feedback data: noisy data, large feature
vectors, and the role of linguistic analysis. In Pro-
ceedings of COLING.

Geoffrey E. Hinton, Nitish Srivastava, Alex
Krizhevsky, Ilya Sutskever, and Ruslan Salakhut-
dinov. 2014. Improving neural networks by
preventing co-adaptation of feature detectors.
Journal of Machine Learning Research, 15.

Ozan Irsoy and Claire Cardie. 2014. Deep recursive
neural networks for compositionality in language.
In Advances in Neural Information Processing Sys-
tems, pages 2096–2104.

Mohit Iyyer, Jordan Boyd-Graber, Leonardo Claudino,
Richard Socher, and Hal Daumé III. 2014. A neural
network for factoid question answering over para-
graphs. In Proceedings of EMNLP.

John Judge, Aoife Cahill, and Josef van Genabith.
2006. Questionbank: Creating a corpus of parse-
annotated questions. In Proceedings of COLING.

Nal Kalchbrenner, Edward Grefenstette, and Phil Blun-
som. 2014. A convolutional neural network for
modelling sentences. In Proceedings of ACL.

Yoon Kim. 2014. Convolutional neural networks for
sentence classification. In Proceedings of EMNLP.

Terry Koo and Michael Collins. 2010. Efficient third-
order dependency parsers. In Proceedings of ACL.

Taku Kudo and Yuji Matsumoto. 2004. A boosting
algorithm for classification of semi-structured text.
In Proceedings of EMNLP.

Quoc V Le and Tomas Mikolov. 2014. Distributed
representations of sentences and documents. In Pro-
ceedings of ICML.

Y. LeCun, L. Jackel, L. Bottou, A. Brunot, C. Cortes,
J. Denker, H. Drucker, I. Guyon, U. Mller,
E. Sckinger, P. Simard, and V. Vapnik. 1995. Com-
parison of learning algorithms for handwritten digit
recognition. In Int’l Conf. on Artificial Neural Nets.

Xin Li and Dan Roth. 2002. Learning question classi-
fiers. In Proceedings of COLING.

Christopher D. Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven J. Bethard, and David Mc-
Closky. 2014. The Stanford CoreNLP natural lan-
guage processing toolkit. In Proceedings of ACL:
Demonstrations, pages 55–60.

Shotaro Matsumoto, Hiroya Takamura, and Manabu
Okumura. 2005. Sentiment classification using
word sub-sequences and dependency sub-trees. In
Proceedings of PA-KDD.

Ryan McDonald and Fernando Pereira. 2006. Online
learning of approximate dependency parsing algo-
rithms. In Proceedings of EACL.

Lili Mou, Ge Li, Zhi Jin, Lu Zhang, and Tao Wang.
2014. TBCNN: A tree-based convolutional neu-
ral network for programming language processing.
Unpublished manuscript: http://arxiv.org/
abs/1409.5718.

Lili Mou, Hao Peng, Ge Li, Yan Xu, Lu Zhang, and
Zhi Jin. 2015. Discriminative neural sentence
modeling by tree-based convolution. Unpublished
manuscript: http://arxiv.org/abs/1504.
01106v5. Version 5 dated June 2, 2015; Version 1
(“Tree-based Convolution: A New Architecture for
Sentence Modeling”) dated Apr 5, 2015.

Bo Pang and Lillian Lee. 2005. Seeing stars: Exploit-
ing class relationships for sentiment categorization
with respect to rating scales. In Proceedings of ACL,
pages 115–124.

Libin Shen, Lucas Champollion, and Aravind K Joshi.
2008. LTAG-spinal and the treebank. Language Re-
sources and Evaluation, 42(1):1–19.

Yelong Shen, Xiaodong he, Jianfeng Gao, Li Deng, and
Gregoire Mesnil. 2014. Learning semantic repre-
sentations using convolutional neural networks for
web search. In Proceedings of WWW.

J. Silva, L. Coheur, A. C. Mendes, and Andreas
Wichert. 2011. From symbolic to sub-symbolic in-
formation in question classification. Artificial Intel-
ligence Review, 35.

Richard Socher, Jeffrey Pennington, Eric H. Huang,
Andrew Y. Ng, and Christopher D. Manning. 2011.
Semi-Supervised Recursive Autoencoders for Pre-
dicting Sentiment Distributions. In Proceedings of
EMNLP 2011.

Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Christopher D. Manning, Andrew Y. Ng,
and Christopher Potts. 2013. Recursive deep mod-
els for semantic compositionality over a sentiment
treebank. In Proceedings of EMNLP 2013.

Wen-tau Yih, Xiaodong He, and Christopher Meek.
2014. Semantic parsing for single-relation question
answering. In Proceedings of ACL.

Mattgew Zeiler. 2012. Adadelta: An adaptive learning
rate method. Unpublished manuscript: http://
arxiv.org/abs/1212.5701.

Xiaodan Zhu, Parinaz Sobhani, and Hongyu Guo.
2015. Long short-term memory over tree structures.
In Proceedings of ICML.

179


