



















































Large-scale Semantic Parsing via Schema Matching and Lexicon Extension


Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 423–433,
Sofia, Bulgaria, August 4-9 2013. c©2013 Association for Computational Linguistics

Large-scale Semantic Parsing via Schema Matching and Lexicon
Extension

Qingqing Cai
Temple University

Computer and Information Sciences
qingqing.cai@temple.edu

Alexander Yates
Temple University

Computer and Information Sciences
yates@temple.edu

Abstract

Supervised training procedures for seman-
tic parsers produce high-quality semantic
parsers, but they have difficulty scaling
to large databases because of the sheer
number of logical constants for which
they must see labeled training data. We
present a technique for developing seman-
tic parsers for large databases based on
a reduction to standard supervised train-
ing algorithms, schema matching, and pat-
tern learning. Leveraging techniques from
each of these areas, we develop a semantic
parser for Freebase that is capable of pars-
ing questions with an F1 that improves by
0.42 over a purely-supervised learning al-
gorithm.

1 Introduction

Semantic parsing is the task of translating natural
language utterances to a formal meaning represen-
tation language (Chen et al., 2010; Liang et al.,
2009; Clarke et al., 2010; Liang et al., 2011; Artzi
and Zettlemoyer, 2011). There has been recent in-
terest in producing such semantic parsers for large,
heterogeneous databases like Freebase (Krishna-
murthy and Mitchell, 2012; Cai and Yates, 2013)
and Yago2 (Yahya et al., 2012), which has driven
the development of semi-supervised and distantly-
supervised training methods for semantic parsing.
Previous purely-supervised approaches have been
limited to smaller domains and databases, such as
the GeoQuery database, in part because of the cost
of labeling enough samples to cover all of the log-
ical constants involved in a domain.

This paper investigates a reduction of the prob-
lem of building a semantic parser to three stan-
dard problems in semantics and machine learning:
supervised training of a semantic parser, schema
matching, and pattern learning. Figure 1 provides
a visualization of our system architecture. We
apply an existing supervised training algorithm
for semantic parsing to a labeled data set. We

(sentence, 
logical form) 
Training data 

Test questions 

Freebase Web 
Relations 
Extracted 
from Web 

Supervised 
Semantic 

Parser 
Learning 

MATCHER 

LEXTENDER 
Freebase PCCG 
Grammar and 

Lexicon 

(word, Freebase symbol) 
correspondences 

High-Coverage Freebase 
PCCG Grammar and 

Lexicon 

Figure 1: We reduce the task of learning a large-
scale semantic parser to a combination of 1) a
standard supervised algorithm for learning seman-
tic parsers; 2) our MATCHER algorithm for find-
ing correspondences between words and database
symbols; and 3) our LEXTENDER algorithm for
integrating (word, database symbol) matches into
a semantic parsing lexicon.

apply schema matching techniques to the prob-
lem of finding correspondences between English
words w and ontological symbols s. And we ap-
ply pattern learning techniques to incorporate new
(w, s) pairs into the lexicon of the trained seman-
tic parser.

This reduction allows us to apply standard tech-
niques from each problem area, which in com-
bination provide a large improvement over the
purely-supervised approaches. On a dataset of
917 questions taken from 81 domains of the Free-
base database, a standard learning algorithm for
semantic parsing yields a parser with an F1 of
0.21, in large part because of the number of log-
ical symbols that appear during testing but never
appear during training. Our techniques can extend
this parser to new logical symbols through schema
matching, and yield a semantic parser with an F1
of 0.63 on the same task. On a more challenging
task where training and test data are divided so that
all logical constants in test are never observed dur-

423



ing training, our approach yields a semantic parser
with an F1 of 0.6, whereas the purely supervised
approach cannot parse a single test question cor-
rectly. These results indicate that it is possible to
automatically extend semantic parsers to symbols
for which little or no training data has been ob-
served.

The rest of this paper is organized as follows.
The next section discusses related work. Section 3
describes our MATCHER algorithm for performing
schema matching between a knowledge base and
text. Section 4 explains how we use MATCHER’s
schema matching to extend a standard semantic
parser to logical symbols for which it has seen no
labeled training data. Section 5 analyzes the per-
formance of MATCHER and our semantic parser.
Section 6 concludes.

2 Previous Work

Two existing systems translate between natural
language questions and database queries over
large-scale databases. Yahya et al. (2012) re-
port on a system for translating natural language
queries to SPARQL queries over the Yago2 (Hof-
fart et al., 2013) database. Yago2 consists of
information extracted from Wikipedia, WordNet,
and other resources using manually-defined ex-
traction patterns. The manual extraction patterns
pre-define a link between natural language terms
and Yago2 relations. Our techniques automate
the process of identifying matches between tex-
tual phrases and database relation symbols, in or-
der to scale up to databases with more relations,
like Freebase. A more minor difference between
Yahya et al.’s work and ours is that their system
handles SPARQL queries, which do not handle ag-
gregation queries like argmax and count. We
rely on an existing semantic parsing technology
to learn the language that will translate into such
aggregation queries. On the other hand, their test
questions involve more conjunctions and complex
semantics than ours. Developing a dataset with
more complicated semantics in the queries is part
of our ongoing efforts.

Krishnamurthy and Mitchell (2012) also cre-
ate a semantic parser for Freebase covering 77
of Freebase’s over 2000 relations. Like our
work, their technique uses distant supervision to
drive training over a collection of sentences gath-
ered from the Web, and they do not require any
manually-labeled training data. However, their

technique does require manual specification of
rules that construct CCG lexical entries from de-
pendency parses. In comparison, we fully auto-
mate the process of constructing CCG lexical en-
tries for the semantic parser by making it a pre-
diction task. We also leverage synonym-matching
techniques for comparing relations extracted from
text with Freebase relations. Finally, we test our
results on a dataset of 917 questions covering
over 600 Freebase relations, a more extensive test
than the 50 questions used by Krishnamurthy and
Mitchell.

Numerous methods exist for comparing two re-
lations based on their sets of tuples. For instance,
the DIRT system (Lin and Pantel, 2001) uses the
mutual information between the (X,Y ) argument
pairs for two binary relations to measure the sim-
ilarity between them, and clusters relations ac-
cordingly. More recent examples of similar tech-
niques include the Resolver system (Yates and Et-
zioni, 2009) and Poon and Domingos’s USP sys-
tem (Poon and Domingos, 2009). Our techniques
for comparing relations fit into this line of work,
but they are novel in their application of these
techniques to the task of comparing database re-
lations and relations extracted from text.

Schema matching (Rahm and Bernstein, 2001;
Ehrig et al., 2004; Giunchiglia et al., 2005) is a
task from the database and knowledge representa-
tion community in which systems attempt to iden-
tify a “common schema” that covers the relations
defined in a set of databases or ontologies, and the
mapping between each individual database and the
common schema. Owing to the complexity of the
general case, researchers have resorted to defining
standard similarity metrics between relations and
attributes, as well as machine learning algorithms
for learning and predicting matches between rela-
tions (Doan et al., 2004; Wick et al., 2008b; Wick
et al., 2008a; Nottelmann and Straccia, 2007;
Berlin and Motro, 2006). These techniques con-
sider only matches between relational databases,
whereas we apply these ideas to matches between
Freebase and extracted relations. Schema match-
ing in the database sense often considers com-
plex matches between relations (Dhamanka et al.,
2004), whereas as our techniques are currently re-
stricted to matches involving one database relation
and one relation extracted from text.

424



3 Textual Schema Matching

3.1 Problem Formulation
The textual schema matching task is to identify
natural language words and phrases that corre-
spond with each relation and entity in a fixed
schema for a relational database. To formalize this
task, we first introduce some notation.

A schema S = (E,R,C, I) consists of a
set of entities E, a set of relations R, a set of
categories C, and a set of instances I . Categories
are one-argument predicates (e.g., film(e)), and
relations are two- (or more-) argument predicates
(e.g., directed by(e1, e2)). Instances are
known tuples of entities that make a relation
or category true, such as film(Titanic)
or directed by(Titanic, James
Cameron). For a given r ∈ R (or c ∈ C),
IS(r) indicates the set of known instances of r in
schema S (and likewise for IS(c)). Examples of
such schemas include Freebase (Bollacker et al.,
2008) and Yago2 (Hoffart et al., 2013). We say a
schema is a textual schema if it has been extracted
from free text, such as the Nell (Carlson et al.,
2010) and ReVerb (Fader et al., 2011) extracted
databases.

Given a textual schema T and a database
schema D, the textual schema matching task is to
identify an alignment or matching M ⊂ RT ×RD
such that (rT , rD) ∈ M if and only if rT can
be used to refer to rD in normal language usage.
The problem would be greatly simplified if
M were a 1-1 function, but in practice most
database relations can be referred to in many
ways by natural language users: for instance,
film actor can be referenced by the English
verbs “played,” “acted,” and “starred,” along
with morphological variants of them. In addi-
tion, many English verbs can refer to several
different relations in Freebase: “make” can refer
to computer processor manufacturer
or distilled spirits producer, among
many others. Our MATCHER algorithm for textual
schema matching handles this by producing a
confidence score for every possible (rT , rD) pair,
which downstream applications can then use to
reason about the possible alignments.

Even worse than the ambiguities in alignment,
some textual relations do not correspond with
any database relation exactly, but instead they
correspond with a projection of a relation, or a
join between multiple relations, or another com-

plex view of a database schema. As a sim-
ple example, “actress” corresponds to a subset
of the Freebase film actor relation that inter-
sects with the set {x: gender(x, female)}.
MATCHER can only determine that “actress”
aligns with film actor or not; it cannot pro-
duce an alignment between “actress” and a join of
film actor and gender. These more complex
alignments are an important consideration for fu-
ture work, but as our experiments will show, quite
useful alignments can be produced without han-
dling these more complex cases.

3.2 Identifying candidate matches

MATCHER uses a generate-and-test architecture
for determining M . It uses a Web search engine
to issue queries for a database relation rD consist-
ing of all the entities in a tuple t ∈ ID(rD). 1000
tuples for each rD are randomly chosen for issu-
ing queries. The system then retrieves matching
snippets from the search engine results. It uses
the top 10 results for each search engine query. It
then counts the frequency of each word type in the
set of retrieved snippets for rD. The top 500 non-
stopword word types are chosen as candidates for
matches with rD. We denote the candidate set for
rD as C(rD).

MATCHER’s threshold of 500 candidates for
C(rD) results in a maximum possible recall of just
less than 0.8 for the alignments in our dataset, but
even if we double the threshold to 1000, the re-
call improves only slightly to 0.82. We therefore
settled on 500 as a point with an acceptable upper
bound on recall, while also producing an accept-
able number of candidate terms for further pro-
cessing.

3.3 Pattern-based match selection

The candidate pool C(rD) of 500 word types is
significantly smaller than the set of all textual re-
lations, but it is also extremely noisy. The can-
didates may include non-relation words, or other
frequent but unrelated words. They may also in-
clude words that are highly related to rD, but not
actually corresponding textual relations. For in-
stance, the candidate set for film director in
Freebase includes words like “directed,” but also
words like “film,” “movie,” “written,” “produced,”
and “starring.” We use a series of filters based on
synonym-detection techniques to help select the
true matching candidates from C(rD).

425



Pattern Condition Example

1. “rT in E” rT ends with “-ed” and E has
type datetime or location

“founded in 1989”

2. “rT by E” rT ends with “-ed” “invented by Edison”
3. “rT such as E” rT ends with “-s” “directors such as Tarantino”
4. “E is a(n) rT ” all cases “Paul Rudd is an actor”

Table 1: Patterns used by MATCHER as evidence of a match between rD and rT . E represents an entity
randomly selected from the tuples in ID(rD).

The first type of evidence we consider for
identifying true matches from C(rD) consists of
pattern-matching. Relation words that express rD
will often be found in complex grammatical con-
structions, and often they will be separated from
their entity arguments by long-distance dependen-
cies. However, over a large corpus, one would ex-
pect that in at least some cases, the relation word
will appear in a simple, relatively-unambiguous
grammatical construction that connects rT with
entities from rD. For instance, entities e from the
relationship automotive designer appear in
the pattern “designed by e” more than 100 times
as often as the next most-common patterns, “con-
sidered by e” and “worked by e.”

MATCHER use searches over the Web to count
the number of instances where a candidate rT ap-
pears in simple patterns that involve entities from
rD. Greater counts for these patterns yield greater
evidence of a correct match between rD and rT .
Table 1 provides a list of patterns that we consider.
For each rD and each rT ∈ C(rD), MATCHER
randomly selects 10 entities from rD’s tuples to
include in its pattern queries. Two of the patterns
are targeted at past-tense verbs, and the other two
patterns at nominal relation words.

MATCHER computes statistics similar to point-
wise mutual information (PMI) (Turney, 2001) to
measure how related rD and rT are, for each pat-
tern p. Let c(p, rD, rT ) indicate the sum of all the
counts for a particular pattern p, database relation,
and textual relation:

fp(rT , rD) =
c(p, rD, rT )∑

r′D

c(p, r′D, rT ) ∗
∑

r′T

c(p, rD, r′T )

For the sum over all r′D, we use all r
′
D in Freebase

for which rT was extracted as a candidate.
One downside of the pattern-matching evidence

is the sheer number of queries it requires. Freebase

currently has over 2,000 relations. For each rD,
we have up to 500 candidate rT , up to 4 patterns,
and up to 10 entities per pattern. To cover all of
Freebase, MATCHER needs 2, 000×500×4×10 =
40 million queries, or just over 1.25 years if it
issues 1 query per second (we covered approxi-
mately one-quarter of Freebase’s relations in our
experiments). Using more patterns and more en-
tities per pattern are desirable for accumulating
more evidence about candidate matches, but there
is a trade-off with the time required to issue the
necessary queries.

3.4 Comparing database relations with
extracted relations

Open Information Extraction (Open IE) systems
(Banko et al., 2007) can often provide a large set of
extracted tuples for a given rT , which MATCHER
can then use to make much more comprehensive
comparisons with the full tuple set for rD than the
pattern-matching technique allows.

MATCHER employs a form of PMI to compute
the degree of relatedness between rD and rT . In
its simplest form, MATCHER computes:

PMI(rT , rD) =
|ID(rD) ∩ IT (rT )|
|ID(rD)| · |IT (rT )|

(1)

While this PMI statistic is already quite useful, we
have found that in practice there are many cases
where an exact match between tuples in ID(rD)
and tuples in IT (rT ) is too strict of a criterion.
MATCHER uses a variety of approximate matches
to compute variations of this statistic. Considered
as predictors for the true matches inM , these vari-
ations of the PMI statistic have a lower precision,
in that they are more likely to have high values
for incorrect matches. However, they also have a
higher recall: that is, they will have a high value
for correct candidates in C(rD) when the strict
version of PMI does not. Table 2 lists all the vari-
ations used by MATCHER.

426



Statistics for (rT , rD)

sκ(rT , rD) =

∑

tD∈ID(rD)

∑

tT∈IT (rT )
κ(tD, tT )

|ID(rD)|·|IT (rT )|

s′κ(rT , rD) =
sκ(rT ,rD)∑

r′D

sκ(r
′
D, rT )

s′′(rT , rD) =
|IT (rT )|
|ID(rD)|

Table 2: MATCHER statistics: for each κ func-
tion for comparing two tuples (given in Table 3),
MATCHER computes the statistics above to com-
pare rD and rT . The PMI statistic in Equation
1 corresponds to sκ where κ =strict match over
Φ =full tuples.

κ(t1, t2) for comparing tuples t1, t2

strict match:

{
1, if Φ(t1) = Φ′(t2)
0, otherwise.

type match:





1, if ∀kcat(Φ(t1)k)
= cat(Φ′(t2)k)

0, otherwise.

Table 3: MATCHER’s κ functions for computing
whether two tuples are similar. cat maps an entity
to a category (or type) in the schema. MATCHER
has a different κ function for each possible com-
bination of Φ and Φ′ functions, which are given in
Table 4.

MATCHER uses an API for the ReVerb Open
IE system1 (Fader et al., 2011) to collect I(rT ),
for each rT . The API for ReVerb allows for rela-
tional queries in which some subset of the entity
strings, entity categories, and relation string are
specified. The API returns all matching triples;
types must match exactly, but relation or argument
strings in the query will match any relation or ar-
gument that contains the query string as a sub-
string. MATCHER queries ReVerb with three dif-
ferent types of queries for each rT , specifying the
types for both arguments, or just the type of the
first argument, or just the second argument. Types
for arguments are taken from the types of argu-
ments for a potentially matching rD in Freebase.
To avoid overwhelming the ReVerb servers, for
our experiments we limited MATCHER to queries

1http://openie.cs.washington.edu/

Φ(t) for tuple t = (e1, . . . , en)

∀iei (projection to one dimension)
(e1, . . . , en) (full tuple)
∀σ(·)(eσ(1), . . . , eσ(n)) (permutation)

Table 4: MATCHER’s Φ functions for projecting
or permuting a tuple. σ indicates a permutation of
the indices.

for the top 80 rT ∈ C(rD), when they are ranked
according to frequency during the candidate iden-
tification process.

3.5 Regression models for scoring candidates

Pattern statistics, the ReVerb statistics from Ta-
ble 2, and the count of rT during the candidate
identification step all provide evidence for correct
matches between rD and rT . MATCHER uses a re-
gression model to combine these various statistics
into a score for (rT , rD). The regression model
is a linear regression with least-squares parameter
estimation; we experimented with support vector
regression models with non-linear kernels, with
no significant improvements in accuracy. Section
5 explains the dataset we use to train this model.
Unlike a classifier, MATCHER does not output any
single matching M . However, downstream appli-
cations can easily convert MATCHER’s output into
a matchingM by, for instance, selecting the topK
candidate rT values for each rD, or by selecting all
(rT , rD) pairs with a score over a chosen thresh-
old. Our experiments analyze MATCHER’s suc-
cess by comparing its performance across a range
of different values for the number of rT matches
for each rD.

4 Extending a Semantic Parser Using a
Schema Alignment

An alignment between textual relations and
database relations has many possible uses: for ex-
ample, it might be used to allow queries over a
database to be answered using additional infor-
mation stored in an extracted relation store, or
it might be used to deduce clusters of synony-
mous relation words in English. Here, we de-
scribe an application in which we build a question-
answering system for Freebase by extending a
standard learning technique for semantic parsing
with schema alignment information.

As a starting point, we used the UBL system

427



developed by Kwiatkowski et al. (2010) to learn
a semantic parser based on probabilistic Com-
binatory Categorial Grammar (PCCG). Source
code for UBL is freely available. Its authors
found that it achieves results competitive with the
state-of-the-art on a variety of standard semantic
parsing data sets, including Geo250 English (0.85
F1). Using a fixed CCG grammar and a procedure
based on unification in second-order logic, UBL
learns a lexicon Λ from the training data which
includes entries like:

Example Lexical Entries

New York City ` NP : new york
neighborhoods in `

S\NP/NP : λxλy.neighborhoods(x, y)

Example CCG Grammar Rules

X/Y : f Y : g ⇒ X : f(g)
Y : g X\Y : f ⇒ X : f(g)

Using Λ, UBL selects a logical form z
for a sentence S by selecting the z with the
most likely parse derivations y: h(S) =
arg maxz

∑
y p(y, z|x; θ,Λ). The probabilistic

model is a log-linear model with features for lex-
ical entries used in the parse, as well as indi-
cator features for relation-argument pairs in the
logical form, to capture selectional preferences.
Inference (parsing) and parameter estimation are
driven by standard dynamic programming algo-
rithms (Clark and Curran, 2007), while lexicon
induction is based on a novel search procedure
through the space of possible higher-order logic
unification operations that yield the desired logi-
cal form for a training sentence.

Our Freebase data covers 81 of the 86 core do-
mains in Freebase, and 635 of its over 2000 re-
lations, but we wish to develop a semantic parser
that can scale to all of Freebase. UBL gets us part
of the way there, by inducing a PCCG grammar, as
well as lexical entries for function words that must
be handled in all domains. It can also learn lexical
entries for relations rD that appear in the training
data. However, UBL has no way to learn lexical
entries for the many valid (rT , rD) pairs that do
not appear during training.

We use MATCHER’s learned alignment to ex-
tend the semantic parser that we get from UBL
by automatically adding in lexical entries for Free-

base relations. Essentially, for each (rT , rD) from
MATCHER’s output, we wish to construct a lexi-
cal entry that states that rT ’s semantics resembles
λxλy.rD(x, y). However, this simple process is
complicated by the fact that the semantic parser re-
quires two additional types of information for each
lexical entry: a syntactic category, and a weight.
Furthermore, for many cases the appropriate se-
mantics are significantly more complex than this
pattern.

To extend the learned semantic parser to a se-
mantic parser for all of Freebase, we introduce a
prediction task, which we call semantic lexicon ex-
tension: given a matching M together with scores
for each pair in M , predict the syntactic category
Syn, lambda-calculus semantics Sem, and weight
W for a full lexical entry for each (rT , rD) ∈ M .
One advantage of the reduction approach to learn-
ing a semantic parser is that we can automatically
construct training examples for this prediction task
from the other components in the reduction. We
use the output lexical entries learned by UBL as
(potentially noisy) examples of true lexical entries
for (rT , rD) pairs where rT matches the word in
one of UBL’s lexical entries, and rD forms part
of the semantics in the same lexical entry. For
(rT , rD) pairs in M where rD occurs in UBL’s
lexical entries, but not paired with rT , we create
dummy “negative” lexical entries with very low
weights, one for each possible syntactic category
observed in all lexical entries. Note that in or-
der to train LEXTENDER, we need the output of
MATCHER for the relations in UBL’s training data,
as well as UBL’s output lexicon from the training
data.

Our system for this prediction task, which we
call LEXTENDER (for Lexicon eXtender), factors
into three components: P (Sem|rD, rT , score),
P (Syn|Sem, rD, rT , score), and
P (W |Syn, Sem, rD, rT , score). This factoriza-
tion is trivial in that it introduces no independence
assumptions, but it helps in designing models
for the task. We set the event space for random
variable Sem to be the set of all lambda calculus
expressions observed in UBL’s output lexicon,
modulo the names of specific Freebase relations.
For instance, if the lexicon includes two entries
whose semantics are λxλy . film actor(x, y) and
λxλy . book author(x, y), the event space would
include the single expression in which relations
film actor and book author were replaced by

428



a new variable: λpλxλy.p(x, y). The final
semantics for a lexical entry is then constructed
by substituting rD for p, or more formally, by a
function application Sem(rD). The event space
for Syn consists of all syntactic categories in
UBL’s output lexicon, and W ranges over R.

LEXTENDER’s model for Sem and Syn are
Naı̈ve Bayes classifiers (NBC), with features for
the part-of-speech for rT (taken from a POS tag-
ger), the suffix of rT , the number of arguments of
rD, and the argument types of rD. For Syn, we
add a feature for the predicted value of Sem. For
W , we use a linear regression model whose fea-
tures are the score from MATCHER, the probabili-
ties from the Syn and Sem NBC models, and the
average weight of all lexical entries in UBL with
matching syntax and semantics. Using the pre-
dictions from these models, LEXTENDER extends
UBL’s learned lexicon with all possible lexical en-
tries with their predicted weights, although typi-
cally only a few lexical entries have high enough
weight to make a difference during parsing. Prun-
ing entries with low weights could improve the
memory and time requirements for parsing, but
these were not an issue in our experiments, so we
did not investigate this further.

5 Experiments

We conducted experiments to test the ability of
MATCHER and LEXTENDER to produce a se-
mantic parser for Freebase. We first analyze
MATCHER on the task of finding matches between
Freebase relations and textual relations. We then
compare the performance of the semantic parser
learned by UBL with its extension provided by
LEXTENDER on a dataset of English questions
posed to Freebase.

5.1 Experimental Setup

Freebase (Bollacker et al., 2008) is a free,
online, user-contributed, relational database
(www.freebase.com) covering many different
domains of knowledge. The full schema and
contents are available for download. The “Free-
base Commons” subset of Freebase, which is our
focus, consists of 86 domains, an average of 25
relations per domain (total of 2134 relations),
and 615,000 known instances per domain (53
million instances total). As a reference point,
the GeoQuery database — which is a standard
benchmark database for semantic parsing —

Examples

1. What are the neighborhoods in New
York City?
λx . neighborhoods(new york, x)

2. How many countries use the rupee?
count(x) . countries used(rupee, x)

3. How many Peabody Award winners are
there?
count(x) . ∃y . award honor(y) ∧

award winner(y, x) ∧
award(y, peabody award)

Figure 2: Example questions with their logical
forms. The logical forms make use of Freebase
symbols as logical constants, as well as a few ad-
ditional symbols such as count and argmin, to
allow for aggregation queries.

contains a single domain (geography), 8 relations,
and 880 total instances.

Our dataset contains 917 questions (on aver-
age, 6.3 words per question) and a meaning repre-
sentation for each question written in a variant of
lambda calculus2. 81 domains are represented in
the data set, and the lambda calculus forms contain
635 distinct Freebase relations. The most com-
mon domains, film and business, each took
up no more than 6% of the overall dataset. Sev-
eral examples are listed in Fig. 2. The ques-
tions were provided by two native English speak-
ers. No restrictions were placed on the type of
questions they should produce, except that they
should produce questions for multiple domains.
By inspection, a large majority of the questions
appear to be answerable from Freebase, although
no instructions were given to restrict questions
to this sort. We also created a dataset of align-
ments from these annotated questions by creating
an alignment for each Freebase relation mentioned
in the logical form for a question, paired with a
manually-selected word from the question.

5.2 Alignment Tests

We measured the precision and recall of
MATCHER’s output against the manually la-
beled data. Let M be the set of (rT , rD) matches
produced by the system, and G the set of matches
in the gold-standard manual data. We define

2The data is available from the second author’s website.

429



0

0.1

0.2

0.3

0.4

0.5

0.6

0 0.2 0.4 0.6 0.8 1

P
re

ci
si

o
n

 

Recall 

Alignment Predictions 

Matcher

Extractions

Pattern

Frequency

Figure 3: MATCHER’s Pattern features and Extrac-
tions features complement one another, so that in
combination they outperform either subset on its
own, especially at the high-recall end of the curve.

precision and recall as:

P =
|M ∩G|
|M | , R =

|M ∩G|
|G|

Figure 3 shows a Precision-Recall (PR) curve
for MATCHER and three baselines: a “Frequency”
model that ranks candidate matches for rD by their
frequency during the candidate identification step;
a “Pattern” model that uses MATCHER’s linear re-
gression model for ranking, but is restricted to
only the pattern-based features; and an “Extrac-
tions” model that similarly restricts the ranking
model to ReVerb features. We have three folds in
our data; the alignments for relation rD in one fold
are predicted by models trained on the other two
folds. Once all of the alignments in all three folds
are scored, we generate points on the PR curve by
applying a threshold to the model’s ranking, and
treating all alignments above the threshold as the
set of predicted alignments.

All regression models for learning alignments
outperform the Frequency ranking by a wide mar-
gin. The Pattern model outperforms the Extrac-
tions model at the high-precision, low-recall end
of the curve. At the high-recall points, the Pat-
tern model drops quickly in precision. However,
the combination of the two kinds of features in
MATCHER yields improved precision at all levels
of recall.

5.3 Semantic Parsing Tests
While our alignment tests can tell us in relative
terms how well different models are performing,
it is difficult to assess these models in absolute
terms, since alignments are not typical applica-
tions that people care about in their own right. We

now compare our alignments on a semantic pars-
ing task for Freebase.

In a first semantic parsing experiment, we train
UBL, MATCHER, and LEXTENDER on a random
sample of 70% of the questions, and test them
on the remaining 30%. In a second test, we fo-
cus on the hard case where all questions from the
test set contain logical constants that have never
been seen before during training. We split the
data into 3 folds, making sure that no Freebase do-
main has symbols appearing in questions in more
than one fold. We then perform 3-fold cross-
validation for all of our supervised models. We
varied the number of matches that the alignment
model (MATCHER, Pattern, Extractions, or Fre-
quency) could make for each Freebase relation,
and measured semantic parsing performance as a
function of the number of matches.

Figure 4 shows the F1 scores for these se-
mantic parsers, judged by exact match between
the top-scoring logical form from the parser and
the manually-produced logical form. Exact-match
tests are overly-strict, in the sense that the sys-
tem may be judged incorrect even when the log-
ical form that is produced is logically equivalent
to the correct logical form. However, by inspec-
tion such cases appear to be very rare in our data,
and the exact-match criterion is often used in other
semantic parsing experimental settings.

The semantic parsers produced by
MATCHER+LEXTENDER and the other alignment
techniques significantly outperform the baseline
semantic parser learned by UBL, which achieves
an overall F1 of 0.21 on these questions in the
70/30 split of the data, and an F1 of 0 in the
cross-domain experiment. Purely-supervised
approaches to this data are severely limited, since
they have almost no chance of correctly parsing
questions that refer to logical symbols that never
appeared during training. However, MATCHER
and LEXTENDER combine with UBL to produce
an effective semantic parser. The best semantic
parser we tested, which was produced by UBL,
MATCHER, and LEXTENDER with 9 matches per
Freebase relation, had a precision of 0.67 and a
recall of 0.59 on the 70/30 split experiment.

The difference in alignment performance be-
tween MATCHER, Pattern, and Extractions carries
over to semantic parsing. MATCHER drops in F1
with more matches as additional matches tend to
be low-quality and low-probability, whereas Pat-

430



0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0 5 10 15 20 25 30

F1
 f

o
r 

ex
ac

t 
m

at
ch

  
o

f 
lo

gi
ca

l f
o

rm
s 

Number of Matches per Freebase Relation 

Semantic Parsing (70/30 Split) 

Matcher

Pattern

Extractions

Frequency

Baseline

0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0 5 10 15 20 25 30

F1
 f

o
r 

ex
ac

t 
m

at
ch

  
o

f 
lo

gi
ca

l f
o

rm
s 

Number of Matches per Freebase Relation 

Semantic Parsing (Cross-Domain) 

Matcher

Extractions

Pattern

Frequency

Figure 4: Semantic parsers produced by UBL+MATCHER+LEXTENDER outperform the purely-
supervised baseline semantic parser on a random 70/30 split of the data (left) by as much as
0.42 in F1. In the case of this split and in the case of a cross-domain experiment (right),
UBL+MATCHER+LEXTENDER outperforms UBL+Pattern+LEXTENDER by as much as 0.06 in F1.

tern and Extractions keep improving as more low-
probability alignments are added. Interestingly,
the Extractions model begins to overtake the Pat-
tern model in F1 at higher numbers of matches,
and all three models trend toward convergence in
F1 with increasing numbers of matches. Neverthe-
less, MATCHER clearly improves over both, and
reaches a higher F1 than either Pattern or Extrac-
tions using a small number of matches, which cor-
responds to a smaller lexicon and a leaner model.

To place these results in context, many different
semantic parsers for databases like GeoQuery and
ATIS (including parsers produced by UBL) have
achieved F1 scores of 0.85 and higher. However,
in all such tests, the test questions refer to logi-
cal constants that also appeared during training, al-
lowing supervised techniques for learning seman-
tic parsers to achieve strong accuracy. As we have
argued, Freebase is large enough that is difficult
to produce enough labeled training data to cover
all of its logical constants. An unsupervised se-
mantic parser for GeoQuery has achieved an F1
score of 0.66 (Goldwasser et al., 2011), impres-
sive in its own right and slightly better than our F1
score. However, this parser was given questions
which it knew a priori to contain words that re-
fer to the logical constants in the database. Our
MATCHER and LEXTENDER systems address a
different challenge: how to learn a semantic parser
for Freebase given the Web and a set of initial la-
beled questions.

6 Conclusion

Scaling semantic parsing to large databases re-
quires an engineering effort to handle large
datasets, but also novel algorithms to extend se-

mantic parsing models to testing examples that
look significantly different from labeled training
data. The MATCHER and LEXTENDER algo-
rithms represent an initial investigation into such
techniques, with early results indicating that se-
mantic parsers can handle Freebase questions on a
large variety of domains with an F1 of 0.63.

We hope that our techniques and datasets will
spur further research into this area. In particu-
lar, more research is needed to handle more com-
plex matches between database and textual rela-
tions, and to handle more complex natural lan-
guage queries. As mentioned in section 3.1, words
like “actress” cannot be addressed by the cur-
rent methodology, since MATCHER assumes that
a word maps to a single Freebase relation, but
the closest Freebase equivalent to the meaning of
“actress” involves the two relations film actor
and gender. Another limitation is that our cur-
rent methodology focuses on finding matches for
nouns and verbs. Other important limitations of
the current methodology include:

• the assumption that function words have no
domain-specific meaning, which prepositions
in particular can violate;

• low accuracy when there are few relevant re-
sults among the set of extracted relations;

• and the restriction to a single database (Free-
base) for finding answers.

While significant challenges remain, the reduction
of large-scale semantic parsing to a combination
of schema matching and supervised learning of-
fers a new path toward building high-coverage se-
mantic parsers.

431



References
Yoav Artzi and Luke Zettlemoyer. 2011. Bootstrap-

ping Semantic Parsers from Conversations. In Pro-
ceedings of the Conference on Empirical Methods in
Natural Language Processing (EMNLP).

M. Banko, M. J. Cafarella, S. Soderland, M. Broad-
head, and O. Etzioni. 2007. Open information ex-
traction from the web. In IJCAI.

Jacob Berlin and Amihai Motro. 2006. Database
schema matching using machine learning with fea-
ture selection. In Advanced Information Systems
Engineering. Springer.

Kurt Bollacker, Colin Evans, Praveen Paritosh, Tim
Sturge, and Jamie Taylor. 2008. Freebase: A col-
laboratively created graph database for structuring
human knowledge. In Proceedings of the Interna-
tional Conference on Management of Data (SIG-
MOD), pages 1247–1250.

Qingqing Cai and Alexander Yates. 2013. Semantic
Parsing Freebase: Towards Open-Domain Semantic
Parsing. In Second Joint Conference on Lexical and
Computational Semantics.

Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr
Settles, Estevam R. Hruschka Jr., and Tom M.
Mitchell. 2010. Toward an Architecture for Never-
Ending Language Learning. In Proceedings of the
Twenty-Fourth Conference on Artificial Intelligence
(AAAI 2010).

David L. Chen, Joohyun Kim, and Raymond J.
Mooney. 2010. Training a Multilingual
Sportscaster: Using Perceptual Context to Learn
Language. Journal of Artificial Intelligence Re-
search, 37:397–435.

Stephen Clark and James R. Curran. 2007. Wide-
coverage efficient statistical parsing with ccg and
log-linear models. Computational Linguistics,
33(4):493–552.

J. Clarke, D. Goldwasser, M. Chang, and D. Roth.
2010. Driving semantic parsing from the world’s re-
sponse. In Computational Natural Language Learn-
ing (CoNLL).

R. Dhamanka, Y. Lee, A. Doan, A. Halevy, and
P. Domingos. 2004. iMAP: Discovering Complex
Semantic Matches between Database Schemas. In
SIGMOD.

A. Doan, J. Madhavan, P. Domingos, and A. Halevy.
2004. Ontology Matching: A Machine Learning
Approach. In S. Staab and R. Studer, editors, Hand-
book on Ontologies in Information Systems, pages
397–416. Springer-Verlag.

M. Ehrig, P. Haase, N. Stojanovic, and M. Hefke.
2004. Similarity for ontologies-a comprehensive
framework. In Workshop Enterprise Modelling and
Ontology: Ingredients for Interoperability, PAKM.

Anthony Fader, Stephen Soderland, and Oren Etzioni.
2011. Identifying Relations for Open Information
Extraction. In Conference on Empirical Methods in
Natural Language Processing (EMNLP).

Fausto Giunchiglia, Pavel Shvaiko, and Mikalai
Yatskevich. 2005. Semantic schema matching.
On the Move to Meaningful Internet Systems 2005:
CoopIS, DOA, and ODBASE, pages 347–365.

D. Goldwasser, R. Reichart, J. Clarke, and D. Roth.
2011. Confidence driven unsupervised semantic
parsing. In Association for Computational Linguis-
tics (ACL).

Johannes Hoffart, Fabian M. Suchanek, Klaus
Berberich, and Gerhard Weikum. 2013. YAGO2:
A Spatially and Temporally Enhanced Knowl-
edge Base from Wikipedia. Artificial Intelligence,
194:28–61, January.

Jayant Krishnamurthy and Tom Mitchell. 2012.
Weakly Supervised Training of Semantic Parsers. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing (EMNLP).

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing Probabilis-
tic CCG Grammars from Logical Form with Higher-
order Unification. In Proceedings of the Conference
on Empirical Methods in Natural Language Pro-
cessing (EMNLP).

P. Liang, M. I. Jordan, and D. Klein. 2009. Learning
semantic correspondences with less supervision. In
Association for Computational Linguistics and In-
ternational Joint Conference on Natural Language
Processing (ACL-IJCNLP).

P. Liang, M. I. Jordan, and D. Klein. 2011. Learn-
ing dependency-based compositional semantics. In
Association for Computational Linguistics (ACL).

D. Lin and P. Pantel. 2001. DIRT – Discovery of In-
ference Rules from Text. In KDD.

Henrik Nottelmann and Umberto Straccia. 2007. In-
formation retrieval and machine learning for proba-
bilistic schema matching. Information processing &
management, 43(3):552–576.

Hoifung Poon and Pedro Domingos. 2009. Unsu-
pervised semantic parsing. In Proceedings of the
2009 Conference on Empirical Methods in Natu-
ral Language Processing, EMNLP ’09, pages 1–10,
Stroudsburg, PA, USA. Association for Computa-
tional Linguistics.

E. Rahm and P.A. Bernstein. 2001. A survey of ap-
proaches to automatic schema matching. The VLDB
Journal, 10:334–350.

P. D. Turney. 2001. Mining the Web for Synonyms:
PMI-IR versus LSA on TOEFL. In Procs. of the
Twelfth European Conference on Machine Learning
(ECML), pages 491–502, Freiburg, Germany.

432



M. Wick, K. Rohanimanesh, A. McCallum, and A.H.
Doan. 2008a. A discriminative approach to ontol-
ogy mapping. In International Workshop on New
Trends in Information Integration (NTII) at VLDB
WS.

M.L. Wick, K. Rohanimanesh, K. Schultz, and A. Mc-
Callum. 2008b. A unified approach for schema
matching, coreference and canonicalization. In Pro-
ceeding of the 14th ACM SIGKDD international
conference on Knowledge discovery and data min-
ing.

Mohamed Yahya, Klaus Berberich, Shady Elbas-
suoni, Maya Ramanath, Volker Tresp, and Gerhard
Weikum. 2012. Natural Language Questions for the
Web of Data. In Proceedings of the Conference on
Empirical Methods in Natural Language Processing
(EMNLP).

Alexander Yates and Oren Etzioni. 2009. Unsuper-
vised methods for determining object and relation
synonyms on the web. Journal of Artificial Intelli-
gence Research (JAIR), 34:255–296, March.

433


