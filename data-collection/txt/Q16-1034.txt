








































Fast, Small and Exact: Infinite-order Language Modelling
with Compressed Suffix Trees

Ehsan Shareghi,[ Matthias Petri,\ Gholamreza Haffari[ and Trevor Cohn\
[ Faculty of Information Technology, Monash University

\ Computing and Information Systems, The University of Melbourne
first.last@{monash.edu,unimelb.edu.au}

Abstract

Efficient methods for storing and querying are
critical for scaling high-order m-gram lan-
guage models to large corpora. We propose
a language model based on compressed suffix
trees, a representation that is highly compact
and can be easily held in memory, while sup-
porting queries needed in computing language
model probabilities on-the-fly. We present
several optimisations which improve query
runtimes up to 2500√ó, despite only incurring
a modest increase in construction time and
memory usage. For large corpora and high
Markov orders, our method is highly competi-
tive with the state-of-the-art KenLM package.
It imposes much lower memory requirements,
often by orders of magnitude, and has run-
times that are either similar (for training) or
comparable (for querying).

1 Introduction

Language models (LMs) are fundamental to many
NLP tasks, including machine translation and
speech recognition. Statistical LMs are probabilis-
tic models that assign a probability to a sequence of
words wN1 , indicating how likely the sequence is in
the language. m-gram LMs are popular, and prove
to be accurate when estimated using large corpora.
In these LMs, the probabilities ofm-grams are often
precomputed and stored explicitly.

Although widely successful, current m-gram LM
approaches are impractical for learning high-order
LMs on large corpora, due to their poor scaling prop-
erties in both training and query phases. Prevailing
methods (Heafield, 2011; Stolcke et al., 2011) pre-
compute allm-gram probabilities, and consequently

need to store and access as many as a hundred of bil-
lions of m-grams for a typical moderate-order LM.

Recent research has attempted to tackle scalabil-
ity issues through the use of efficient data structures
such as tries and hash-tables (Heafield, 2011; Stol-
cke et al., 2011), lossy compression (Talbot and Os-
borne, 2007; Levenberg and Osborne, 2009; Guthrie
and Hepple, 2010; Pauls and Klein, 2011; Church et
al., 2007), compact data structures (Germann et al.,
2009; Watanabe et al., 2009; Sorensen and Allauzen,
2011), and distributed computation (Heafield et al.,
2013; Brants et al., 2007). Fundamental to all the
widely used methods is the precomputation of all
probabilities, hence they do not provide an adequate
trade-off between space and time for high m, both
during training and querying. Exceptions are Ken-
nington et al. (2012) and Zhang and Vogel (2006),
who use a suffix-tree or suffix-array over the text for
computing the sufficient statistics on-the-fly.

In our previous work (Shareghi et al., 2015), we
extended this line of research using a Compressed
Suffix Tree (CST) (Ohlebusch et al., 2010), which
provides a considerably more compact searchable
means of storing the corpus than an uncompressed
suffix array or suffix tree. This approach showed
favourable scaling properties with m and had only a
modest memory requirement. However, the method
only supported Kneser-Ney smoothing, not its modi-
fied variant (Chen and Goodman, 1999) which over-
all performs better and has become the de-facto
standard. Additionally, querying was significantly
slower than for leading LM toolkits, making the
method impractical for widespread use.

In this paper we extend Shareghi et al. (2015)
to support modified Kneser-Ney smoothing, and

477

Transactions of the Association for Computational Linguistics, vol. 4, pp. 477‚Äì490, 2016. Action Editor: Brian Roark.
Submission batch: 1/2016; Revision batch: 6/2016; Published 9/2016.

c¬©2016 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license.



present new optimisation methods for fast construc-
tion and querying.1 Critical to our approach are:

‚Ä¢ Precomputation of several modified counts,
which would be very expensive to compute at
query time. To orchestrate this, a subset of
the CST nodes is selected based on the cost
of computing their modified counts (which re-
lates with the branching factor of a node).
The precomputed counts are then stored in a
compressed data structure supporting efficient
memory usage and lookup.

‚Ä¢ Re-use of CST nodes within m-gram probabil-
ity computation as a sentence gets scored left-
to-right, thus saving many expensive lookups.

Empirical comparison against our earlier work
(Shareghi et al., 2015) shows the significance of
each of these optimisations. The strengths of our
method are apparent when applied to very large
training datasets (‚â• 16 GiB) and for high order mod-
els, m ‚â• 5. In this setting, while our approach
is more memory efficient than the leading KenLM
model, both in the construction (training) and query-
ing (testing) phases, we are highly competitive in
terms of runtimes of both phases. When memory
is a limiting factor at query time, our approach is
orders of magnitude faster than the state of the art.
Moreover, our method allows for efficient querying
with an unlimited Markov order, m ‚Üí ‚àû, without
resorting to approximations or heuristics.

2 Modified Kneser-Ney Language Model

In an m-gram language model, the probability of a
sentence is decomposed into

‚àèN
i=1 P (wi|wi‚àí1i‚àím+1),

where P (wi|wi‚àí1i‚àím+1) is the conditional probability
of the next word given its finite history. Smooth-
ing techniques are employed to deal with sparsity
when estimating the parameters of P (wi|wi‚àí1i‚àím+1).
A comprehensive comparison of different smooth-
ing techniques is provided in (Chen and Goodman,
1999). We focus on interpolated Modified Kneser-
Ney (MKN) smoothing, which is widely regarded
as a state-of-the-art technique and is supported by
popular language modelling toolkits, e.g. SRILM
(Stolcke, 2002) and KenLM (Heafield, 2011).

1https://github.com/eehsan/cstlm

Pm(w|ux) = [c(uxw)‚àí D
m(c(uxw))]+

c(ux)
+
Œ≥m(ux)PÃÑm‚àí1(w|x)

c(ux)

PÃÑk(w|ux) =
[N1+(¬∑uxw)‚àí Dk(N1+(¬∑uxw))]+

N1+(¬∑ux¬∑) +
Œ≥k(ux)PÃÑk‚àí1(w|x)

N1+(¬∑ux¬∑)
PÃÑ0(w|ÔøΩ) =

[N1+(¬∑w)‚àí D1(N1+(¬∑w))]+
N1+(¬∑¬∑) +

Œ≥(ÔøΩ)

N1+(¬∑¬∑) √ó
1

œÉ

Œ≥k(ux) =

{‚àë
j‚àà{1,2,3+} D

k(j)Nj(ux¬∑), if k = m‚àë
j‚àà{1,2,3+} D

k(j)N ‚Ä≤j(ux¬∑), if k < m

Dk(j) =

Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥

0, if j = 0
1‚àí 2n2(k)

n1(k)
. n1(k)
n1(k)+2n2(k)

, if j = 1

2‚àí 3n3(k)
n2(k)

. n1(k)
n1(k)+2n2(k)

, if j = 2

3‚àí 4n4(k)
n3(k)

. n1(k)
n1(k)+2n2(k)

, if j ‚â• 3

ni(k) =

{
|{Œ± s.t. |Œ±| = k, c(Œ±) = i}| , if k = m‚à£‚à£{Œ± s.t. |Œ±| = k,N1+(¬∑Œ±) = i}‚à£‚à£ , if k < m

Figure 1: The quantities and formula needed for modified
Kneser-Ney smoothing, where x is a k-gram, u and w

are words, and [a]+ def= max{0, a}. We use m to refer
to the order of the language model, and k ‚àà [1,m] to the
level of smoothing. The recursion stops at the unigram
level PÃÑ0(w|ÔøΩ) where the probability is smoothed by the
uniform distribution over the vocabulary 1œÉ .

MKN is a recursive smoothing technique which
uses lower order k-gram language models to smooth
higher order models. Figure 1 describes the re-
cursive smoothing formula employed in MKN. It
is distinguished from Kneser-Ney (KN) smoothing
in its use of adaptive discount parameters (denoted
as Dk(j) in Figure 1) based on the k-gram counts.
Importantly, MKN is based on not just m-gram
frequencies, c(x), but also several modified counts
based on numbers of unique contexts, namely

Ni+(Œ±¬∑) = |{w s.t. c(Œ±w) ‚â• i}|
Ni+(¬∑Œ±) = |{w s.t. c(wŒ±) ‚â• i}|
Ni+(¬∑Œ±¬∑) = |{w1w2 s.t. c(w1Œ±w2) ‚â• i}|
N ‚Ä≤i+(Œ±¬∑) = ‚à£‚à£{w s.t. N1+(¬∑Œ±w) ‚â• i}‚à£‚à£ .

Ni+(¬∑Œ±) and Ni+(Œ±¬∑) are the number of words
with frequency at least i that come before and after
a pattern Œ±, respectively. Ni+(¬∑Œ±¬∑) is the number
of word-pairs with frequency at least i which sur-
round Œ±. N ‚Ä≤i+(Œ±¬∑) is the number of words coming
after Œ± to form a pattern Œ±w for which the number
of unique left contexts is at least i; it is specific to
MKN and not needed in KN. Table 1 illustrates the

478

https://github.com/eehsan/cstlm


k num. count denom. count Œ≥
4 c(Force is strong with) c(Force is strong) N{1,2,3+}(Force is strong¬∑)
3 N1+(¬∑is strong with) N1+(¬∑is strong¬∑) N ‚Ä≤{1,2,3+}(is strong¬∑)
2 N1+(¬∑strong with) N1+(¬∑strong¬∑) N ‚Ä≤{1,2,3+}(strong¬∑)
1 N1+(¬∑with) N1+(¬∑¬∑) N ‚Ä≤{1,2,3+}(ÔøΩ¬∑)

Table 1: The main quantities required for computing
P (with|Force, is, strong) under MKN.

different types of quantities required for computing
an example 4-gram MKN probability.

Efficient computation of these quantities is chal-
lenging with limited memory and time resources,
particularly when the order of the language model
m is high and/or the training corpus is large. In this
paper, we make use of advanced data structures to
efficiently obtain the required quantities to answer
probabilistic queries as they arrive. Our solution in-
volves precomputing and caching expensive quan-
tities, N1+(¬∑Œ±¬∑), N1+(¬∑Œ±), N{1,2,3+}(¬∑Œ±) and
N ‚Ä≤{1,2,3+}(Œ±¬∑), which we will explain in ¬ß4. We
start in ¬ß3 by providing a review of the approach in
Shareghi et al. (2015) upon which we base our work.

3 KN with Compressed Suffix Trees

3.1 Compressed Data Structures

Shareghi et al. (2015) proposed a method for
Kneser-Ney (KN) language modelling based on on-
the-fly probability computation from a compressed
suffix tree (CST) (Ohlebusch et al., 2010). The
CST emulates the functionality of the Suffix Tree
(ST) (Weiner, 1973) using substantially less space.
The suffix tree is a classical search index consisting
of a rooted labelled search tree constructed from a
text T of length n drawn from an alphabet of size œÉ.
Each root to leaf path in the suffix tree corresponds
to a suffix of T . The leaves, considered in left-to-
right order define the suffix array (SA) (Manber and
Myers, 1993) such that the suffix T [SA[i], n ‚àí 1] is
lexicographically smaller than T [SA[i+1], n‚àí1] for
i ‚àà [0, n‚àí 2]. Searching for a pattern Œ± of length m
in T can be achieved by finding the ‚Äúhighest‚Äù node
v in the ST such that the path from the root to v is
prefixed by Œ±. All leaf nodes in the subtree start-
ing at v correspond to the locations of Œ± in T . This
is translated to finding the specific range SA[lb, rb]
such that

T [SA[j], SA[j +m‚àí 1]] = Œ± for j ‚àà [lb, rb]

as illustrated in the ST and SA of Figure 2 (left).
While searching using the ST or the SA is effi-

cient in theory, it requires large amounts of main
memory. A CST reduces the space requirements of
ST by utilizing the compressibility of the Burrows-
Wheeler transform (BWT) (Burrows and Wheeler,
1994). The BWT corresponds to a reversible per-
mutation of the text used in data compression tools
such as BZIP2 to increase the compressibility of the
input. The transform is defined as

BWT[i] = T[SA[i]‚àí 1 mod n] (1)

and is the core component of the FM-Index (Ferrag-
ina and Manzini, 2000) which is a subcomponent
of a CST to provide efficient search for locating ar-
bitrary length patterns (m-grams), determining oc-
currence frequencies etc. The key functionality pro-
vided by the FM-Index is the ability to efficiently
determine the range SA[lb, rb] matching a given pat-
tern Œ± described above without the need to store the
ST or SA explicitly. This is achieved by iteratively
processing Œ± in reverse order using the BWT, which
is usually referred to as backward-search.

The backward-search procedure utilizes the dual-
ity between the BWT and SA to iteratively determine
SA[lb, rb] for suffixes of Œ±. Suppose SA[spj , epj ]
corresponds to all suffixes in T matchingŒ±[j,m‚àí1].
Range SA[spj‚àí1, epj‚àí1] matching Œ±[j ‚àí 1,m ‚àí 1]
with c def= Œ±[j ‚àí 1] can be expressed as

spj‚àí1 = C[c] + RANK(BWT, spj , c)

epj‚àí1 = C[c+ 1] + RANK(BWT, epj + 1, c)‚àí 1

where C[c] refers to the starting position of all suf-
fixes prefixed by c in SA and RANK(BWT, spj , c)
determines the number of occurrences of symbol c
in BWT[0, spj ].

Operation RANK(BWT, i, c) (and its inverse op-
eration SELECT(BWT,i,c)2) can be performed effi-
ciently using a wavelet tree (Grossi et al., 2003) rep-
resentation of the BWT. A wavelet tree is a ver-
satile, space-efficient representation of a sequence
which can efficiently support a variety of opera-
tions (Navarro, 2014). The structure of the wavelet
tree is derived by recursively decomposing the al-
phabet into subsets. At each level the alphabet is

2SELECT(BWT,i,c) returns the position of the ith occur-
rence of symbol c in BWT.

479



$

14

7

1213

0

3
6

9

1 4

# ùíó

10
8

11

2 5

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
SA 14 13 0 1 4 7 10 11 2 5 8 12 3 6 9

BWT # c $ # c c d b a a a b b b b

(a) Suffix Tree, Suffix Array, and Burrows-Wheeler
Transform

# c $ # c c d b a a a b b b b

0 1 0 0 1 1 1 1 0 0 0 1 1 1 1

# $ # a a a

0 0 0 1 1 1

c c c d b b b b b

0 0 0 1 0 0 0 0 0

# $ #

1 0 1

$ b c

0 1

0 1

#

a

1

c c c b b b b b

0 0 0 1 1 1 1 1

0

0 1 0 1

d

(b) Wavelet Tree of BWT

Figure 2: (a) Character-Level Suffix Tree, Suffix Array (SA), and Burrows-Wheeler Transform (BWT) for ‚Äú#abcab-
cabdbbc#$‚Äù (as formulated in eq. 1). (b) The Wavelet Tree of BWT and the RANK(BWT, 8, a). The ordered alphabet
symbols and their code words are {$:000, #:001, a:01, b:100, c:101, d:11}, and symbols ‚Äú#‚Äù and ‚Äú$‚Äù are to mark
sentence and file boundaries. The red bounding boxes and digits signify the path for computing RANK(BWT, 8, a).

split into two subsets based on which symbols in
the sequence are assigned to the left and right child
nodes respectively. Using compressed bitvector rep-
resentations and Huffman codes to define the al-
phabet partitioning, the space usage of the wavelet
tree and associated RANK structures of the BWT is
bound by Hk(T)n + o(n log œÉ) bits (Grossi et al.,
2003). Thus the space usage is proportional to the
order k entropy (Hk(T)) of the text.

Figure 2 (right) shows a sample wavelet tree rep-
resentation. Using the wavelet tree structure, RANK
over a sequence drawn from an alphabet of size
œÉ can be reduced to log œÉ binary RANK opera-
tions which can be answered efficiently in constant
time (Jacobson, 1989). The range SA[lb, rb] cor-
responding to a pattern Œ±, can be determined in
O(m log œÉ) time using a wavelet tree of the BWT.

In addition to the FM-index, a CST efficiently
stores the tree topology of the ST to emulate tree
operations such efficiently (Ohlebusch et al., 2010).

3.2 Computing KN modified counts

Shareghi et al. (2015) showed how the req-
uisite counts for a KN-LM, namely c(Œ±),
N1+(¬∑Œ±), N1+(¬∑Œ±¬∑) and N1+(Œ±¬∑), can be
computed directly from CST. Consider the example
in Figure 2, the number of occurrences of b corre-
sponds to counting the number of leaves, size(v),
in the subtree rooted at v. This can be computed in
O(1) time by computing the size of the range [lb, rb]

implicitly associated with each node. The number of
unique right contexts of b can be determined using
degree(v) (again O(1) but requires bit operations
on the succinct tree representation of the ST). That
is, N1+(b¬∑) = degree(v) = 3.

Determining the number of left-contexts and sur-
rounding contexts is more involved. Computing
N1+(¬∑Œ±) relies on the BWT. Recall that BWT[i]
corresponds to the symbol preceding the suffix start-
ing at SA[i]. For example computing N1+(¬∑b)
first requires finding the interval of suffixes start-
ing with b in SA, namely lb = 6 and rb = 10,
and then counting the number of unique symbols
in BWT[6, 10] = {d, b, a, a, a}, i.e., 3. Determin-
ing all unique symbols in BWT[i, j] can be per-
formed efficiently (independently of the size of the
range) using the wavelet tree encoding of the BWT.
The set of symbols preceding pattern Œ±, denoted by
P (Œ±) can be computed in O(|P (Œ±)| log œÉ) by vis-
iting all unique leafs in the wavelet tree which cor-
respond to symbols in BWT[i, j]. This is usually
referred to as the interval-symbols (Schnattinger et
al., 2010) procedure and uses RANK operations
to find the set of symbols s ‚àà P (Œ±) and corre-
sponding ranges for sŒ± in SA. In the above exam-
ple, identifying the SA range of ab requires find-
ing the lb, rb in the SA for suffixes starting with a
(SA [3,5]) and then adjusting the bounds to cover
only the suffixes starting with ab. This last step
is done via computing the rank of three a symbols

480



2 3 5 8 ‚àû

0
10

s
20

s

N'123+(Œ± .)
N123+(Œ± .)
N1+(. Œ± .)
N1+(. Œ±)
N1+(Œ± .)
backward‚àísearch

On‚àíthe‚àífly

T
im

e 
(s

ec
)

2 3 5 8 ‚àû

0
4m

s
8m

s Precomputed

m‚àígram

T
im

e 
(m

se
c)

Figure 3: Time breakdown for querying average per-
sentence, shown without runtime precomputation of ex-
pensive contextual counts (above) vs. with precomputa-
tion (below). The left and right bar in each group denote
KN and MKN, respectively. Trained on the German por-
tion of the Europarl corpus and tested over the first 10K
sentences from the News Commentary corpus.

in BWT[8,10] using the wavelet tree, see Figure 2
(right) for RANK(BWT, a, 8). As illustrated, an-
swering RANK(BWT, 8, a) corresponds to process-
ing the first digit of the code word at the root level,
which translates into RANK(WTroot, 8, 0) = 4, fol-
lowed by a RANK(WT1, 4, 1) = 1 on the left branch.
Once the ranks are computed lb, rb are refined ac-
cordingly to SA [3+ (1 - 1), 3+ (3 - 1)]. Finally,
for N1+(¬∑Œ±¬∑) all patterns which can follow Œ± are
enumerated, and for each of these extended patterns,
the number of preceding symbols is computed using
interval-symbols. This proved to be the most expen-
sive operation in their approach.

Given these quantities, Shareghi et al. (2015)
show how m-gram probabilities can be computed
on demand using an iterative algorithm to search for
matching nodes in the suffix tree for the required k-
gram (k ‚â§ m) patterns in the numerator and de-
nominator of the KN recursive equations, which are
then used to compute the probabilities. We refer
the reader to Shareghi et al. (2015) for further de-
tails. Overall their approach showed promise, in that
it allowed for unlimited order KN-LMs to be eval-
uated with a modest memory footprint, however it
was many orders of magnitude slower for smaller m
than leading LM toolkits.

To illustrate the cost of querying, see Figure 3
(top) which shows per-sentence query time for KN,

Algorithm 1 N{1,2,3+}(Œ±¬∑) or N ‚Ä≤{1,2,3+}(Œ±¬∑)
1: function N123PFRONT(t, v, Œ±, is-prime)

. t is a CST, v is the node matching pattern Œ±
2: N1, N2, N3+‚Üê 0
3: for u‚Üê children(v) do
4: if is-prime then
5: f ‚Üê interval-symbols(t, [lb(u), rb(u)])
6: else
7: f ‚Üê size(u)
8: if 1 ‚â§ f ‚â§ 2 then
9: Nf ‚Üê Nf + 1

10: N3+‚Üê degree(v)‚àíN1 ‚àíN2
11: return N1, N2, N3+

based on the approach of Shareghi et al. (2015)
(also shown is MKN, through an extension of their
method as described in ¬ß4). It is clear that the run-
times for KN are much too long for practical use
‚Äì about 5 seconds per sentence, with the majority of
this time spent computingN1+(¬∑Œ±¬∑). Clearly opti-
misation is warranted, and the gains from it are spec-
tacular (see Figure 3 bottom, which uses the precom-
putation method as described in ¬ß4.2).

4 Extending to MKN

4.1 Computing MKN modified counts

A central requirement for extending Shareghi et al.
(2015) to support MKN are algorithms for comput-
ing N{1,2,3+}(Œ±¬∑) and N ‚Ä≤{1,2,3+}(Œ±¬∑), which we
now expound upon. Algorithm 1 computes both of
these quantities, taking as input a CST t, a node
v matching the pattern Œ±, the pattern and a flag
is-prime, denoting which of the N and N ‚Ä≤ variants
is required. This method enumerates the children of
the node (line 3) and calculates either the frequency
of each child (line 7) or the modified countN1+(¬∑Œ±
x), for each child u where x is the first symbol on
the edge vu (line 5). Lines 8 and 9 accumulate the
number of these values equal to one or two, and fi-
nally in line 10, N3+ is computed by the difference
between N1+(Œ±¬∑) = degree(v) and the already
counted events N1 +N2.

For example, computing N{1,2,3+}(b¬∑) in Fig-
ure 2 corresponds to enumerating over its three chil-
dren. Two of v‚Äôs children are leaf nodes {10, 8},
and one child has three leaf descendants {11, 2, 5},
hence N1 and N2 are 2 and 0 respectively, and N3+
is 1. Further, consider computing N ‚Ä≤{1,2,3+}(b¬∑) in

481



Figure 2, which again enumerates over child nodes
(whose path labels start with symbols b, c and d)
and computes the number of preceding symbols for
the extended patterns.3 Accordingly N ‚Ä≤1(b¬∑) = 2,
N ‚Ä≤2(b¬∑) = 1 and N ‚Ä≤3+(b¬∑) = 0.

While roughly similar in approach, comput-
ing N ‚Ä≤{1,2,3+}(Œ±¬∑) is in practice slower than
N{1,2,3+}(Œ±¬∑) since it requires calling interval-
symbols (line 7) instead of calling the constant time
size operation (line 5). This gives rise to a time
complexity of O(d|P (Œ±)| log œÉ) for N ‚Ä≤{1,2,3+}(Œ±¬∑)
where d is the number of children of v.

As illustrated in Figure 3 (top), the modified
counts (¬ß2) combined are responsible for 99% of the
query time. Moreover the already expensive runtime
of KN is considerably worsened in MKN due to the
additional counts required. These facts motivate op-
timisation, which we achieve by precomputing val-
ues, resulting in a 2500√ó speed up in query time as
shown in Figure 3 (bottom).

4.2 Efficient Precomputation

Language modelling toolkits such as KenLM and
SRILM precompute real valued probabilities and
backoff-weights at training time, such that querying
becomes largely a problem of retrieval. We might
consider taking a similar route in optimising our lan-
guage model, however we would face the problem
that floating point numbers cannot be compressed
very effectively. Even with quantisation, which can
have a detrimental effect on modelling perplexity,
we would not expect good compression and thus this
technique would limit the scaling potential of our ap-
proach.

For these reasons, instead we store the most ex-
pensive count data, targeting those counts which
have the greatest effect on runtime (see Figure 3
top). We expect these integer values to compress
well: as highlighted by Figure 4 most counts will
have low values, and accordingly a variable byte
compression scheme will be able to realise high
compression rates. Removing the need for comput-
ing these values at query time leaves only pattern
search and a few floating point operations in order
to compute language model probabilities (see ¬ß4.3)
which can be done cheaply.

3That is N1+(¬∑ bb) = 1, N1+(¬∑ bc) = 2, N1+(¬∑ bd) = 1.

25%

50%

75%

100%

0 16 32 48 64 80 96 112128
Stored value

%
of

va
lu

es
sm

al
le

ro
re

qu
al

th
an

0%

5%

10%

15%

2 3 4 5 6 7 8 9 10
Storage Threshold

%
of

to
ta

ls
pa

ce
us

ag
e

N1+(¬∑Œ±)
N1(Œ±¬∑)
N ‚Ä≤1(Œ±¬∑)
N2(Œ±¬∑)
N ‚Ä≤2(Œ±¬∑)
N1+(¬∑Œ±¬∑)
bv

Figure 4: Left: Distribution of values prestored for Eu-
roparl German; Right: Space usage of prestored values
relative to total index size for Europarl German for dif-
ferent storage thresholds (mÃÇ).

Our first consideration is how to structure the
cache. Given that each precomputed value is com-
puted using a CST node, v, (with the pattern as its
path-label), we structure the cache as a mapping be-
tween unique node identifiers id(v) and the precom-
puted values.4 Next we consider which values to
cache: while it is possible to precompute values for
every node in the CST, many nodes are unlikely to
be accessed at query time. Moreover, these rare pat-
terns are likely to be cheap to process using the on-
the-fly methods, given they occur in few contexts.
Consequently precomputing these values will bring
minimal speed benefits, while still incurring a mem-
ory cost. For this reason we precompute the val-
ues only for nodes corresponding to k-grams up to
length mÃÇ (for our word-level experiments mÃÇ = 10),
which are most likely to be accessed at runtime.5

The precomputation method is outlined in
Algorithm 2, showing how a compressed
cache is created for the quantities x ‚àà
{N1+(¬∑Œ±), N1+(¬∑Œ±¬∑), N12(Œ±¬∑), N ‚Ä≤12(Œ±¬∑)}.
The algorithm visits the suffix tree nodes in depth-
first-search (DFS) order, and selects a subset of
nodes for precomputation (line 7), such that the
remaining nodes are either rare or trivial to handle

4Each node can uniquely be identified by the order which it
is visited in a DFS traversal of the suffix tree. This corresponds
to the RANK of the opening parenthesis of the node in the bal-
anced parenthesis representation of the tree topology of the CST
which can be determined inO(1) time (Ohlebusch et al., 2010).

5We did not test other selection criteria. Other methods may
be more effective, such as selecting nodes for precomputation
based on the frequency of their corresponding patterns in the
training set.

482



Algorithm 2 Precomputing expensive counts
N{1,2}(Œ±¬∑), N1+(¬∑Œ±¬∑), N1+(¬∑Œ±), N ‚Ä≤{1,2}(Œ±¬∑).
1: function PRECOMPUTE(t, mÃÇ)
2: bvl‚Üê 0 ‚àÄl ‚àà [0, nodes(t)‚àí 1]
3: i(x)l ‚Üê 0 ‚àÄl ‚àà [0, nodes(t)‚àí 1], x ‚àà count types
4: j‚Üê 0
5: for v ‚Üê descendants(root(t)) do . DFS
6: d‚Üê string-depth(v)
7: if not is-leaf(v) ‚àß d ‚â§ mÃÇ then
8: l‚Üê id(v) . unique id
9: bvl‚Üê 1

10: Call N1PFRONTBACK1(t, v, ¬∑)
11: Call N123PFRONT(t, v, ¬∑, 0)
12: Call N123PFRONT(t, v, ¬∑, 1)
13: i(x)j ‚Üê counts from above, for each output x
14: j‚Üê j + 1
15: bvrrr ‚Üê compress-rrr(bv)
16: i‚Üê compress-dac({i(x) ‚àÄx})
17: write-to-disk(bvrrr ,i)

on-the-fly (i.e., leaf nodes). A node included
in the cache is marked by storing a 1 in the bit
vector bv (lines 8-9) at index l, where l is the node
identifier. For each selected node we precompute
the expensive counts in lines 10-12,

N1+(¬∑Œ±¬∑), N1+(¬∑Œ±) via6 N1PFRONTBACK1(t, v, ¬∑),
N{1,2}(Œ±¬∑) via N123PFRONT(t, v, ¬∑, 0),
N ‚Ä≤{1,2}(Œ±¬∑) via N123PFRONT(t, v, ¬∑, 1),

which are stored into integer vectors i(x) for each
count type x (line 13). The integer vectors are
streamed to disk and then compressed (lines 15-17)
in order to limit memory usage.

The final steps in lines 15 and 16 compress
the integer and bit-vectors. The integer vectors
i(x) are compressed using a variable length encod-
ing, namely Directly Addressable Variable-Length
Codes (DAC; Brisaboa et al. (2009)) which allows
for efficient storage of integers while providing effi-
cient random access. As the overwhelming majority
of our precomputed values are small (see Figure 4
left), this gives rise to a dramatic compression rate
of only ‚âà 5.2 bits per integer. The bit vector bv of
sizeO(n) where n is the number of nodes in the suf-
fix tree, is compressed using the scheme of Raman
et al. (2002) which supports constant time rank op-
eration over very large bit vectors.

6The function N1PFRONTBACK1 is defined as Algorithm 5
in Shareghi et al. (2015).

This encoding allows for efficient retrieval of the
precomputed counts at query time. The compressed
vectors are loaded into memory and when an ex-
pensive count is required for node v, the precom-
puted quantities can be fetched in constant time via
LOOKUP(v, bv, i(x)) = i(x)RANK(bv,id(v),1). We use
RANK to determine the number of 1s preceding v‚Äôs
position in the bit vector bv. This corresponds to v‚Äôs
index in the compressed integer vectors i(x), from
which its precomputed count can be fetched. This
strategy only applies for precomputed nodes; for
other nodes, the values are computed on-the-fly.

Figure 3 compares the query time breakdown for
on-the-fly count computation (top) versus precom-
putation (bottom), for both KN and MKN and with
different Markov orders, m. Note that query speed
improves dramatically, by a factor of about 2500√ó,
for precomputed cases. This improvement comes at
a modest cost in construction space. Precomputing
for CST nodes with m ‚â§ 10 resulted in 20% of the
nodes being selected for precomputation. The space
used by the precomputed values accounts for 20%
of the total space usage (see Figure 4 right). Index
construction time increased by 70%.

4.3 Computing MKN Probability
Having established a means of computing the requi-
site counts for MKN and an efficient precomputation
strategy, we now turn to the algorithm for computing
the language model probability. This is presented
in Algorithm 3, which is based on Shareghi et al.
(2015)‚Äôs single CST approach for computing the KN
probability (reported in their paper as Algorithm 4.)
Similar to their method, our approach implements
the recursive m-gram probability formulation as an
iterative loop (here using MKN). The core of the
algorithm are the two nodes vfull and v which cor-
respond to nodes matching the full k-gram and its
(k ‚àí 1)-gram context, respectively.

Although similar to Shareghi et al. (2015)‚Äôs
method, which also features a similar right-to-left
pattern lookup, in addition we optimise the compu-
tation of a full sentence probability by sliding a win-
dow of widthm over the sequence from left-to-right,
adding one new word at a time.7 This allows for the
re-use of nodes in one window matching the full k-

7Pauls and Klein (2011) propose a similar algorithm for trie-
based LMs.

483



Algorithm 3 MKN probability P
(
wi|wi‚àí1i‚àí(m‚àí1)

)

1: function PROBMKN(t, wii‚àím+1,m, [vk]
m‚àí1
k=0 )

2: Assumption: vk is the matching node for wi‚àí1i‚àík
3: vfull0 ‚Üê root(t) . tracks match for wii‚àík
4: p‚Üê 1/|œÉ|
5: for k ‚Üê 1 to m do
6: if vk‚àí1 does not match then
7: break out of loop
8: vfullk ‚Üê back-search([lb(vfullk‚àí1), rb(vfullk‚àí1)], wi‚àík+1)
9: Dk(1),Dk(2),Dk(3+)‚Üê discounts for k-grams

10: if k = m then
11: c‚Üê size(vfullk )
12: d‚Üê size(vk‚àí1)
13: N1,2,3+‚Üê N123PFRONT(t, vk‚àí1, wi‚àí1i‚àík+1, 0)
14: else
15: c‚Üê N1PBACK1(t, vfullk , wi‚àí1i‚àík+1)
16: d‚Üê N1PFRONTBACK1(t, vk‚àí1, wi‚àí1i‚àík+1)
17: N1,2,3+‚Üê N123PFRONT(t, vk‚àí1, wi‚àí1i‚àík+1, 1)
18: if 1 ‚â§ c ‚â§ 2 then
19: c‚Üê c‚àí Dk(c)
20: else
21: c‚Üê c‚àí Dk(3+)
22: Œ≥‚Üê Dk(1)N1 + Dk(2)N2 + Dk(3+)N3+
23: p‚Üê 1

d
(c+ Œ≥p)

24: return
(
p,
[
vfullk
]m‚àí1
k=0

)

grams, vfull, as the nodes matching the context in the
subsequent window, denoted v.

For example, in the sentence ‚ÄúThe Force is strong
with this one.‚Äù, computing the 4-gram probability
of ‚ÄúThe Force is strong‚Äù requires matches into the
CST for ‚Äústrong‚Äù, ‚Äúis strong‚Äù, etc. As illustrated
in Table 1, for the next 4-gram resulting from slid-
ing the window to include ‚Äúwith‚Äù, the denomina-
tor terms require exactly these nodes, see Figure 5.
Practically, this is achieved by storing the matching
vfull nodes computed in line 8, and passing this vec-
tor as the input argument [vk]

m‚àí1
k=0 to the next call

to PROBMKN (line 1). This saves half the calls to
backward-search, which, as shown in Figure 3, rep-
resent a significant fraction of the querying cost, re-
sulting in a 30% improvement in query runtime.

The algorithm starts by considering the unigram
probability, and grows the context to its left by one
word at a time until the m-gram is fully covered
(line 5). This best suits the use of backward-search
in a CST, which proceeds from right-to-left over
the search pattern. At each stage the search for
vfullk uses the span from the previous match, v

full
k‚àí1,

S

IS

FIS

TFIS

w

SW

ISW

FISW

S

IS

FIS

N1+(‚Ä¢W) N1+(‚Ä¢‚Ä¢)

N1+(‚Ä¢SW) N1+(‚Ä¢S‚Ä¢) N‚Äô123+(S‚Ä¢)

N1+(‚Ä¢ ISW) N1+(‚Ä¢IS ‚Ä¢) N‚Äô123+(IS ‚Ä¢)

c (FISW) c (FIS) N123+(FIS‚Ä¢)

N‚Äô123+(Œµ‚Ä¢)

Root : [0,n]Root : [0,n]

Figure 5: Example MKN probability computation for a
4-gram LM applied to ‚ÄúThe Force is strong with‚Äù (each
word abbreviated to its first character), showing in the
two left columns the suffix matches required for the 4-
gram FISW and elements which can be reused from pre-
vious 4-gram computation (gray shading), TFIS. Ele-
ments on the right denote the count and occurrence statis-
tics derived from the suffix matches, as linked by blue
lines.

along with the BWT to efficiently locate the match-
ing node. Once the nodes matching the full se-
quence and its context are retrieved, the procedure
is fairly straightforward: the discounts are loaded
on line 9 and applied in lines 18-21, while the nu-
merator, denominator and smoothing quantities as
required for computing P and PÃÑ are calculated in
lines 10-13 and 15-17, respectively.8 Note that the
calls for functions N123PFRONT, N1PBACK1, and
N1PFRONTBACK1 are avoided if the corresponding
node is amongst the selected nodes in the precompu-
tation step; instead the LOOKUP function is called.
Finally, the smoothing weight Œ≥ is computed in line
22 and the conditional probability computed on line
23. The loop terminates when we reach the length
limit k = m or we cannot match the context, i.e.,
wi‚àí1i‚àík is not in the training corpus, in which case the
probability value p for the longest match is returned.

We now turn to the discount parameters,
Dk(j) , k ‚â§ m, j ‚àà 1, 2, 3+, which are functions of
the corpus statistics as outlined in Figure 1. While
these could be computed based on raw m-gram
statistics, this approach is very inefficient for large
m ‚â• 5; instead these values can be computed effi-
ciently from the compressed data structures. Algo-
rithm 4 outlines how the Dk(i) values can be com-
puted directly from the CST. This method iterates

8N1PBACK1 and N1PFRONTBACK1 are defined in
Shareghi et al. (2015); see also ¬ß3 for an overview.

484



Algorithm 4 Compute discounts
1: function COMPUTEDISCOUNTS(t, mÃÑ, bv‚Ä≤, SA )
2: ni(k)‚Üê 0, nÃÑi(k)‚Üê 0 ‚àÄi ‚àà [1, 4], k ‚àà [1, mÃÑ]
3: N1+(¬∑¬∑)‚Üê 0
4: for v ‚Üê descendants(root(t)) do . DFS
5: dP ‚Üê string-depth(parent(v))
6: d‚Üê string-depth(v)
7: dS ‚Üê depth-next-sentinel(SA, bv‚Ä≤, lb(v))
8: i‚Üê size(v) . frequency
9: c‚Üê interval-symbols(t, [lb(v), rb(v)]) . left occ.

10: for k ‚Üê dP + 1 to min (d, mÃÑ, dS ‚àí 1) do
11: if k = 2 then
12: N1+(¬∑¬∑)‚Üê N1+(¬∑¬∑) + 1
13: if 1 ‚â§ i ‚â§ 4 then
14: ni(k)‚Üê ni(k) + 1
15: if 1 ‚â§ c ‚â§ 4 then
16: nÃÑc(k)‚Üê nÃÑc(k) + 1
17: Dk(i)‚Üê computed using formula in Figure 1
18: return Dk(i), k ‚àà [1, mÃÑ], i ‚àà {1, 2, 3+}

over the nodes in the suffix tree, and for each node
considers the k-grams encoded in the edge label,
where each k-gram is taken to start at the root node
(to avoid duplicate counting, we consider k-grams
only contained on the given edge but not in the par-
ent edges, i.e., by bounding k based on the string
depth of the parent and current nodes, dP ‚â§ k ‚â§ d).
For each k-gram we record its count, i (line 8), and
the number of unique symbols to the left, c (line
9), which are accumulated in an array for each k-
gram size for values between 1 and 4 (lines 13-14
and 15-16, respectively). We also record the number
of unique bigrams by incrementing a counter during
the traversal (lines 11-12).

Special care is required to exclude edge labels that
span sentence boundaries, by detecting special sen-
tinel symbols (line 8) that separate each sentence or
conclude the corpus. This check could be done by
repeatedly calling edge(v, k) to find the kth symbol
on the given edge to check for sentinels, however
this is a slow operation as it requires multiple back-
ward search calls. Instead we precalculate a bit vec-
tor, bv‚Ä≤, of size equal to the number of tokens in the
corpus, n, in which sentinel locations in the text are
marked by 1 bits. Coupled with this, we use the suf-
fix array SA, such that

depth-next-sentinel(SA, bv‚Ä≤, `) =

SELECT(bv‚Ä≤,RANK(bv‚Ä≤, SA`, 1) + 1, 1)‚àí SA` ,

where SA` returns the offset into the text for index `,
and the SA is stored uncompressed to avoid the ex-
pensive cost of recovering these values.9 This func-
tion can be understood as finding the first occurrence
of the pattern in the text (using SA`) then finding the
location of the next 1 in the bit vector, using constant
time RANK and SELECT operations. This locates the
next sentinel in the text, after which it computes the
distance to the start of the pattern. Using this method
in place of explicit edge calls improved the training
runtime substantially up to 41√ó.

We precompute the discount values for k ‚â§ mÃÑ-
grams. For querying with m > mÃÑ (including‚àû) we
reuse the discounts for the largest mÃÑ-grams.10

5 Experiments

To evaluate our approach we measure memory and
time usage, along with the predictive perplexity
score of word-level LMs on a number of different
corpora varying in size and domain. For all of our
word-level LMs, we use mÃÑ, mÃÇ ‚â§ 10. We also
demonstrate the positive impact of increasing the set
limit on mÃÑ, mÃÇ from 10 to 50 on improving character-
level LM perplexity. The SDSL library (Gog et al.,
2014) is used to implement our data structures. The
benchmarking experiments were run on a single core
of a Intel Xeon E5-2687 v3 3.10GHz server with
500GiB of RAM.

In our word-level experiments, we use the Ger-
man subset of the Europarl (Koehn, 2005) as a small
corpus, which is 382 MiB in size measuring the raw
uncompressed text. We also evaluate on much larger
corpora, training on 32GiB subsets of the dedupli-
cated English, Spanish, German, and French Com-
mon Crawl corpus (Buck et al., 2014). As test
sets, we used newstest-2014 for all languages except
Spanish, for which we used newstest-2013.11 In our

9Although the SA can be very large, we need not store it in
memory. The DFS traversal in Algorithm 4 (lines 4‚Äì16) means
that the calls to SA` occur in increasing order of `. Hence, we
use on-disk storage for the SA with a small memory mapped
buffer, thereby incurring a negligible memory overhead.

10It is possible to compute the discounts for all patterns of the
text using our algorithm with complexity linear in the length of
the text. However, the discounts appear to converge by pattern
length mÃÑ = 10. This limit also helps to avoid problems of
wild fluctuations in discounts for very long patterns arising from
noise for low count events.

11http://www.statmt.org/wmt{13,14}/test.tgz

485



construction load+query

10

100

1k

10k

100k

0.1 1.0 10.0 0.1 1.0 10.0
Memory [GiB]

Ti
m

e
[s

ec
]

CST on-the-fly
CST precompute

KenLM (trie)
KenLM (probing)

SRILM

Figure 6: Memory consumption and total runtime for the
CST with and without precomputation, KenLM (trie), and
SRILM (default) with m ‚àà [2, 10], while we also in-
clude m =‚àû for CST methods. Trained on the Europarl
German corpus and tested over the bottom 1M sentences
from the German Common Crawl corpus.

benchmarking experiments we used the bottom 1M
sentences (not used in training) of the German Com-
man Crawl corpus. We used the preprocessing script
of Buck et al. (2014), then removed sentences with
‚â§ 2 words, and replaced rare words12 c ‚â§ 9 in the
training data with a special token. In our character-
level experiments, we used the training and test data
of the benchmark 1-billion-words corpus (Chelba et
al., 2013).

Small data: German Europarl First, we com-
pare the time and memory consumption of both the
SRILM and KenLM toolkits, and the CST on the
small German corpus. Figure 6 shows the memory
usage for construction and querying for CST-based
methods w/o precomputation is independent of m,
but becomes substantially with m for the SRILM
and KenLM benchmarks. To make our results com-
parable to those reported in (Shareghi et al., 2015)
for query time measurements we reported the load-
ing and query time combined. The construction cost
is modest, requiring less memory than the bench-
mark systems for m ‚â• 3, and running in a sim-
ilar time13 (despite our method supporting queries

12Running with the full vocabulary increased the memory re-
quirement by 40% for construction and 5% for querying with
our model, and 10% and 30%, resp. for KenLM. Construction
times for both approaches were 15% slower, but query runtime
was 20% slower for our model versus 80% for KenLM.

13 For all timings reported in the paper we manually flushed
the system cache between each operation (both for construction

size (M) perplexity
tokens m = 2 m = 3 m = 5 m = 7 m = 10 m =‚àû

EN 6470 321.6 183.8 154.3 152.7 152.5 152.3
ES 6276 231.3 133.2 111.7 109.7 109.3 109.2
FR 6100 215.8 109.2 85.2 83.1 82.6 82.4
DE 5540 588.3 336.6 292.8 288.1 287.8 287.8

Table 2: Perplexities on English, French, German new-
stests 2014, and Spanish newstest 2013 when trained on
32GiB chunks of English, Spanish, French, and German
Common Crawl corpus.

of unlimited size). Precomputation adds to the con-
struction time, which rose from 173 to 299 seconds,
but yielded speed improvements of several orders of
magnitude for querying (218k to 98 seconds for 10-
gram). In querying, the CST-precompute method
is 2-4√ó slower than both SRILM and KenLM for
large m ‚â• 5, with the exception of m = 10
where it outperforms SRILM. A substantial fraction
of the query time is loading the structures from disk;
when this cost is excluded, our approach is between
8-13√ó slower than the benchmark toolkits. Note that
perplexity computed by the CST closely matched
KenLM (differences ‚â§ 0.1).

Big Data: Common Crawl Table 2 reports the
perplexity results for training on 32GiB subsets of
the English, Spanish, French, and German Common
Crawl corpus. Note that with such large datasets,
perplexity improves with increasing m, with sub-
stantial gains available moving above the widely
used m = 5. This highlights the importance of our
approach being independent from m, in that we can
evaluate for any m, including‚àû, at low cost.

Heterogeneous Data To illustrate the effects of
domain shift, corpus size and language model capac-
ity on modelling accuracy, we now evaluate the sys-
tem using a variety of different training corpora. Ta-
ble 3 reports the perplexity for German when train-
ing over datasets ranging from the small Europarl up
to 32GiB of the Common Crawl corpus. Note that
the test set is from the same domain as the News

and querying) to remove the effect of caching on runtime. To
query KenLM, we used the speed optimised populate method.
(We also compare the memory optimised lazy method in Fig-
ure 7.) To train and query SRILM we used the default method
which is optimised for speed, but had slightly worse memory
usage than the compact method.

486



size (M) perplexity
Training tokens sents m = 3 m = 5 m = 10

Europarl 55 2.2 1004.8 973.3 971.4
Commentary 6 0.2 941.8 928.6 928.1
NCrawl2007 37 2.0 514.8 493.5 488.9
NCrawl2008 126 6.8 427.7 404.8 400.0
NCrawl2009 119 6.5 433.4 408.9 404.7
NCrawl2010 54 3.0 472.7 450.9 446.8
NCrawl2011 298 16.3 362.6 335.9 327.9
NCrawl2012 377 20.9 343.9 315.6 307.3
NCrawl2013 641 35.1 268.9 229.8 225.6
NCrawl2014 845 46.3 247.6 195.2 189.3

All combined 2560 139.3 211.8 158.9 151.5

CCrawl1G 173 14.2 542.8 515.5 512.7
CCrawl2G 346 28.5 493.2 462.3 459.2
CCrawl4G 692 56.2 446.5 412.2 408.8
CCrawl8G 1390 110.2 402.1 364.4 360.9
CCrawl16G 2770 216.7 364.9 323.9 319.6
CCrawl32G 5540 426.6 336.6 292.8 287.8

Table 3: Perplexity of German newstest 2014 with differ-
ent datasets (Europarl, News-Commentary, NewsCrawl
2007-2014, CommonCrawl 1-32 GiB chunks) and m.

Crawl, which explains the vast difference in perplex-
ities. The domain effect is strong enough to elimi-
nate the impact of using much larger corpora, com-
pare 10-gram perplexities for training on the smaller
News Crawl 2007 corpus versus Europarl. However
‚Äòbig data‚Äô is still useful: in all cases the perplexity
improves as we provide more data from the same
source. Moreover, the magnitude of the gain in per-
plexity when increasing m is influenced by the data
size: with more training data higher order m-grams
provide richer models; therefore, the scalability of
our method to large datasets is crucially important.

Benchmarking against KenLM Next we com-
pare our model against the state-of-the-art method,
KenLM trie. The perplexity difference between CST
and KenLM was less than 0.003 in all experiments.

Construction Cost. Figure 7a compares the peak
memory usage of our CST models and KenLM.
KenLM is given a target memory usage of the peak
usage of our CST models.14 The construction phase
for the CST required more time for lower order mod-
els (see Figure 7c) but was comparable for larger

14Using the memory budget option, -S. Note that KenLM of-
ten used more memory than specified. Allowing KenLM use of
80% of the available RAM reduced training time by a factor of
between 2 and 4.

m, roughly matching KenLM for m = 10.15 For
the 32GiB dataset, the CST model took 14 hours to
build, compared to KenLM‚Äôs 13.5 and 4 hours for
the 10-gram and 5-gram models, respectively.

Query Cost. As shown in Figure 7b, the mem-
ory requirements for querying with the CST method
were consistently lower than KenLM for m ‚â• 4:
for m = 10 the memory consumption of KenLM
was 277GiB compared to our 27GiB, a 10√ó im-
provement. This closely matches the file sizes of
the stored models on disk. Figure 7d reports the
query runtimes, showing that KenLM becomes sub-
stantially slower with increasing dataset size and in-
creasing language model order. In contrast, the run-
time of our CST approach is much less affected by
data size or model order. Our approach is faster than
KenLM with the memory optimised lazy option for
m ‚â• 3, often by several orders of magnitude. For
the faster KenLM populate, our model is still highly
competitive, growing to 4√ó faster for the largest data
size.16 The loading time is still a significant part
of the runtime; without this cost, our model is 5√ó
slower than KenLM populate for m = 10 on the
largest dataset. Running our model with m =‚àû on
the largest data size did not change the memory us-
age and only had a minor effect on runtime, taking
645s.

Character-level modelling To demonstrate the
full potential of our approach, we now consider
character based language modelling, evaluated on
the large benchmark 1-billion-words language mod-
elling corpus, a 3.9GiB (training) dataset with 768M
words and 4 billion characters.17 Table 4 shows the
test perplexity results for our models, using the full
training vocabulary. Note that perplexity improves
with m for the character based model, but plateaus
at m = 10 for the word based model; one reason for
this is the limited discount computation, mÃÑ ‚â§ 10,

15The CST method uses a single thread for construction,
while KenLM uses several threads. Most stages of construction
for our method could be easily parallelised.

16KenLM benefits significantly from caching which can oc-
cur between runs or as more queries are issued (from m-gram
repetition in our large 1 million sentence test set), whereas the
CST approach does not benefit noticeably (as it does not incor-
porate any caching functionality).

17http://www.statmt.org/lm-benchmark/

487

http://www.statmt.org/lm-benchmark/


construction load+query

1

10

100

1 4 8 16 32 1 4 8 16 32
Input Size [GiB]

M
em

or
y

[G
iB

]

construction load+query

100

1k

10k

1 4 8 16 32 1 4 8 16 32
Input Size [GiB]

Ti
m

e
[s

ec
on

ds
]

m
2gram
3gram
4gram
5gram
8gram
10gram

method
ken (pop.)
ken (lazy)
cst(a) (b) (c) (d)

Figure 7: Memory and runtime statistics for CST and KenLM for construction and querying with different amounts
of German Common Crawl training data and different Markov orders, m. We compare the query runtimes against the
optimised version of KenLM for memory (lazy) and speed (populate). For clarity, in the figure we only show CST
numbers form = 10; the results for other settings ofm are very similar. KenLM was trained to match the construction
memory requirements of the CST-precompute method.

unit time (s) mem (GiB)m = 5m = 10m = 20m =‚àû
word 8164 6.29 73.45 68.66 68.76 68.80
character 17 935 18.58 3.93 2.69 2.37 2.33

Table 4: Perplexity results for the 1 billion word bench-
mark corpus, showing word based and character based
MKN models, for different m. Timings and peak mem-
ory usage are reported for construction. The word
model computed discounts and precomputed counts up
to mÃÑ, mÃÇ = 10, while the character model used thresholds
mÃÑ, mÃÇ = 50. Timings measured on a single core.

for the word model, which may not be a good pa-
rameterisation for m > mÃÑ.

Despite the character based model (implicitly)
having a massive parameter space, estimating this
model was tractable with our approach: the con-
struction time was a modest 5 hours (and 2.3 hours
for the word based model.) For the same dataset,
Chelba et al. (2013) report that training a MKN 5-
gram model took 3 hours using a cluster of 100
CPUs; our algorithm is faster than this, despite only
using a single CPU core.18 Queries were also fast:
0.72-0.87ms and 15ms per sentence for word and
character based models, respectively.

6 Conclusions

We proposed a language model based on com-
pressed suffix trees, a representation that is highly

18Chelba et al. (2013) report a better perplexity of 67.6, but
they pruned the training vocabulary, whereas we did not. Also
we use a stringent treatment of OOV, following Heafield (2013).

compact and can be easily held in memory, while
supporting queries needed in computing language
model probabilities on the fly. We presented several
optimisations to accelerate this process, with only
a modest increase in construction time and memory
usage, yet improving query runtimes up to 2500√ó.
In benchmarking against the state-of-the-art KenLM
package on large corpora, our method has superior
memory usage and highly competitive runtimes for
both querying and training. Our approach allows
easy experimentation with high order language mod-
els, and our results provide evidence that such high
orders are most useful when using large training
sets.

We posit that further perplexity gains can be re-
alised using richer smoothing techniques, such as a
non-parametric Bayesian prior (Teh, 2006; Wood et
al., 2011). Our ongoing work will explore this av-
enue, as well as integrating our language model into
the Moses machine translation system, and improv-
ing the querying time by caching the lower order
probabilities (e.g., m < 4) which we believe can
improve query time substantially while maintaining
a modest memory footprint.

Acknowledgements

This research was supported by the Australian Re-
search Council (FT130101105), National ICT Aus-
tralia (NICTA) and a Google Faculty Research
Award.

488



References

Thorsten Brants, Ashok C Popat, Peng Xu, Franz J Och,
and Jeffrey Dean. 2007. Large language models
in machine translation. In Proceedings of the Joint
Conference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning.

Nieves R Brisaboa, Susana Ladra, and Gonzalo Navarro.
2009. Directly addressable variable-length codes. In
Proceedings of the International Symposium on String
Processing and Information Retrieval.

Christian Buck, Kenneth Heafield, and Bas van Ooyen.
2014. N-gram counts and language models from the
common crawl. In Proceedings of the Language Re-
sources and Evaluation Conference.

Michael Burrows and David Wheeler. 1994. A block
sorting lossless data compression algorithm. Techni-
cal Report 124, Digital Equipment Corporation Sys-
tems Research Center.

Ciprian Chelba, Tomas Mikolov, Mike Schuster, Qi Ge,
Thorsten Brants, Phillipp Koehn, and Tony Robin-
son. 2013. One billion word benchmark for measur-
ing progress in statistical language modeling. arXiv
preprint arXiv:1312.3005.

Stanley F Chen and Joshua Goodman. 1999. An empir-
ical study of smoothing techniques for language mod-
eling. Computer Speech & Language, 13(4):359‚Äì393.

Kenneth Church, Ted Hart, and Jianfeng Gao. 2007.
Compressing trigram language models with Golomb
coding. In Proceedings of the Conference on Empiri-
cal Methods in Natural Language Processing.

Paolo Ferragina and Giovanni Manzini. 2000. Oppor-
tunistic data structures with applications. In Proceed-
ings of the Annual Symposium on Foundations of Com-
puter Science.

Ulrich Germann, Eric Joanis, and Samuel Larkin. 2009.
Tightly packed tries: How to fit large models into
memory, and make them load fast, too. In Proceedings
of the Workshop on Software Engineering, Testing, and
Quality Assurance for Natural Language Processing.

Simon Gog, Timo Beller, Alistair Moffat, and Matthias
Petri. 2014. From theory to practice: Plug and play
with succinct data structures. In Proceedings of the In-
ternational Symposium on Experimental Algorithms.

R. Grossi, A. Gupta, and J. S. Vitter. 2003. High-order
entropy-compressed text indexes. In Proceedings of
the ACM-SIAM symposium on Discrete algorithms.

David Guthrie and Mark Hepple. 2010. Storing the web
in memory: Space efficient language models with con-
stant time retrieval. In Proceedings of the Conference
on Empirical Methods in Natural Language Process-
ing.

Kenneth Heafield, Ivan Pouzyrevsky, Jonathan H. Clark,
and Philipp Koehn. 2013. Scalable modified Kneser-
Ney language model estimation. In Proceedings of the
Annual Meeting of the Association for Computational
Linguistics.

Kenneth Heafield. 2011. KenLM: Faster and smaller lan-
guage model queries. In Proceedings of the Workshop
on Statistical Machine Translation.

Kenneth Heafield. 2013. Efficient Language Modeling
Algorithms with Applications to Statistical Machine
Translation. Ph.D. thesis, Carnegie Mellon University.

Guy Jacobson. 1989. Space-efficient static trees and
graphs. In Proceedings of the Annual Symposium on
Foundations of Computer Science.

Casey Redd Kennington, Martin Kay, and Annemarie
Friedrich. 2012. Suffix trees as language models.
In Proceedings of the Conference on Language Re-
sources and Evaluation.

Philipp Koehn. 2005. Europarl: A parallel corpus for
statistical machine translation. In Proceedings of the
Machine Translation summit.

Abby Levenberg and Miles Osborne. 2009. Stream-
based randomised language models for SMT. In Pro-
ceedings of the Conference on Empirical Methods in
Natural Language Processing.

Udi Manber and Eugene W. Myers. 1993. Suffix arrays:
A new method for on-line string searches. SIAM Jour-
nal on Computing, 22(5):935‚Äì948.

Gonzalo Navarro. 2014. Wavelet trees for all. Journal of
Discrete Algorithms, 25:2‚Äì20.

Enno Ohlebusch, Johannes Fischer, and Simon Gog.
2010. CST++. In Proceedings of the International
Symposium on String Processing and Information Re-
trieval.

Adam Pauls and Dan Klein. 2011. Faster and smaller n-
gram language models. In Proceedings of the Annual
Meeting of the Association for Computational Linguis-
tics: Human Language Technologies.

Rajeev Raman, Venkatesh Raman, and S Srinivasa Rao.
2002. Succinct indexable dictionaries with applica-
tions to encoding k-ary trees and multisets. In Pro-
ceedings of the thirteenth annual ACM-SIAM Sympo-
sium on Discrete algorithms.

Thomas Schnattinger, Enno Ohlebusch, and Simon Gog.
2010. Bidirectional search in a string with wavelet
trees. In Proceedings of the Annual Symposium on
Combinatorial Pattern Matching.

Ehsan Shareghi, Matthias Petri, Gholamreza Haffari, and
Trevor Cohn. 2015. Compact, efficient and unlimited
capacity: Language modeling with compressed suffix
trees. In Proceedings of the Conference on Empirical
Methods in Natural Language Processing.

489



Jeffrey Sorensen and Cyril Allauzen. 2011. Unary data
structures for language models. In Proceedings of IN-
TERSPEECH.

Andreas Stolcke, Jing Zheng, Wen Wang, and Victor
Abrash. 2011. SRILM at sixteen: Update and
outlook. In Proceedings of IEEE Automatic Speech
Recognition and Understanding Workshop.

Andreas Stolcke. 2002. SRILM‚Äìan extensible language
modeling toolkit. In Proceedings of the International
Conference of Spoken Language Processing.

David Talbot and Miles Osborne. 2007. Randomised
language modelling for statistical machine translation.
In Proceedings of the Annual Meeting of the Associa-
tion for Computational Linguistics.

Yee Whye Teh. 2006. A hierarchical Bayesian language
model based on Pitman-Yor processes. In Proceedings
of the Annual Meeting of the Association for Compu-
tational Linguistics.

Taro Watanabe, Hajime Tsukada, and Hideki Isozaki.
2009. A succinct n-gram language model. In Pro-
ceedings of the Annual Meeting of the Association for
Computational Linguistics.

Peter Weiner. 1973. Linear pattern matching algorithms.
In Proceedings of the Annual Symposium Switching
and Automata Theory.

Frank Wood, Jan Gasthaus, CeÃÅdric Archambeau,
Lancelot James, and Yee Whye Teh. 2011. The
sequence memoizer. Communications of the ACM,
54(2):91‚Äì98.

Ying Zhang and Stephan Vogel. 2006. Suffix array and
its applications in empirical natural language process-
ing. Technical report, CMU, Pittsburgh PA.

490


