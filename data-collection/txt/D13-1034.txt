










































Adaptor Grammars for Learning Non-Concatenative Morphology


Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 345–356,
Seattle, Washington, USA, 18-21 October 2013. c©2013 Association for Computational Linguistics

Adaptor Grammars for Learning Non-Concatenative Morphology

Jan A. Botha and Phil Blunsom
Department of Computer Science

University of Oxford
Oxford, OX1 3QD, UK

{jan.botha,phil.blunsom}@cs.ox.ac.uk

Abstract

This paper contributes an approach for
expressing non-concatenative morphological
phenomena, such as stem derivation in
Semitic languages, in terms of a mildly
context-sensitive grammar formalism. This
offers a convenient level of modelling ab-
straction while remaining computationally
tractable. The nonparametric Bayesian frame-
work of adaptor grammars is extended to this
richer grammar formalism to propose a prob-
abilistic model that can learn word segmenta-
tion and morpheme lexicons, including ones
with discontiguous strings as elements, from
unannotated data. Our experiments on He-
brew and three variants of Arabic data find
that the additional expressiveness to capture
roots and templates as atomic units improves
the quality of concatenative segmentation and
stem identification. We obtain 74% accuracy
in identifying triliteral Hebrew roots, while
performing morphological segmentation with
an F1-score of 78.1.

1 Introduction

Unsupervised learning of morphology is the task
of acquiring, from unannotated data, the intra-word
building blocks of a language and the rules by which
they combine to form words. This task is of interest
both as a gateway for studying language acquisition
in humans and as a way of producing morphological
analyses that are of practical use in a variety of nat-
ural language processing tasks, including machine
translation, parsing and information retrieval.

A particularly interesting version of the morphol-
ogy learning problem comes from languages that
use templatic morphology, such as Arabic, He-
brew and Amharic. These Semitic languages de-
rive verb and noun stems by interspersing abstract

root morphemes into templatic structures in a non-
concatenative way. For example, the Arabic root
k·t·b can combine with the template (i-a) to derive
the noun stem kitab (book). Established morpho-
logical analysers typically ignore this process and
simply view the derived stems as elementary units
(Buckwalter, 2002), or their account of it coincides
with a requirement for extensive linguistic knowl-
edge and hand-crafting of rules (Finkel and Stump,
2002; Schneider, 2010; Altantawy et al., 2010). The
former approach is bound to suffer from vocabu-
lary coverage issues, while the latter clearly does
not transfer easily across languages. The practical
appeal of unsupervised learning of templatic mor-
phology is that it can overcome these shortcomings.

Unsupervised learning of concatenative morphol-
ogy has received extensive attention, partly driven
by the MorphoChallenge (Kurimo et al., 2010) in re-
cent years, but that is not the case for root-templatic
morphology (Hammarström and Borin, 2011).

In this paper we present a model-based method
that learns concatenative and root-templatic mor-
phology in a unified framework. We build on two
disparate strands of work from the literature: Firstly,
we apply simple Range Concatenating Grammars
(SRCGs) (Boullier, 2000) to parse contiguous and
discontiguous morphemes from an input string.
These grammars are mildly-context sensitive (Joshi,
1985), a superset of context-free grammars that
retains polynomial parsing time-complexity. Sec-
ondly, we generalise the nonparametric Bayesian
learning framework of adaptor grammars (Johnson
et al., 2007) to SRCGs.1 This should also be rel-

1Our formulation is in terms of SRCGs, which are equiv-
alent in power to linear context-free rewrite systems (Vijay-
Shanker et al., 1987) and multiple context-free grammars (Seki
et al., 1991), all of which are weaker than (non-simple) range
concatenating grammars (Boullier, 2000).

345



evant to other applications of probabilistic SRCGs,
e.g. in parsing (Maier, 2010), translation (Kaesham-
mer, 2013) and genetics (Kato et al., 2006).

In addition to unannotated data, our method re-
quires as input a minimal set of high-level grammar
rules that encode basic intuitions of the morphology.
This is where there would be room to become very
language specific. Our aim, however, is not to obtain
a best-published result in a particular language, but
rather to create a method that is applicable across
a variety of morphological processes. The specific
rules used in our empirical evaluation on Arabic and
Hebrew therefore contain hardly any explicit lin-
guistic knowledge about the languages and are ap-
plicable across the family of Semitic languages.

2 A powerful grammar for morphology

Concatenative morphology lends itself well to an
analysis in terms of finite-state transducers (FSTs)
(Koskenniemi, 1984). With some additional effort,
FSTs can also encode non-concatenative morphol-
ogy (Kiraz, 2000; Beesley and Karttunen, 2003;
Cohen-Sygal and Wintner, 2006; Gasser, 2009). De-
spite this seeming adequacy of regular languages to
describe morphology, we see two main shortcom-
ings that motivate moving further up the Chom-
sky hierarchy of formal languages: first is the is-
sue of learning. We are not aware of successful at-
tempts at inducing FST-based morphological analy-
sers in an unsupervised way, and believe the chal-
lenge lies in the fact that FSTs do not offer a conve-
nient way of expressing prior linguistic intuitions to
guide the learning process. Secondly, an FST com-
posed of multiple machines might capture morpho-
logical processes well and excel at analysis, but in-
terpretability of its internal operations are limited.

These shortcomings are overcome for concate-
native morphology by context-free adaptor gram-
mars, which allowed diverse segmentation models
to be formulated and investigated within a single
framework (Johnson et al., 2007; Johnson, 2008;
Sirts and Goldwater, 2013). In principle, that cov-
ers a wide range of phenomena (typical example
language in parentheses): affixal inflection (Czech)
and derivation (English), agglutinative derivation
(Turkish, Finnish), compounding (German). Our
agenda here is to extend that approach to include
non-concatenative processes such as root-templatic

derivation (Arabic), infixation (Tagalog) and cir-
cumfixation (Indonesian). In this pursuit, an ab-
straction that permits discontiguous constituents is
a highly useful modelling tool, but requires looking
beyond context-free grammars.

An idealised generative grammar that would cap-
ture all the aforementioned phenomena could look
like this:

Word→ (Pre∗ Stem Suf∗)+ (1)
e.g. English un+accept+able

Stem |Pre |Suf→ Morph (2)
Stem→ intercal (Root,Template) (3)
e.g. Arabic derivation k·t·b + i·a⇒ kitab (book)

Stem→ infix (Stem, Infix) (4)
e.g. Tagalog sulat (write)⇒ sumulat (wrote)

Stem→ circfix (Stem,Circumfix) (5)
e.g. Indonesian percaya (to trust)

⇒ kepercayaan (belief)

where the symbols (excluding Word and Stem) im-
plicitly expand to the relevant terminal strings. The
bold-faced “functions” combine the potentially dis-
contiguous yields of the argument symbols into sin-
gle contiguous strings, e.g. infix(s·ulat, um) pro-
duces stem sumulat.

Taken by themselves, the first two rules are sim-
ply a CFG that describes word formation as the
concatenation of stems and affixes, a formulation
that matches the underlying grammar of Morfessor
(Creutz and Lagus, 2007), a well-studied unsuper-
vised model.

The key aim of our extension is that we want the
grammar to capture a discontiguous string like k·t·b
as a single constituent in a parse tree. This leads to
well-understood problems in probabilistic grammars
(e.g. what is this rule’s probability?), but also corre-
sponds to the linguistic consideration that k·t·b is a
proper morpheme of the language (Prunet, 2006).

3 Simple range concatenating grammars

In this section we define SRCGs formally and
illustrate how they can be used to model non-
concatenative morphology. SRCGs define lan-
guages that are recognisable in polynomial time, yet
can capture discontiguous elements of a string un-
der a single category (Boullier, 2000). An SRCG-

346



rule operates on vectors of ranges in contrast to the
way a CFG-rule operates on single ranges (spans).
In other words, a non-terminal symbol in an SRCG
(CFG) derivation can dominate a subset (substring)
of terminals in an input string.

3.1 Formalism

An SRCG G is a tuple (N,T, V, P, S), with
finite sets of non-terminals (N ), termi-
nals (T ) and variables (V ), with a start sym-
bol S ∈ N . A rewrite rule p ∈ P of rank
r = ρ(p) ≥ 0 has the form A(α1, . . . , αψ(A)) →
B1(β1,1, . . . , β1,ψ(B1)) . . . Br(βr,1, . . . , βr,ψ(Br)),
where each α, β ∈ (T ∪ V )∗, and ψ(A) is the
number of arguments a non-terminal A has, called
its arity. By definition, the start symbol has arity 1.
Any variable v ∈ V appearing in a given rule
must be used exactly once on each side of the
rule. Terminating rules are written with � as the
right-hand side and thus have rank 0.

A range is a pair of integers (i, j) denoting the
substring wi+1 . . . wj of a string w = w1 . . . wn.
A non-terminal becomes instantiated when its vari-
ables are bound to ranges through substitution. Vari-
ables within an argument imply concatenation and
therefore have to bind to adjacent ranges.

An instantiated non-terminal A′ is said to de-
rive � if the consecutive application of a sequence
of instantiated rules rewrite it as �. A string w is
within the language defined by a particular SRCG
iff the start symbol S, instantiated with the exhaus-
tive range (0, wn), derives �.

An important distinction with regard to CFGs is
that, due to the instantiation mechanism, the order-
ing of non-terminals on the right-hand side of an
SRCG rule is irrelevant, i.e. A(ab) → B(a)C(b)
and A(ab) → C(b)B(a) are the same rule.2 Con-
sequently, the isomorphisms of any given SRCG
derivation tree all encode the same string, which is
uniquely defined through the instantiation process.

3.2 Application to morphological analysis

A fragment of the idealised grammar schema from
the previous section (§2) can be rephrased as an
SRCG by writing the rules in the newly introduced

2Certain ordering restrictions over the variables within an
argument need to hold for an SRCG to indeed be a simple RCG
(Boullier, 2000).

Word(wakitabi)

Suf(i)

i

Stm(kitab)

Template(i,a)Root(k,t,b)

Pre(wa)

aw k i t a b

Figure 1: Example derivation for wakitabi (and my
book) using the SRCG fragment from §3.2. CFGs
cannot capture such crossing branches.

notation, and supplying a definition of the intercal
function as simply another rule of the grammar, with
instantiation for w = kitab shown below:

Word(abc)→ Pre(a) Stem(b) Suf(c)
Stem(abcde)→ Root(a, c, e) Template(b, d),

Stem(〈0..1〉, 〈1..2〉, 〈2..3〉, 〈3..4〉, 〈4..5〉)
→ Root(〈0..1〉, 〈2..3〉, 〈4..5〉)

Template(〈1..2〉, 〈3..4〉)

Given an appropriate set of grammar rules (as we
present in §5), we can parse an input string to ob-
tain a tree as shown in Figure 1. The overlapping
branches of the tree demonstrate that this grammar
captures something a CFG could not. From the parse
tree one can read off the word’s root morpheme and
the template used.

Although SRCGs specify mildly context-sensitive
grammars, each step in a derivation is context-free –
a node’s expansion does not depend on other parts
of the tree. This property implies that a recogni-
tion/parsing algorithm can have a worst-case time
complexity that is polynomial in the input length n,
O(n(ρ+1)ψ) for arity ψ and rank ρ, which reduces
to O(n3ψ) for a binarised grammar. To capture the
maximal case of a root with k − 1 characters and
k discontiguous templatic characters forming a stem
would require a grammar that has arity ψ = k. For
Arabic, which has up to quadriliteral roots (k = 5),
the time complexity would be O(n15).3 This is a
daunting proposition for parsing, but we are careful

3The trade-off between arity and rank with respect to pars-
ing complexity has been characterised (Gildea, 2010), and the
appropriate refactoring may bring down the complexity for our
grammars too.

347



to set up our application of SRCGs in such a way
that this is not too big an obstacle:

Firstly, our grammars are defined over the char-
acters that make up a word, and not over words that
make up a sentence. As such, the input length n
would tend to be shorter than when parsing full sen-
tences from a corpus.

Secondly, we do type-based morphological analy-
sis, a view supported by evidence from Goldwater et
al. (2006), so each unique word in a dataset is only
ever parsed once with a given grammar. The set of
word types attested in the data sources of interest
here is fairly limited, typically in the tens of thou-
sands. For these reasons, our parsing and inference
tasks turn out to be tractable despite the high time
complexity.

4 Learning

4.1 Probabilistic SRCG

The probabilistic extension of SRCGs is similar to
the probabilistic extension of CFGs, and has been
used in other guises (Kato et al., 2006; Maier, 2010).
Each rule r ∈ P has an associated probability θr
such that

∑
r∈PA θr = 1. A random string in

the language of the grammar can then be obtained
through a generative procedure that begins with the
start symbol S and iteratively expands it until deriv-
ing �: At each step for some current symbol A, a
rewrite rule r is sampled randomly from PA in ac-
cordance with the distribution over rules and used
to expand A. This procedure terminates when no
further expansions are possible. Of course, expan-
sions need to respect the range concatenating and or-
dering constraints imposed by the variables in rules.
The expansions imply a chain of variable bindings
going down the tree, and instantiation happens only
when rewriting into �s but then propagates back up
the tree.

The probability P (w, t) of the resulting tree t and
terminal string w is the product

∏
r θr over the se-

quence of rewrite rules used. This generative proce-
dure is a conceptual device; in practice, one would
care about parsing some input string under this prob-
abilistic grammar.

4.2 PYSRCAG

A central property of the generative procedure un-
derlying probabilistic SRCGs is the fact that each

expansion happens independently, both of the other
expansions in the tree under construction and of any
other trees. To some extent, this flies in the face of
the reality of estimating a grammar from text, where
one would expect certain sub-trees to be used repeat-
edly across different input strings.

Adaptor grammars weaken this independence as-
sumption by allowing whole subtrees to be reused
during expansion. Informally, they act as a cache of
tree fragments whose tendency to be reused during
expansion is governed by the choice of adaptor func-
tion. Following earlier applications of adaptor gram-
mars (Johnson et al., 2007; Huang et al., 2011), we
employ the Pitman-Yor process (Pitman, 1995; Pit-
man and Yor, 1997) as adaptor function.

A Pitman-Yor Simple Range Concatenat-
ing Adaptor Grammar (PYSRCAG) is a tuple
G = (GS ,M,a, b,α), where GS is a probabilistic
SRCG as defined before and M ⊆ N is a set
of adapted non-terminals. The vectors a and b,
indexed by the elements of M , are the discount
and concentration parameters for each adapted non-
terminal, with a ∈ [0, 1], b ≥ 0. α are parameters to
Dirichlet priors on the rule probabilities θ.

PYSRCAG defines a generative process over a set
of trees T . Unadapted non-terminals A′ ∈ N \M
are expanded as before (§4.1). For each adapted
non-terminal A ∈ M , a cache CA is maintained
for storing the terminating tree fragments expanded
from A earlier in the process, and we denote the
fragment corresponding to the i-th expansion of A
as zi. In other words, the sequence of indices zi
is the assignment of a sequence of expansions of
A to particular tree fragments. Given a cache CA
that has n previously generated trees comprising
m unique trees each used n1, . . . , nm times (where
n =

∑
k nk), the tree fragment for the next expan-

sion of A, zn+1, is sampled conditional on the pre-
vious assignments z< according to

zn+1|z< ∼

{
nk−a
n+b if zn+1 = k ∈ [1,m]
ma+b
n+b if zn+1 = m+ 1,

where a and b are those elements of a and b cor-
responding to A. The first case denotes the situa-
tion where a previously cached tree is reused for this
n + 1-th expansion of A; to be clear, this expands
A with a fully terminating tree fragment, meaning
that none of the nodes descending from A in the

348



tree being generated are subject to further expan-
sion. The second case by-passes the cache and ex-
pandsA according to the rules PA and rule probabil-
ities θA of the underlying SRCG GS . Other caches
CB(B ∈ M) may come into play during those
expansions of the descendants of A; thus a PYS-
RCAG can define a hierarchical stochastic process.
Both cases eventually result in a terminating tree-
fragment for A, which is then added to the cache,
updating the counts n, nzn+1 and potentially m.

The adaptation does not affect the string language
of GS , but it maps the distribution over trees to one
that is distributed according to the PYP.

The invariance of SRCGs trees under isomor-
phism would make the probabilistic model deficient,
but we side-step this issue by requiring that grammar
rules are specified in a canonical way that ensures
a one-to-one correspondence between the order of
nodes in a tree and of terminals in the yield.

4.3 Inference under PYSRCAG

The inference procedure under our model is very
similar to that of CFG PY-adaptor grammars, so we
restate the central aspects here but refer the reader
to the original article by Johnson et al. (2007) for
further details. First, one may integrate out the
adaptors to obtain a single distribution over the set
of trees generated from a particular non-terminal.
Thus, the joint probability of a particular sequence z
for the adapted non-terminal A with cached counts
(n1, . . . , nm) is

PY (z|a, b) =
∏m
k=1 (a(k − 1) + b)

∏nk−1
j=1 (j − a)∏n−1

i=0 (i+ b)
.

(6)
Taking all the adapted non-terminals into account,
the joint probability of a set of full trees T under the
grammar G is

P (T |a, b,α) =
∏
A∈M

B(αA + fA)

B(αA)
PY (z(T )|a, b),

(7)
where fA is a vector of the usage counts of rules
r ∈ PA across T , and B is the Euler beta function.

The posterior distribution over a set of strings
w is obtained by marginalising (7) over all trees
that have w as their yields. This is intractable to
compute directly, so instead we use MCMC tech-
niques to obtain samples from that posterior using a

component-wise Metropolis-Hastings sampler. The
sampler works by visiting each string w in turn and
drawing a new tree for it under a proposal grammar
GQ and randomly accepting that as the new analysis
for w according to the Metropolis-Hastings accept-
reject probability. As proposal grammar, we use the
analogous approximation of our G as Johnson et al.
used for PCFGs, namely by taking a static snapshot
GQ of the adaptor grammar where additional rules
rewrite adapted non-terminals as the terminal strings
of their cached trees. Drawing a sample from the
proposal distribution is then a matter of drawing a
random tree from the parse chart of w under GQ.

Lastly, the adaptor hyperparameters a and b
are modelled by placing flat Beta(1, 1) and vague
Gamma(10, 0.1) priors on them, respectively, and
inferring their values using slice sampling (Johnson
and Goldwater, 2009).

5 Modelling root-templatic morphology

We start with a CFG-based adaptor grammar4 that
models words as a stem and any number of prefixes
and suffixes:

Word→ Pre∗ Stem Suf∗ (8)
Pre | Stem | Suf→ Char+ (9)

This fragment can be seen as building on the stem-
and-affix adaptor grammar presented in (Johnson et
al., 2007) for morphological analysis of English, of
which a later version also covers multiple affixes
(Sirts and Goldwater, 2013). In the particular case of
Arabic, multiple affixes are required to handle the at-
tachment of particles and proclitics onto base words.

To extend this to complex stems consisting of a
root with three radicals we have rules like the fol-
lowing:

Stem(abcdefg)→ R3(b, d, e) T4(a, c, e, g) (10)
Stem(abcdef)→ R3(a, c, e) T3(b, d, f) (11)

Stem(abcde)→ R3(a, c, e) T2(b, d) (12)
Stem(abcd)→ R3(a, c, d) T1(b) (13)

Stem(abc)→ R3(a, b, c) (14)
4Adapted non-terminals are indicated by underlining and

we use the following abbreviations: X → Y+ means one
or more instances of Y and encodes the rules X → Ys and
Ys → Ys Y | Y. Similarly, X → Y∗ Z allows zero or more
instances of Y and encodes the rules X → Z and X → Y+ Z.
Further relabelling is added as necessary to avoid cycles among
adapted non-terminals.

349



The actual rules include certain permutations of
these, e.g. rule (13) has a variant R3(a, b, d)T1(c).
In unvocalised text, the standard written form of
Modern Standard Arabic (MSA), it may happen that
the stem and the root of a word form are one and the
same. So while rule (14) may look trivial, it ensures
that in such cases the radicals are still captured as de-
scendants of the non-terminal category R3, thereby
making their appearance in the cache.

A discontiguous non-terminal An is rewritten
through recursion on its arity down to 1, i.e.
An(v1, . . . , vn)→ Al(v1, . . . , vn−1) Char(vn) with
base case A1(v) → Char(v), where Char rewrites
all individual terminals as �, vi are variables and
l = n−1.5 Note that although we provide the model
with two sets of discontiguous non-terminals R and
T, we do not specify their mapping onto the actual
terminal strings; no subdivision of the alphabet into
vowels and consonants is hard-wired.

6 Experiments

We evaluate our model on standard Arabic, Quranic
Arabic and Hebrew in terms of segmentation quality
and lexicon induction ability. These languages share
various properties, including morphology and lexi-
cal cognates, but are sufficiently different so as to
require manual intervention when transferring rule-
based morphological analysers across languages. A
key question in this evaluation is therefore whether
an appropriate instantiation of our model success-
fully generalises across related languages.

6.1 Data sets

Our models are unsupervised and therefore learn
from raw text, but their evaluation requires anno-
tated data as a gold-standard and these were derived6

as follows:

Arabic (MSA) We created the dataset BW by syn-
thesising 50k morphotactically correct word types
from the morpheme lexicons and consistency rules
supplied with the Buckwalter Arabic Morphological

5Including the arity as part of the non-terminal symbol
names forms part of our convention here to ensure that the
grammar contains no cycles, a situation which would compli-
cate inference under PYSRCAG.

6Our data preprocessing scripts are obtainable from
http://github.com/bothameister/pysrcag-data.

Types Stems Roots m/w c/w

BW 48428 24197 4717 2.3 6.4
BW

′
48428 30891 4707 2.3 10.7

QU
′

18808 12021 1270 1.9 9.9
HEB 5231 3164 492 2.1 6.7

Table 1: Corpus statistics, including average number
of morphemes (m/w) and characters (c/w) per word,
and total surface-realised roots of length 3 or 4.

Analyser (BAMA).7 This allowed control over the
word shapes, which is important to focus the evalu-
ation, while yielding reliable segmentation and root
annotations. BW has no vocalisation; we denote the
corresponding vocalised dataset as BW

′
.

Quranic Arabic We extracted the roughly 18k
word types from a morphologically analysed version
of the Quran (Dukes and Habash, 2010). As an ad-
ditional challenge, we left all given diacritics intact
for this dataset, QU

′
.

Hebrew We leveraged the Hebrew CHILDES
database as an annotated resource (Albert et al.,
2013) and were able to extract 5k word types that
feature at least one affix to use as dataset HEB. The
corrected versions of words marked as non-standard
child language were used, diacritics were dropped,
and we conflated stressed and unstressed vowels to
overcome inconsistencies in the source data.

6.2 Models

We consider two classes of models. The first
is the strictly context-free adaptor grammar for
morphemes as sequences of characters using
rules (8)-(9), which we denote as Concat and
MConcat, where the latter allows multiple pre-
fixes/suffixes in a word. These serve as baselines for
the second class in which non-concatenative rules
are added. MTpl and Tpl denote the canonical ver-

7We used version 2.0, LDC2004L02, and sampled word
types having a single stem and at most one prefix, suffix or both,
according to the following random procedure: Sample a shape
(stem: 0.1, pre+stem: 0.25 stem+suf: 0.25, pre+stem+suf: 0.4).
Sample uniformly at random (with replacement) a stem from
the BAMA stem lexicon, and affix(es) from the ones consis-
tent with the chosen stem. The BAMA lexicons contain affixes
and their legitimate concatenations, so some of the generated
words would permit a linguistic segmentation into multiple pre-
fixes/suffixes. Nonetheless, we take as gold-standard segmenta-
tion precisely the items used by our procedure.

350



sions with stems as shown in the set of rules above,
and we experiment with a variant Tpl3Ch that al-
lows the non-terminal T1 to be rewritten as up to
three Char symbols, since the data indicate there are
cases where multiple characters intervene between
the radicals of a root.

These models exclude rule (10), which we include
only in the variant Tpl+T4. Lastly, TplR4 is the ex-
tension of Tpl+T4 to include a stem-forming rule
that uses R4.

As external baseline model we used Morfessor
(Creutz and Lagus, 2007), which performs decently
in morphological segmentation of a variety of lan-
guages, but only handles concatenation.

6.3 Method

The MCMC samplers converged within a few hun-
dred iterations and we collected 100 posterior sam-
ples after 900 iterations of burn-in. Collected sam-
ples, each of which is a set of parse trees of the input
word types, are used in two ways:

First, by averaging over the samples we can es-
timate the joint probability of a word type w and a
parse tree t under the adaptor grammar, conditional
on the data and the model’s hyperparameters. We
take the most probable parse of each word type and
evaluate the implied segmentation against the gold
standard segmentation. Likewise, we evaluate the
implied lexicon of stems, affixes and roots against
the corresponding reference sets. It should be em-
phasised that using this maximally probable analy-
sis is aimed at simplifying the evaluation set-up; one
could also extract multiple analyses of a word since
the model defines a distribution over them.

The second method abstracts away from individ-
ual word-types and instead averages over the union
of all samples to obtain an estimate of the probabil-
ity of a string s being generated by a certain category
(non-terminal) of the grammar. In this way we can
obtain a lexicon of the morphemes in each category,
ranked by their probability under the model.

6.4 Inducing Morpheme Lexicons

The quality of each induced lexicon is measured
with standard set-based precision and recall with re-
spect to the corresponding gold lexicon. The results
are summarised by balanced F-scores in Table 2.

The main result is that all our models capable of

forming complex stems obtain a marked improve-
ment in F-scores over the baseline concatenative
adaptor grammar, and the margin of improvement
grows along with the expressivity of the complex-
stem models tested. This applies across prefix, stem
and suffix categories and across our datasets, with
the exception of QU

′
, which we elaborate on in §6.5.

Stem lexicons of Arabic were learnt with rel-
atively constant precision (∼70%), but modelling
complex stems broadened the coverage by about
3000 stems over the concatenative model (against a
reference set of 24k stems). On vocalised Arabic,
the improvements for stems are along both dimen-
sions. In contrast, affix lexicons for both BW and
BW

′
are noisy and the models all generate greedily

to obtain near perfect recall but low precision.
On our Hebrew data, which comprises only 5k

words, the gains in lexicon quality from modelling
complex stems tend to be larger than on Arabic. This
is consistent with our intuition that an appropriate,
richer Bayesian prior helps overcome data sparsity.

Extracting a lexicon of roots is rendered challeng-
ing by the unsupervised nature of the model as the
labelling of grammar symbols is ultimately arbitrary.
Our simple approach was to regard a character tuple
parsed under category R3 as a root. This had mixed
success, as demonstrated by the outlier scores in Ta-
ble 2. In the one case where it was obvious that T3
had been been co-opted for the role, we report the
F-score obtained on the union of R3 and T3 strings.

Soft decisions The preceding set-based evaluation
imposes hard decisions about category membership.
But adaptor grammars are probabilistic by definition
and should thus also be evaluated in terms of prob-
abilistic ability. One method is to turn the model
predictions into a binary classifier of strings us-
ing Receiver-Operator-Characteristic (ROC) theory.
We plot the true positive rate versus the false pos-
itive rate for each prediction lexicon Lτ containing
strings that have probability greater than τ under the
model (for a grammar category of interest). A per-
fect classifier would rank all true positives (e.g. stem
strings) above false positives (e.g. non-stem strings),
corresponding to a curve in the upper left corner of
the ROC plot. A random guesser would trace a di-
agonal line. The area under the curves (AUC) is
the probability that the classifier would discriminate
correctly.

351



Vocalised Arabic (BW′) Unvocalised Arabic (BW) Hebrew (HEB)
Pre Stem Suf R3 Pre Stem Suf R3 Pre Stem Suf R3

Concat 15.0 20.2 25.4 - 32.8 44.1 40.3 - 18.7 20.9 29.2 -
Tpl 24.7 39.4 35.2 †42.4 45.9 54.7 47.9 62.7 35.1 59.6 52.9 34.8
Tpl3Ch 28.4 36.0 36.5 5.2 50.3 55.1 48.5 62.4 38.6 61.5 56.6 7.1
Tpl+T4 29.0 44.8 41.0 3.9 46.2 54.2 47.7 62.3 32.5 59.6 53.0 36.4
TplR4 37.8 60.3 47.0 5.2 53.0 57.7 51.9 62.4 38.0 62.4 55.2 34.7

Table 2: Morpheme lexicon induction quality. F1-scores for lexicons induced from the most probable parse
of each different dataset under each models. †42.4 was obtained by taking the union of R3 and T3 items to
match the way the model used them (see §6.4).

BW
′

BW QU
′

HEB

Morfessor 55.57 40.04 44.34 24.20
Concat 47.36 64.22 19.64 60.05

Tpl 60.42 71.91 22.53 77.26
Tpl3Ch 60.52 72.20 25.72 77.41
Tpl+T4 64.49 71.59 24.81 77.14
TplR4 74.54 73.66 - 78.14

Table 3: Segmentation quality in SBF1. The QU
′

results are for the corresponding M* models .

Our models with complex stem formation im-
prove over the baseline on the AUC metric too. We
include the ROC plots for Hebrew stem and root in-
duction in Figure 2, along with the roots the model
was most confident about (Table 4).

6.5 Morphological Analysis per Word Type

In this section we turn to the analyses our models
assign to each word type. Two aspects of interest are
the segmentation into sequential morphemes and the
identification of the root.

Our intercalating adaptor grammars consistently
obtain large gains in segmentation accuracy over the
baseline concatenative model, across all our datasets
(Table 3). We measure segmentation quality as seg-
ment border F1-score (SBF) (Sirts and Goldwater,
2013), which is the F-score over word-internal seg-
mentation points of the predicted analysis with re-
spect to the gold segmentation.

Of the two MSA datasets, the vocalised version
BW

′
presents a more difficult segmentation task as

its words are on average longer and feature 31k
unique contiguous morphemes, compared to the 24k
in BW for the same number of words. It should thus
benefit more from additional model expressivity, as

is reflected in the increase of 10 SBF when adding
the TplR4 rule to the other triliteral ones.

The best triliteral root identification accuracy (on
a per-word basis) was found for HEB (74%) and BW
(67%).8,9 Refer to Figure 3 for example analyses.

An interesting aspect of these results is that tem-
platic rules may aid segmentation quality without
necessarily giving perfect root identification. Mod-
elling stem substructure allows any regularities that
give rise to a higher data likelihood to be picked up.

The low performance on the Quran demands fur-
ther explanation. All our adaptor grammars severely
oversegmented this data, although the mistakes were
not uniformly distributed. Most of the performance
loss is on the 79% of words that have 1-2 mor-
phemes. On the remaining words (having 3-5 mor-
phemes), our models recover and approach the Mor-
fessor baseline (MConcat: 32.7 , MTpl3Ch: 38.6).

Preliminary experiments on BW had indicated
that adaptation of (single) affix categories is crucial
for good performance. Our multi-affixing models
used on QU

′
lacked a further level of adaptation for

composite affixes, which we suspect as a contribut-
ing factor to the lower performance on that dataset.
This remains to be confirmed in future experiments,
but would be consistent with other observations on
the role of hierarchical adaptation in adaptor gram-
mars (Sirts and Goldwater, 2013). The trend that
intercalated rules improve segmentation (compared
to the concatenative grammar) remains consistent

8When excluding cases where root equals stem, root identi-
fication on BW is 55%. Those cases are still not trivial, since
words without roots also exist.

9By way of comparison, Rodrigues and Ćavar (2007)
presented an unsupervised statistics-based root identification
method that obtained precision ranging between 50-75%, the
higher requiring vocalised words.

352



0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

False Positive Rate

0.0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1.0

T
ru

e
 P

o
si

ti
v
e
 R

a
te

TplR4 (0.84)
Tpl+T4 (0.83)
Concat (0.63)
random (0.5)

(a) Stems

0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

False Positive Rate

0.0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1.0

T
ru

e
 P

o
si

ti
v
e
 R

a
te

TplR4 (0.77)
Tpl+T4 (0.77)
random (0.5)

(b) Triliteral roots

Figure 2: ROC curves for predicting the stem and root lexicons for the HEB dataset. The area under each
curve (AUC), as computed with the trapezium rule, is given in parentheses.

across datasets, despite the lower absolute perfor-
mance on QU

′
.

The performance of the Morfessor baseline was
quite mixed. Contrary to our expectations, it per-
forms best on the “harder” BW

′
, worst on the ar-

guably simpler HEB and struggled less than the
adaptor grammars on QU

′
.

One factor here is that it learns according to
a grammar with multiple consecutive affixes and
stems, whereas all our experiments (except on QU

′
)

presupposed single affixes. This biases the evalua-
tion slightly in our favour, but works in Morfessor’s
favour on the QU

′
data which is annotated with mul-

tiple affixes.

7 Related work

The distinctive feature of our morphological model
is that it jointly addresses root identification and
morpheme segmentation, and our results demon-
strate the mutual benefit of this.

In contrast, earlier unsupervised approaches tend
to focus on these tasks in isolation.

In unsupervised Arabic segmentation, the para-
metric Bayesian model of (Lee et al., 2011) achieves
F1-scores in the high eighties by incorporating sen-
tential context and inferred syntactic categories,
both of which our model forgoes, although theirs has
no account of discontiguous root morphemes.

Root Example instances

1. spr X G šap̌ař.ti te.šap̌ř ye.šap̌ř.u
B sipur.im hixštap̌xař t

2. lbs X G ľab̌aŠ.t li.ľb̌oŠ ti.ľb̌eŠ.i
B le hax ľb̌iŠ ti tx ľab̌Š.i

3. ptx X G p̌aťax̌.ti ti.p̌ťex̌.i
B li.p̌ťoax̌ nixp̌ťax̌.at

5. !al × B ya.!al.u m̌ax!̌aľ.a !̌ačľxan it

Table 4: Top Hebrew roots hypothesised by Tpl+T4.
Numbers indicate position when ranked by model
probability. (G)ood and (B)ad instances from
the corpus are given with morpheme boundaries
marked: true positive (.), false negative ( ) and false
positive (x). Hypothesised root characters are bold-
faced, while accent (ˇ) marks gold root characters.

Previous approaches to Arabic root identifica-
tion that sought to use little supervision typically
constrain the search space of candidate characters
within a word, leveraging pre-existing dictionar-
ies (Darwish, 2002; Boudlal et al., 2009) or rule
constraints (Elghamry, 2005; Rodrigues and Ćavar,
2007; Daya et al., 2008).

In contrast to these approaches, our model re-
quires no dictionary, and while our grammar rules
effect some constraints on what could be a root, they
are specified in a convenient and flexible manner that

353



Word

Suf

k m

Stem

s t A r

Pre

w l >

wl >stAr km X

Pre(w l) ... Stem ... Suf(k m)

X2 s t · r

R3 s · t · r

R1

r

R2 s · t

R1

t

R1

s

T2 > · A

T1

A

T1

>

(a) Concat & Tpl+T4, “wl>stArkm” (BW)

Word

Stem

n o t i l l A

Pre

l i d a

li danotillA X

Pre(l i) ... Stem(danotill) ... Suf(A)

T4 o · a · i · l

T1

l

T3 o · a · i

T1

i

T2 o · a

T1

a

T1

o

R4 d · n · t · l

R1

l

R3 d · n · t

R1

t

R2 d · n

R1

n

R1

d

(b) Concat & TplR4, “lidanotillA” (BW
′
)

Figure 3: Parse trees produced for words in the two standard Arabic datasets that were incorrectly segmented
by the baseline grammar. The templatic grammars correctly identified the triliteral and quadriliteral roots,
also fixing the segmentation of (a). In (b), the templatic grammar improved over the baseline by finding
the correct prefix but falsely posited a suffix. Unimportant subtrees are elided for space, while the yields of
discontiguous constituents are indicated next to their symbols, with dots marking gaps. Crossing branches
are not drawn but should be inferrable. Root characters are bold-faced in the reference analysis X. The non-
terminal X2 in (a) is part of a number of implementation-specific helper rules that ensure the appropriate
handling of partly contiguous roots.

makes experimentation with other phenomena easy.
Recent work by Fullwood and O’Donnell (2013)

goes some way toward jointly dealing with non-
concatenative and concatenative morphology in the
unsupervised setting, but their focus is limited to in-
flected stems and does not handle multiple consecu-
tive affixes. They analyse the Arabic verb stem (e.g.
kataba “he wrote”) into a templatic bit-string denot-
ing root and non-root characters (e.g. r-r-r-) along
with a root morpheme (e.g. ktb) and a so-called
residue morpheme (e.g. aaa). Their nonparamet-
ric Bayesian model induces lexicons of these en-
tities and achieves very high performance on tem-
plates. The explicit formulation of templates allevi-
ates the labelling ambiguity that hampered our eval-
uation (§6.4), but we believe their method of anal-
ysis can be simulated in our framework using the
appropriate SRCG-rules.

Learning root-templatic morphology is loosely re-
lated to morphological paradigm induction (Clark,
2001; Dreyer and Eisner, 2011; Durrett and DeN-
ero, 2013). Our models do not represent templatic
paradigms explicitly, but it is interesting to note that
preliminary experiments with German indicate that
our adaptor grammars pick up on the past participle
forming circumfix in ab+ge+spiel+t (played back).

8 Conclusion and Outlook

We presented a new approach to modelling non-
concatenative phenomena in morphology using sim-

ple range concatenating grammars and extended
adaptor grammars to this formalism. Our experi-
ments show that this richer model improves morpho-
logical segmentation and morpheme lexicon induc-
tion on different languages in the Semitic family.

Various avenues for future work present them-
selves. Firstly, the lightly-supervised, meta-
grammar approach to adaptor grammars (Sirts and
Goldwater, 2013) can be extended to this more
powerful formalism to lessen the burden of defin-
ing the “right” grammar rules by hand, and possi-
bly boost performance. Secondly, the discontigu-
ous constituents learnt with our framework can be
used as features in other downstream applications.
Especially in low-resource languages, the ability to
model non-concatenative phenomena (e.g. circum-
fixing, ablaut, etc.) can play an important role in re-
ducing data sparsity for tasks like word alignment
and language modelling. Finally, the PYSRCAG
presents another way of learning SRCGs in general,
which can thus be employed in other applications of
SRCGs, including syntactic parsing and translation.

Acknowledgements

We thank the anonymous reviewers for their valu-
able comments. Our PYSRCAG implementation
leveraged the adaptor grammar code released by
Mark Johnson, whom we thank, along with the in-
dividuals who contributed to the public data sources
that enabled the empirical elements of this paper.

354



References

Aviad Albert, Brian MacWhinney, Bracha Nir, and Shuly
Wintner. 2013. The Hebrew CHILDES corpus: tran-
scription and morphological analysis. Language Re-
sources and Evaluation, pages 1–33.

Mohamed Altantawy, Nizar Habash, Owen Rambow, and
Ibrahim Saleh. 2010. Morphological Analysis and
Generation of Arabic Nouns: A Morphemic Func-
tional Approach. In Proceedings of LREC, pages 851–
858.

Kenneth R Beesley and Lauri Karttunen. 2003. Fi-
nite state morphology, volume 18. CSLI publications
Stanford.

Abderrahim Boudlal, Rachid Belahbib, Abdelhak
Lakhouaja, Azzeddine Mazroui, Abdelouafi Meziane,
and Mohamed Bebah. 2009. A Markovian approach
for Arabic Root Extraction. The International Arab
Journal of Information Technology, 8(1):91–98.

Pierre Boullier. 2000. A cubic time extension of context-
free grammars. Grammars, 3(2-3):111–131.

Tim Buckwalter. 2002. Arabic Morphological Ana-
lyzer. Technical report, Linguistic Data Consortium,
Philedelphia.

Alexander Clark. 2001. Learning Morphology with Pair
Hidden Markov Models. In Proceedings of the ACL
Student Workshop, pages 55–60.

Yael Cohen-Sygal and Shuly Wintner. 2006. Finite-
state registered automata for non-concatenative mor-
phology. Computational Linguistics, 32(1):49–82.

Mathias Creutz and Krista Lagus. 2007. Unsupervised
models for morpheme segmentation and morphology
learning. ACM Transactions on Speech and Language
Processing, 4(1):1–34.

Kareem Darwish. 2002. Building a shallow Arabic
morphological analyzer in one day. In Proceedings
of the ACL Workshop on Computational Approaches
to Semitic Languages, pages 47–54. Association for
Computational Linguistics.

Ezra Daya, Dan Roth, and Shuly Wintner. 2008.
Identifying Semitic Roots: Machine Learning with
Linguistic Constraints. Computational Linguistics,
34(3):429–448.

Markus Dreyer and Jason Eisner. 2011. Discovering
Morphological Paradigms from Plain Text Using a
Dirichlet Process Mixture Model. In Proceedings of
EMNLP, pages 616–627, Edinburgh, Scotland.

Kais Dukes and Nizar Habash. 2010. Morphological An-
notation of Quranic Arabic. In Proceedings of LREC.

Greg Durrett and John DeNero. 2013. Supervised Learn-
ing of Complete Morphological Paradigms. In Pro-
ceedings of NAACL-HLT, pages 1185–1195, Atlanta,
Georgia, June. Association for Computational Lin-
guistics.

Khaled Elghamry. 2005. A Constraint-based Algorithm
for the Identification of Arabic Roots. In Proceed-
ings of the Midwest Computational Linguistics Collo-
quium. Indiana University. Bloomington, IN.

Raphael Finkel and Gregory Stump. 2002. Generating
Hebrew verb morphology by default inheritance hier-
archies. In Proceedings of the ACL Workshop on Com-
putational Approaches to Semitic Languages. Associ-
ation for Computational Linguistics.

Michelle A. Fullwood and Timothy J. O’Donnell. 2013.
Learning non-concatenative morphology. In Proceed-
ings of the Workshop on Cognitive Modeling and Com-
putational Linguistics, pages 21–27, Sofia, Bulgaria.
Association for Computational Linguistics.

Michael Gasser. 2009. Semitic morphological analysis
and generation using finite state transducers with fea-
ture structures. In Proceedings of EACL, pages 309–
317. Association for Computational Linguistics.

Daniel Gildea. 2010. Optimal Parsing Strategies for Lin-
ear Context-Free Rewriting Systems. In Proceedings
of NAACL, pages 769–776. Association for Computa-
tional Linguistics.

Sharon Goldwater, Thomas L. Griffiths, and Mark John-
son. 2006. Interpolating Between Types and Tokens
by Estimating Power-Law Generators. In Advances in
Neural Information Processing Systems, Volume 18.

Harald Hammarström and Lars Borin. 2011. Unsuper-
vised Learning of Morphology. Computational Lin-
guistics, 37(2):309–350.

Yun Huang, Min Zhang, and Chew Lim Tan. 2011.
Nonparametric Bayesian Machine Transliteration with
Synchronous Adaptor Grammars. In Proceedings of
ACL (Short papers), pages 534–539.

Mark Johnson and Sharon Goldwater. 2009. Improving
nonparameteric Bayesian inference: Experiments on
unsupervised word segmentation with adaptor gram-
mars. In Proceedings of NAACL-HLT, pages 317–325.
Association for Computational Linguistics.

Mark Johnson, Thomas L. Griffiths, and Sharon Gold-
water. 2007. Adaptor Grammars: A Framework for
Specifying Compositional Nonparametric Bayesian
Models. In Advances in Neural Information Process-
ing Systems, volume 19, page 641. MIT.

Mark Johnson. 2008. Unsupervised word segmentation
for Sesotho using Adaptor Grammars. In Proceedings
of ACL Special Interest Group on Computational Mor-
phology and Phonology (SigMorPhon), pages 20–27.
Association for Computational Linguistics.

Aravind K. Joshi. 1985. Tree adjoining grammars: How
much context-sensitivity is required to provide reason-
able structural descriptions? In D.R. Dowty, L. Kart-
tunen, and A.M. Zwicky, editors, Natural Language
Parsing, chapter 6, pages 206–250. Cambridge Uni-
versity Press.

355



Miriam Kaeshammer. 2013. Synchronous Linear
Context-Free Rewriting Systems for Machine Trans-
lation. In Proceedings of the Workshop on Syntax, Se-
mantics and Structure in Statistical Translation, pages
68–77, Atlanta, Georgia. Association for Computa-
tional Linguistics.

Yuki Kato, Hiroyuki Seki, and Tadao Kasami. 2006.
Stochastic Multiple Context-Free Grammar for RNA
Pseudoknot Modeling. In Proceedings of the Inter-
national Workshop on Tree Adjoining Grammar and
Related Formalisms, pages 57–64.

George Anton Kiraz. 2000. Multitiered Nonlinear Mor-
phology Using Multitape Finite Automata: A Case
Study on Syriac and Arabic. Computational Linguis-
tics, 26(1):77–105, March.

Kimmo Koskenniemi. 1984. A general computational
model for word-form recognition and production. In
Proceedings of the 10th international conference on
Computational Linguistics, pages 178–181. Associa-
tion for Computational Linguistics.

Mikko Kurimo, Sami Virpioja, Ville T. Turunen,
Graeme W. Blackwood, and William Byrne. 2010.
Overview and Results of Morpho Challenge 2009. In
Multilingual Information Access Evaluation I. Text Re-
trieval Experiments, volume 6241 of Lecture Notes in
Computer Science, pages 578–597. Springer Berlin /
Heidelberg.

Yoong Keok Lee, Aria Haghighi, and Regina Barzilay.
2011. Modeling syntactic context improves morpho-
logical segmentation. In Proceedings of CoNLL.

Wolfgang Maier. 2010. Direct Parsing of Discon-
tinuous Constituents in German. In Proceedings of
the NAACL-HLT Workshop on Statistical Parsing of
Morphologically-Rich Languages, pages 58–66. Asso-
ciation for Computational Linguistics.

Jim Pitman and Marc Yor. 1997. The Two-Parameter
Poisson-Dirichlet Distribution Derived from a Stable
Subordinator. The Annals of Probability, 25(2):855–
900.

Jim Pitman. 1995. Exchangeable and partially exchange-
able random partitions. Probability Theory and Re-
lated Fields, 102:145–158.

Jean-François Prunet. 2006. External Evidence and the
Semitic Root. Morphology, 16(1):41–67.

Paul Rodrigues and Damir Ćavar. 2007. Learning Arabic
Morphology Using Statistical Constraint-Satisfaction
Models. In Elabbas Benmamoun, editor, Perspectives
on Arabic Linguistics: Proceedings of the 19th Ara-
bic Linguistics Symposium, pages 63–75, Urbana, IL,
USA. John Benjamins Publishing Company.

Nathan Schneider. 2010. Computational Cognitive
Morphosemantics: Modeling Morphological Compo-
sitionality in Hebrew Verbs with Embodied Construc-

tion Grammar. In Proceedings of the Annual Meeting
of the Berkeley Linguistics Society, Berkeley, CA.

Hiroyuki Seki, Takashi Matsumura, Mamoru Fujii, and
Tadao Kasami. 1991. On multiple context-free gram-
mars. Theoretical Computer Science, 88(2):191–229.

Kairit Sirts and Sharon Goldwater. 2013. Minimally-
Supervised Morphological Segmentation using Adap-
tor Grammars. Transactions of the ACL.

K. Vijay-Shanker, David J. Weir, and Aravind K. Joshi.
1987. Characterizing structural descriptions produced
by various grammatical formalisms. In Proceedings of
ACL, pages 104–111.

356


