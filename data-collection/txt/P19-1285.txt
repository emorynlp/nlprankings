











































Transformer-XL: Attentive Language Models beyond a Fixed-Length Context


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 2978–2988
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

2978

Transformer-XL: Attentive Language Models

Beyond a Fixed-Length Context

Zihang Dai
⇤12

, Zhilin Yang
⇤12

, Yiming Yang
1
, Jaime Carbonell

1
,

Quoc V. Le
2
, Ruslan Salakhutdinov

1

1Carnegie Mellon University, 2Google Brain
{dzihang,zhiliny,yiming,jgc,rsalakhu}@cs.cmu.edu, qvl@google.com

Abstract

Transformers have a potential of learning
longer-term dependency, but are limited by a
fixed-length context in the setting of language
modeling. We propose a novel neural ar-
chitecture Transformer-XL that enables learn-
ing dependency beyond a fixed length with-
out disrupting temporal coherence. It con-
sists of a segment-level recurrence mechanism
and a novel positional encoding scheme. Our
method not only enables capturing longer-term
dependency, but also resolves the context frag-
mentation problem. As a result, Transformer-
XL learns dependency that is 80% longer than
RNNs and 450% longer than vanilla Trans-
formers, achieves better performance on both
short and long sequences, and is up to 1,800+
times faster than vanilla Transformers during
evaluation. Notably, we improve the state-of-
the-art results of bpc/perplexity to 0.99 on en-
wiki8, 1.08 on text8, 18.3 on WikiText-103,
21.8 on One Billion Word, and 54.5 on Penn
Treebank (without finetuning). When trained
only on WikiText-103, Transformer-XL man-
ages to generate reasonably coherent, novel
text articles with thousands of tokens. Our
code, pretrained models, and hyperparameters
are available in both Tensorflow and PyTorch1.

1 Introduction

Language modeling is among the important prob-
lems that require modeling long-term dependency,
with successful applications such as unsupervised
pretraining (Dai and Le, 2015; Peters et al., 2018;
Radford et al., 2018; Devlin et al., 2018). How-
ever, it has been a challenge to equip neural
networks with the capability to model long-term
dependency in sequential data. Recurrent neu-
ral networks (RNNs), in particular Long Short-

⇤Equal contribution. Order determined by swapping the
one in Yang et al. (2017).

1https://github.com/kimiyoung/
transformer-xl

Term Memory (LSTM) networks (Hochreiter and
Schmidhuber, 1997), have been a standard solu-
tion to language modeling and obtained strong
results on multiple benchmarks. Despite the
wide adaption, RNNs are difficult to optimize
due to gradient vanishing and explosion (Hochre-
iter et al., 2001), and the introduction of gat-
ing in LSTMs and the gradient clipping tech-
nique (Graves, 2013) might not be sufficient to
fully address this issue. Empirically, previous
work has found that LSTM language models use
200 context words on average (Khandelwal et al.,
2018), indicating room for further improvement.

On the other hand, the direct connections be-
tween long-distance word pairs baked in atten-
tion mechanisms might ease optimization and en-
able the learning of long-term dependency (Bah-
danau et al., 2014; Vaswani et al., 2017). Re-
cently, Al-Rfou et al. (2018) designed a set of aux-
iliary losses to train deep Transformer networks
for character-level language modeling, which out-
perform LSTMs by a large margin. Despite the
success, the LM training in Al-Rfou et al. (2018)
is performed on separated fixed-length segments
of a few hundred characters, without any informa-
tion flow across segments. As a consequence of
the fixed context length, the model cannot capture
any longer-term dependency beyond the prede-
fined context length. In addition, the fixed-length
segments are created by selecting a consecutive
chunk of symbols without respecting the sentence
or any other semantic boundary. Hence, the model
lacks necessary contextual information needed to
well predict the first few symbols, leading to inef-
ficient optimization and inferior performance. We
refer to this problem as context fragmentation.

To address the aforementioned limitations of
fixed-length contexts, we propose a new architec-
ture called Transformer-XL (meaning extra long).
We introduce the notion of recurrence into our

https://github.com/kimiyoung/transformer-xl
https://github.com/kimiyoung/transformer-xl


2979

deep self-attention network. In particular, instead
of computing the hidden states from scratch for
each new segment, we reuse the hidden states ob-
tained in previous segments. The reused hidden
states serve as memory for the current segment,
which builds up a recurrent connection between
the segments. As a result, modeling very long-
term dependency becomes possible because in-
formation can be propagated through the recur-
rent connections. Meanwhile, passing informa-
tion from the previous segment can also resolve
the problem of context fragmentation. More im-
portantly, we show the necessity of using relative
positional encodings rather than absolute ones, in
order to enable state reuse without causing tem-
poral confusion. Hence, as an additional techni-
cal contribution, we introduce a simple but more
effective relative positional encoding formulation
that generalizes to attention lengths longer than the
one observed during training.

Transformer-XL obtained strong results on five
datasets, varying from word-level to character-
level language modeling. Transformer-XL is also
able to generate relatively coherent long text arti-
cles with thousands of tokens (see Appendix E),
trained on only 100M tokens.

Our main technical contributions include intro-
ducing the notion of recurrence in a purely self-
attentive model and deriving a novel positional en-
coding scheme. These two techniques form a com-
plete set of solutions, as any one of them alone
does not address the issue of fixed-length con-
texts. Transformer-XL is the first self-attention
model that achieves substantially better results
than RNNs on both character-level and word-level
language modeling.

2 Related Work

In the last few years, the field of language mod-
eling has witnessed many significant advances,
including but not limited to devising novel ar-
chitectures to better encode the context (Bengio
et al., 2003; Mikolov et al., 2010; Merity et al.,
2016; Al-Rfou et al., 2018), improving regulariza-
tion and optimization algorithms (Gal and Ghahra-
mani, 2016) , speeding up the Softmax computa-
tion (Grave et al., 2016a) , and enriching the output
distribution family (Yang et al., 2017).

To capture the long-range context in language
modeling, a line of work directly feeds a repre-
sentation of the wider context into the network

as an additional input. Existing works range
from ones where context representations are man-
ually defined (Mikolov and Zweig, 2012; Ji et al.,
2015; Wang and Cho, 2015) to others that rely on
document-level topics learned from data (Dieng
et al., 2016; Wang et al., 2017).

More broadly, in generic sequence modeling,
how to capture long-term dependency has been a
long-standing research problem. From this per-
spective, since the ubiquitous adaption of LSTM,
many efforts have been spent on relieving the
vanishing gradient problem, including better ini-
tialization (Le et al., 2015), additional loss sig-
nal (Trinh et al., 2018), augmented memory struc-
ture (Ke et al., 2018) and others that modify the in-
ternal architecture of RNNs to ease the optimiza-
tion (Wu et al., 2016; Li et al., 2018). Different
from them, our work is based on the Transformer
architecture and shows that language modeling as
a real-world task benefits from the ability to learn
longer-term dependency.

3 Model

Given a corpus of tokens x = (x1, . . . , xT ), the
task of language modeling is to estimate the joint
probability P (x), which is often auto-regressively
factorized as P (x) =

Q
t P (xt | x<t). With the

factorization, the problem reduces to estimating
each conditional factor. In this work, we stick to
the standard neural approach to modeling the con-
ditional probability. Specifically, a trainable neu-
ral network is used to encode the context x<t into
a fixed size hidden state, which is multiplied with
the word embeddings to obtain the logits. The log-
its are then fed into the Softmax function, yielding
a categorical probability distribution over the next
token.

3.1 Vanilla Transformer Language Models

In order to apply Transformer or self-attention to
language modeling, the central problem is how to
train a Transformer to effectively encode an arbi-
trarily long context into a fixed size representation.
Given infinite memory and computation, a sim-
ple solution would be to process the entire con-
text sequence using an unconditional Transformer
decoder, similar to a feed-forward neural network.
However, this is usually infeasible with the limited
resource in practice.

One feasible but crude approximation is to split
the entire corpus into shorter segments of man-



2980

Segment 1

x1 x2 x4x3

Segment 2

x8x5 x6 x7

(a) Train phase.

Limited Context

x1 x2 x4x3 x5 x6

Limited Context

x2 x3 x5x4 x6x1

Limited Context

x3 x4 x6x5x2x1

(b) Evaluation phase.

Figure 1: Illustration of the vanilla model with a segment length 4.

ageable sizes, and only train the model within
each segment, ignoring all contextual information
from previous segments. This is the idea adopted
by Al-Rfou et al. (2018). We call it the vanilla
model and visualize it in Fig. 1a. Under this
training paradigm, information never flows across
segments in either the forward or backward pass.
There are two critical limitations of using a fixed-
length context. First, the largest possible depen-
dency length is upper bounded by the segment
length, which is a few hundred on character-level
language modeling (Al-Rfou et al., 2018). There-
fore, although the self-attention mechanism is less
affected by the vanishing gradient problem com-
pared to RNNs, the vanilla model is not able to
fully exploit this optimization advantage. Second,
though it is possible to use padding to respect the
sentence or other semantic boundaries, in practice
it has been standard practice to simply chunk long
text into fixed-length segments due to improved
efficiency (Peters et al., 2018; Devlin et al., 2018;
Al-Rfou et al., 2018). However, simply chunking
a sequence into fixed-length segments will lead to
the context fragmentation problem as discussed in
Section 1.

During evaluation, at each step, the vanilla
model also consumes a segment of the same length
as in training, but only makes one prediction at the
last position. Then, at the next step, the segment
is shifted to the right by only one position, and the
new segment has to be processed all from scratch.
As shown in Fig. 1b, this procedure ensures that
each prediction utilizes the longest possible con-
text exposed during training, and also relieves con-
text fragmentation issue encountered in training.
However, this evaluation procedure is extremely
expensive. We will show that our proposed archi-
tecture is able to substantially improve the evalua-
tion speed.

3.2 Segment-Level Recurrence with State

Reuse

To address the limitations of using a fixed-length
context, we propose to introduce a recurrence
mechanism to the Transformer architecture. Dur-
ing training, the hidden state sequence computed
for the previous segment is fixed and cached to
be reused as an extended context when the model
processes the next new segment, as shown in Fig.
2a. Although the gradient still remains within a
segment, this additional input allows the network
to exploit information in the history, leading to an
ability of modeling longer-term dependency and
avoiding context fragmentation. Formally, let the
two consecutive segments of length L be s⌧ =
[x⌧,1, · · · , x⌧,L] and s⌧+1 = [x⌧+1,1, · · · , x⌧+1,L]
respectively. Denoting the n-th layer hidden state
sequence produced for the ⌧ -th segment s⌧ by
hn⌧ 2 RL⇥d, where d is the hidden dimension.
Then, the n-th layer hidden state for segment s⌧+1
is produced (schematically) as follows,
ehn�1⌧+1 =

⇥
SG(hn�1⌧ ) � hn�1⌧+1

⇤
,

qn⌧+1,k
n
⌧+1,v

n
⌧+1 = h

n�1
⌧+1W

>
q , ehn�1⌧+1W

>
k , ehn�1⌧+1W

>
v ,

hn⌧+1 = Transformer-Layer (q
n
⌧+1,k

n
⌧+1,v

n
⌧+1) .

where the function SG(·) stands for stop-gradient,
the notation [hu � hv] indicates the concatenation
of two hidden sequences along the length dimen-
sion, and W· denotes model parameters. Com-
pared to the standard Transformer, the critical dif-
ference lies in that the key kn⌧+1 and value vn⌧+1
are conditioned on the extended context ehn�1⌧+1 and
hence hn�1⌧ cached from the previous segment.
We emphasize this particular design by the green
paths in Fig. 2a.

With this recurrence mechanism applied to ev-
ery two consecutive segments of a corpus, it es-
sentially creates a segment-level recurrence in the
hidden states. As a result, the effective context be-
ing utilized can go way beyond just two segments.
However, notice that the recurrent dependency be-
tween hn⌧+1 and hn�1⌧ shifts one layer downwards



2981

x1 x2 x4x3 x8x5 x6 x7

New Segment

x12x9 x10 x11

Fixed (No Grad)

x1 x2 x4x3 x8x5 x6 x7

Fixed (No Grad) New Segment

(a) Training phase.

x1 x2 x4x3 x8x5 x6 x7 x12x9 x10 x11

Extended Context

(b) Evaluation phase.

Figure 2: Illustration of the Transformer-XL model with a segment length 4.

per-segment, which differs from the same-layer
recurrence in conventional RNN-LMs. Conse-
quently, the largest possible dependency length
grows linearly w.r.t. the number of layers as well
as the segment length, i.e., O(N ⇥ L), as vi-
sualized by the shaded area in Fig. 2b. This
is analogous to truncated BPTT (Mikolov et al.,
2010), a technique developed for training RNN-
LMs. However, different from truncated BPTT,
our method caches a sequence of hidden states in-
stead of the last one, and should be applied to-
gether with the relative positional encoding tech-
nique described in Section 3.3.

Besides achieving extra long context and re-
solving fragmentation, another benefit that comes
with the recurrence scheme is significantly faster
evaluation. Specifically, during evaluation, the
representations from the previous segments can
be reused instead of being computed from scratch
as in the case of the vanilla model. In our ex-
periments on enwiki8, Transformer-XL is up to
1,800+ times faster than the vanilla model during
evaluation (see Section 4).

Finally, notice that the recurrence scheme does
not need to be restricted to only the previous seg-
ment. In theory, we can cache as many previous
segments as the GPU memory allows, and reuse
all of them as the extra context when processing
the current segment. Thus, we can cache a prede-
fined length-M old hidden states spanning (pos-
sibly) multiple segments, and refer to them as the
memory mn⌧ 2 RM⇥d, due to a clear connection to
the memory augmented neural networks (Graves
et al., 2014; Weston et al., 2014). In our experi-
ments, we set M equal to the segment length dur-
ing training, and increase it by multiple times dur-
ing evaluation.

3.3 Relative Positional Encodings

While we found the idea presented in the pre-
vious subsection very appealing, there is a cru-
cial technical challenge we haven’t solved in or-

der to reuse the hidden states. That is, how can
we keep the positional information coherent when
we reuse the states? Recall that, in the standard
Transformer, the information of sequence order is
provided by a set of positional encodings, denoted
as U 2 RLmax⇥d, where the i-th row Ui corre-
sponds to the i-th absolute position within a seg-
ment and Lmax prescribes the maximum possible
length to be modeled. Then, the actual input to the
Transformer is the element-wise addition of the
word embeddings and the positional encodings. If
we simply adapt this positional encoding to our
recurrence mechanism, the hidden state sequence
would be computed schematically by

h⌧+1 = f(h⌧ ,Es⌧+1 +U1:L)

h⌧ = f(h⌧�1,Es⌧ +U1:L),

where Es⌧ 2 RL⇥d is the word embedding se-
quence of s⌧ , and f represents a transformation
function. Notice that, both Es⌧ and Es⌧+1 are as-
sociated with the same positional encoding U1:L.
As a result, the model has no information to dis-
tinguish the positional difference between x⌧,j and
x⌧+1,j for any j = 1, . . . , L, resulting in a sheer
performance loss.

In order to avoid this failure mode, the funda-
mental idea is to only encode the relative posi-
tional information in the hidden states. Concep-
tually, the positional encoding gives the model a
temporal clue or “bias” about how information
should be gathered, i.e., where to attend. For the
same purpose, instead of incorporating bias stati-
cally into the initial embedding, one can inject the
same information into the attention score of each
layer. More importantly, it is more intuitive and
generalizable to define the temporal bias in a rela-
tive manner. For instance, when a query vector q⌧,i
attends on the key vectors k⌧,i, it does not need
to know the absolute position of each key vector
to identify the temporal order of the segment. In-
stead, it suffices to know the relative distance be-
tween each key vector k⌧,j and itself q⌧,i, i.e. i�j.
Practically, one can create a set of relative posi-



2982

tional encodings R 2 RLmax⇥d, where the i-th row
Ri indicates a relative distance of i between two
positions. By injecting the relative distance dy-
namically into the attention score, the query vector
can easily distinguish the representations of x⌧,j
and x⌧+1,j from their different distances, making
the state reuse mechanism feasible. Meanwhile,
we won’t lose any temporal information, as the ab-
solute position can be recovered recursively from
relative distances.

Previously, the idea of relative positional encod-
ings has been explored in the context of machine
translation (Shaw et al., 2018) and music gener-
ation (Huang et al., 2018). Here, we offer a dif-
ferent derivation, arriving at a new form of rel-
ative positional encodings, which not only has a
one-to-one correspondence to its absolute coun-
terpart but also enjoys much better generalization
empirically (see Section 4). Firstly, in the standard
Transformer (Vaswani et al., 2017), the attention
score between query qi and key vector kj within
the same segment can be decomposed as

Aabsi,j = E
>
xiW

>
q WkExj| {z }
(a)

+E>xiW
>
q WkUj| {z }
(b)

+U>i W
>
q WkExj| {z }
(c)

+U>i W
>
q WkUj| {z }
(d)

.

Following the idea of only relying on rela-
tive positional information, we propose to re-
parameterize the four terms as follows

Areli,j = E
>
xiW

>
q Wk,EExj| {z }
(a)

+E>xiW
>
q Wk,RRi�j| {z }

(b)

+ u>Wk,EExj| {z }
(c)

+ v>Wk,RRi�j| {z }
(d)

.

• The first change we make is to replace all ap-
pearances of the absolute positional embedding
Uj for computing key vectors in term (b) and
(d) with its relative counterpart Ri�j . This es-
sentially reflects the prior that only the relative
distance matters for where to attend. Note that
R is a sinusoid encoding matrix (Vaswani et al.,
2017) without learnable parameters.

• Secondly, we introduce a trainable parameter
u 2 Rd to replace the query U>i W>q in term
(c). In this case, since the query vector is the
same for all query positions, it suggests that the
attentive bias towards different words should re-
main the same regardless of the query position.
With a similar reasoning, a trainable parameter
v 2 Rd is added to substitute U>i W>q in term
(d).

• Finally, we deliberately separate the two weight
matrices Wk,E and Wk,R for producing the
content-based key vectors and location-based
key vectors respectively.

Under the new parameterization, each term has
an intuitive meaning: term (a) represents content-
based addressing, term (b) captures a content-
dependent positional bias, term (c) governs a
global content bias, and (d) encodes a global po-
sitional bias.

In comparison, the formulation in Shaw et al.
(2018) only has terms (a) and (b), dropping the
two bias terms (c) and (d). Moreover, Shaw et al.
(2018) merge the multiplication WkR into a sin-
gle trainable matrix R̂, which abandons the induc-
tive bias built into the original sinusoid positional
encoding (Vaswani et al., 2017). In contrast, our
relative positional embedding R adapts the sinu-
soid formulation. As a benefit of the inductive
bias, a model trained on a memory of some certain
length can automatically generalize to a memory
several times longer during evaluation.

Equipping the recurrence mechanism with our
proposed relative positional embedding, we finally
arrive at the Transformer-XL architecture. For
completeness, we summarize the computational
procedure for a N -layer Transformer-XL with a
single attention head here. For n = 1, . . . , N :

ehn�1⌧ =
⇥
SG(mn�1⌧ ) � hn�1⌧

⇤

qn⌧ ,k
n
⌧ ,v

n
⌧ =h

n�1
⌧ W

n
q
>, ehn�1⌧ Wnk,E>, ehn�1⌧ Wnv >

An⌧,i,j =q
n
⌧,i

>kn⌧,j + q
n
⌧,i

>Wnk,RRi�j

+ u>k⌧,j + v
>Wnk,RRi�j

an⌧ =Masked-Softmax(A
n
⌧ )v

n
⌧

on⌧ =LayerNorm(Linear(a
n
⌧ ) + h

n�1
⌧ )

hn⌧ = Positionwise-Feed-Forward(o
n
⌧ )

with h0⌧ := Es⌧ defined as the word embed-
ding sequence. In addition, it is worth mention-
ing that a naive way to compute A requires com-
puting Wnk,RRi�j for all pairs (i, j), whose cost
is quadratic w.r.t. the sequence length. How-
ever, noticing that the value of i � j only ranges
from zero to the sequence length, we show a sim-
ple computation procedure in Appendix B, which
reduces the cost to be linear w.r.t. the sequence
length.

4 Experiments

4.1 Main Results

We apply Transformer-XL to a variety of datasets
on both word-level and character-level language



2983

Model #Param PPL

Grave et al. (2016b) - LSTM - 48.7
Bai et al. (2018) - TCN - 45.2
Dauphin et al. (2016) - GCNN-8 - 44.9
Grave et al. (2016b) - Neural cache - 40.8
Dauphin et al. (2016) - GCNN-14 - 37.2
Merity et al. (2018) - QRNN 151M 33.0
Rae et al. (2018) - Hebbian + Cache - 29.9
Ours - Transformer-XL Standard 151M 24.0

Baevski and Auli (2018) - Adaptive Input⇧ 247M 20.5
Ours - Transformer-XL Large 257M 18.3

Table 1: Comparison with state-of-the-art results on
WikiText-103. ⇧ indicates contemporary work.

Model #Param bpc

Ha et al. (2016) - LN HyperNetworks 27M 1.34
Chung et al. (2016) - LN HM-LSTM 35M 1.32
Zilly et al. (2016) - RHN 46M 1.27
Mujika et al. (2017) - FS-LSTM-4 47M 1.25
Krause et al. (2016) - Large mLSTM 46M 1.24
Knol (2017) - cmix v13 - 1.23
Al-Rfou et al. (2018) - 12L Transformer 44M 1.11
Ours - 12L Transformer-XL 41M 1.06

Al-Rfou et al. (2018) - 64L Transformer 235M 1.06
Ours - 18L Transformer-XL 88M 1.03
Ours - 24L Transformer-XL 277M 0.99

Table 2: Comparison with state-of-the-art results on en-
wik8.

modeling to have a comparison with state-of-the-
art systems, including WikiText-103 (Merity et al.,
2016), enwik8 (LLC, 2009), text8 (LLC, 2009),
One Billion Word (Chelba et al., 2013), and Penn
Treebank (Mikolov and Zweig, 2012).

WikiText-103 is the largest available word-level
language modeling benchmark with long-term de-
pendency. It contains 103M training tokens from
28K articles, with an average length of 3.6K to-
kens per article, which allows testing the abil-
ity of long-term dependency modeling. We set
the attention length to 384 during training and
1600 during evaluation. We adopted adaptive soft-
max and input representations (Baevski and Auli,
2018; Grave et al., 2016a). As shown in Table 1,
Transformer-XL reduces the previous state-of-the-
art (SoTA) perplexity from 20.5 to 18.3, which
demonstrates the superiority of the Transformer-
XL architecture.

The dataset enwik8 contains 100M bytes of un-
processed Wikipedia text. We compare our ar-
chitecture with the previous results in Table 2.
Under the model size constraint, the 12-layer
Transformer-XL achieves a new SoTA result, out-

Model #Param bpc

Cooijmans et al. (2016) - BN-LSTM - 1.36
Chung et al. (2016) - LN HM-LSTM 35M 1.29
Zilly et al. (2016) - RHN 45M 1.27
Krause et al. (2016) - Large mLSTM 45M 1.27
Al-Rfou et al. (2018) - 12L Transformer 44M 1.18

Al-Rfou et al. (2018) - 64L Transformer 235M 1.13
Ours - 24L Transformer-XL 277M 1.08

Table 3: Comparison with state-of-the-art results on
text8.

Model #Param PPL

Shazeer et al. (2014) - Sparse Non-Negative 33B 52.9
Chelba et al. (2013) - RNN-1024 + 9 Gram 20B 51.3
Kuchaiev and Ginsburg (2017) - G-LSTM-2 - 36.0
Dauphin et al. (2016) - GCNN-14 bottleneck - 31.9
Jozefowicz et al. (2016) - LSTM 1.8B 30.6
Jozefowicz et al. (2016) - LSTM + CNN 1.04B 30.0
Shazeer et al. (2017) - Low-Budget MoE ⇠5B 34.1
Shazeer et al. (2017) - High-Budget MoE ⇠5B 28.0
Shazeer et al. (2018) - Mesh Tensorflow 4.9B 24.0
Baevski and Auli (2018) - Adaptive Input⇧ 0.46B 24.1
Baevski and Auli (2018) - Adaptive Input⇧ 1.0B 23.7

Ours - Transformer-XL Base 0.46B 23.5
Ours - Transformer-XL Large 0.8B 21.8

Table 4: Comparison with state-of-the-art results on One
Billion Word. ⇧ indicates contemporary work.

performing the 12-layer vanilla Transformer from
Al-Rfou et al. (2018) by 0.05, while both Trans-
former variants have a large margin over conven-
tional RNN-based models. Notably, our 12-layer
architecture achieves the same result as the 64-
layer network from Al-Rfou et al. (2018), using
only 17% of the parameter budget. In order to see
whether better performances can be obtained by
increasing the model size, we train 18-layer and
24-layer Transformer-XLs with increased model
sizes. With the attention length 784 during train-
ing and 3,800 during evaluation, we obtained a
new SoTA result and our method is the first to
break through 1.0 on widely-studied character-
level benchmarks. Different from Al-Rfou et al.
(2018), Transformer-XL does not need any auxil-
iary losses, and thus all benefits are credited to a
better architecture.

Similar to but different from enwik8, text8 con-
tains 100M processed Wikipedia characters cre-
ated by lowering case the text and removing any
character other than the 26 letters a through z, and
space. Due to the similarity, we simply adapt the
best model and the same hyper-parameters on en-
wik8 to text8 without further tuning. The compari-



2984

Model #Param PPL

Inan et al. (2016) - Tied Variational LSTM 24M 73.2
Zilly et al. (2016) - Variational RHN 23M 65.4
Zoph and Le (2016) - NAS Cell 25M 64.0
Merity et al. (2017) - AWD-LSTM 24M 58.8
Pham et al. (2018) - Efficient NAS 24M 58.6
Liu et al. (2018) - Differentiable NAS 23M 56.1
Yang et al. (2017) - AWD-LSTM-MoS 22M 55.97
Melis et al. (2018) - Dropout tuning 24M 55.3

Ours - Transformer-XL 24M 54.52

Merity et al. (2017) - AWD-LSTM+Finetune† 24M 57.3
Yang et al. (2017) - MoS+Finetune† 22M 54.44

Table 5: Comparison with state-of-the-art results on
Penn Treebank. † indicates using two-step finetuning.

son with previous methods is summarized in Table
3. Again, Transformer-XL achieves the new SoTA
result with a clear margin.

One Billion Word does not preserve any long-
term dependency because sentences have been
shuffled. Consequently, this dataset mainly tests
the ability of modeling only short-term depen-
dency. The comparison between Transformer-XL
and the other methods is shown in Table 4. Al-
though Transformer-XL is mainly designed to bet-
ter capture longer-term dependency, it dramati-
cally improves the single-model SoTA from 23.7
to 21.8. Specifically, Transformer-XL signifi-
cantly outperforms a contemporary method using
vanilla Transformers (Baevski and Auli, 2018),
suggesting the advantage of Transformer-XL is
generalizable to modeling short sequences.

We also report the results on word-level Penn
Treebank in Table 5. Similar to AWD-LSTM
(Merity et al., 2017), we apply variational dropout
and weight average to Transformer-XL. With
proper regularization, Transformer-XL achieves a
new SoTA result among models without two-step
finetuning. Penn Treebank has only 1M training
tokens, which implies that Transformer-XL also
generalizes well even on small datasets.

4.2 Ablation Study

We conduct two sets of ablation studies to exam-
ine the effects of two proposed techniques used in
Transformer-XL: the recurrence mechanism and
the new positional encoding scheme.

The first study is performed on WikiText-103,
which requires modeling long-term dependency.
The results are reported in Table 6. Among the
compared encoding schemes, Shaw et al. (2018) is
relative, while Vaswani et al. (2017) and Al-Rfou

et al. (2018) are absolute. “Full” and “half” losses
refer to applying a cross entropy loss to all or the
recent half positions in the segment. We found
that absolute encodings only work well with half
losses because half losses exclude positions with
very short attention lengths during training for bet-
ter generalization. Table 6 shows that both the
recurrence mechanism and our encoding scheme
are necessary to achieve the best performance, as
well as generalizing to longer attention sequences
during evaluation time. Although the backprop-
agation length during training is only 128, with
the two techniques the attention length can be in-
creased to 640 at test time. In the standard setting
with 151M parameters, the perplexity decreases as
the attention length increases.

Since the recurrence mechanism costs addi-
tional memory, we also compare Transformer-XL
with baselines under the same GPU memory con-
straints. As shown in Table 10 in Appendix A,
despite using a shorter backpropagation length,
Transformer-XL remains superior to the baselines.

The second study targets at isolating the ef-
fects of resolving the context fragmentation prob-
lem from the benefit of capturing longer context
length. In order to achieve this goal, we deliber-
ately choose a dataset that does not require long-
term dependency, so that any improvement from
establishing the recurrence can be attributed to
solving the context fragmentation. Specifically,
we perform this controlled experiment on the One
Billion Word dataset, which can only benefit from
removing the context fragmentation. We train
a 20-layer Transformer-XL with ⇠0.3B parame-
ters for 400K steps. As shown in Table 7, using
segment-level recurrence substantially improves
performance even when long-term dependency is
not needed, which is consistent with our previous
discussion that the recurrence mechanism resolves
the context fragmentation problem. Moreover, our
relative positional encodings is also superior to
Shaw et al. (2018) on short sequences.

4.3 Relative Effective Context Length

Khandelwal et al. (2018) proposed a method to
evaluate the Effective Context Length (ECL) of a
sequence model. ECL is the longest length to
which increasing the context span would lead to
a gain more than a threshold. However, ECL ig-
nores the fact that it is harder to get improve-
ment when a model already achieves a lower per-



2985

Remark Recurrence Encoding Loss PPL init PPL best Attn Len

Transformer-XL (128M) 3 Ours Full 27.02 26.77 500
- 3 Shaw et al. (2018) Full 27.94 27.94 256
- 3 Ours Half 28.69 28.33 460
- 7 Ours Full 29.59 29.02 260
- 7 Ours Half 30.10 30.10 120

- 7 Shaw et al. (2018) Full 29.75 29.75 120
- 7 Shaw et al. (2018) Half 30.50 30.50 120
- 7 Vaswani et al. (2017) Half 30.97 30.97 120
Transformer (128M)† 7 Al-Rfou et al. (2018) Half 31.16 31.16 120

Transformer-XL (151M) 3 Ours Full 23.43
23.09 640

23.16 450
23.35 300

Table 6: Ablation study on WikiText-103. For the first two blocks, we use a slightly smaller model (128M parame-
ters). † indicates that the corresponding row is reduced to the same setting as the Transformer network in (Al-Rfou
et al., 2018), except that two auxiliary losses are not implemented in our experiments. “PPL init” refers to using
the same length as training. “PPL best” indicates the perplexity obtained by using the optimal length. “Attn Len”
is the shortest possible attention length during evaluation to achieve the corresponding result (PPL best). Increas-
ing the attention length during evaluation improves performance only when our positional encoding is used. The
“Transformer-XL (151M)” setting uses a standard parameter budget as previous work (Merity et al., 2018), where
we observe a similar effect when increasing the attention length during evaluation.

Method PPL

Ours 25.2
With Shaw et al. (2018) encodings 25.7
Without recurrence 27.1

Table 7: Ablation study on One Billion Word, a dataset
without long-term dependency.

Model r = 0.1 r = 0.5 r = 1.0

Transformer-XL 151M 900 800 700
QRNN 500 400 300
LSTM 400 300 200

Transformer-XL 128M 700 600 500
- use Shaw et al. (2018) encoding 400 400 300
- remove recurrence 300 300 300
Transformer 128 128 128

Table 8: Relative effective context length (RECL) com-
parison. See text for the definition of RECL and r. The
first three models and the last four models are com-
pared as two model groups when we calculate RECL
(RECL is computed on a model group rather than a sin-
gle model). Each group has the same parameter budget.

plexity using only a shorter context, and thus it
is not suitable for fair comparison among mul-
tiple models. We instead propose a new metric
called Relative Effective Context Length (RECL).
RECL is defined on a model group instead of a
single model, and the gain of a long context is
measure by the relative improvement over the best
short context model. As such, the model group
shares the same baseline to enable fair compari-

son. RECL also has a parameter r, which means
constraining the comparison on top-r hard exam-
ples. See Appedix C for more details about RECL.
As shown in Table 8, Transformer-XL manages
to model dependency of 900 words long on av-
erage with r = 0.1. The RECL of Transformer-
XL is 80% and 450% longer than recurrent net-
works and Transformer respectively. Both the re-
currence mechanism and our positional encodings
contribute to a longer RECL. This further substan-
tiates our argument that Transformer-XL is able to
model longer-term dependency.

4.4 Generated Text

Trained only on WikiText-103 which is medium-
sized, Transformer-XL is already able to generate
relatively coherent articles with thousands of to-
kens without manual cherry picking, despite mi-
nor flaws. Please refer to Appendix E for samples.

4.5 Evaluation Speed

Finally, we compare the evaluation speed of our
model with the vanilla Transformer model (Al-
Rfou et al., 2018). As shown in Table 9, due to
the state reuse scheme, Transformer-XL achieves
an up to 1,874 times speedup during evaluation.

5 Conclusions

Transformer-XL obtains strong perplexity results,
models longer-term dependency than RNNs and
Transformer, achieves substantial speedup during



2986

Attn Len How much Al-Rfou et al. (2018) is slower

3,800 1,874x
2,800 1,409x
1,800 773x
800 363x

Table 9: Slowdown in terms of running time during
evaluation. Evaluation is based on per-token time on
one GPU.

evaluation, and is able to generate coherent text
articles. We envision interesting applications of
Transformer-XL in the fields of text generation,
unsupervised feature learning, image and speech
modeling.

Acknowledgments

ZD and YY were supported in part by National
Science Foundation (NSF) under the grant IIS-
1546329 and by the DOE-Office of Science un-
der the grant ASCR #KJ040201. ZY and RS
were supported in part by the Office of Naval
Research grant N000141812861, the NSF grant
IIS1763562, the Nvidia fellowship, and the Siebel
scholarship.

References

Rami Al-Rfou, Dokook Choe, Noah Constant, Mandy
Guo, and Llion Jones. 2018. Character-level lan-
guage modeling with deeper self-attention. arXiv
preprint arXiv:1808.04444.

Alexei Baevski and Michael Auli. 2018. Adaptive in-
put representations for neural language modeling.
arXiv preprint arXiv:1809.10853.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. arXiv preprint
arXiv:1409.0473.

Shaojie Bai, J Zico Kolter, and Vladlen Koltun.
2018. An empirical evaluation of generic convolu-
tional and recurrent networks for sequence model-
ing. arXiv preprint arXiv:1803.01271.

Yoshua Bengio, Réjean Ducharme, Pascal Vincent, and
Christian Jauvin. 2003. A neural probabilistic lan-
guage model. Journal of machine learning research,
3(Feb):1137–1155.

Ciprian Chelba, Tomas Mikolov, Mike Schuster, Qi Ge,
Thorsten Brants, Phillipp Koehn, and Tony Robin-
son. 2013. One billion word benchmark for measur-
ing progress in statistical language modeling. arXiv
preprint arXiv:1312.3005.

Junyoung Chung, Sungjin Ahn, and Yoshua Bengio.
2016. Hierarchical multiscale recurrent neural net-
works. arXiv preprint arXiv:1609.01704.

Tim Cooijmans, Nicolas Ballas, César Laurent, Çağlar
Gülçehre, and Aaron Courville. 2016. Re-
current batch normalization. arXiv preprint
arXiv:1603.09025.

Andrew M Dai and Quoc V Le. 2015. Semi-supervised
sequence learning. In Advances in neural informa-
tion processing systems, pages 3079–3087.

Yann N Dauphin, Angela Fan, Michael Auli, and
David Grangier. 2016. Language modeling with
gated convolutional networks. arXiv preprint
arXiv:1612.08083.

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and
Kristina Toutanova. 2018. Bert: Pre-training of deep
bidirectional transformers for language understand-
ing. arXiv preprint arXiv:1810.04805.

Adji B Dieng, Chong Wang, Jianfeng Gao, and John
Paisley. 2016. Topicrnn: A recurrent neural net-
work with long-range semantic dependency. arXiv
preprint arXiv:1611.01702.

Yarin Gal and Zoubin Ghahramani. 2016. A theoret-
ically grounded application of dropout in recurrent
neural networks. In Advances in neural information
processing systems, pages 1019–1027.

Edouard Grave, Armand Joulin, Moustapha Cissé,
David Grangier, and Hervé Jégou. 2016a. Efficient
softmax approximation for gpus. arXiv preprint
arXiv:1609.04309.

Edouard Grave, Armand Joulin, and Nicolas
Usunier. 2016b. Improving neural language
models with a continuous cache. arXiv preprint
arXiv:1612.04426.

Alex Graves. 2013. Generating sequences with
recurrent neural networks. arXiv preprint
arXiv:1308.0850.

Alex Graves, Greg Wayne, and Ivo Danihelka.
2014. Neural turing machines. arXiv preprint
arXiv:1410.5401.

David Ha, Andrew Dai, and Quoc V Le. 2016. Hyper-
networks. arXiv preprint arXiv:1609.09106.

Sepp Hochreiter, Yoshua Bengio, Paolo Frasconi, Jür-
gen Schmidhuber, et al. 2001. Gradient flow in re-
current nets: the difficulty of learning long-term de-
pendencies.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Cheng-Zhi Anna Huang, Ashish Vaswani, Jakob
Uszkoreit, Noam Shazeer, Curtis Hawthorne, An-
drew M Dai, Matthew D Hoffman, and Douglas Eck.



2987

2018. An improved relative self-attention mecha-
nism for transformer with application to music gen-
eration. arXiv preprint arXiv:1809.04281.

Hakan Inan, Khashayar Khosravi, and Richard Socher.
2016. Tying word vectors and word classifiers:
A loss framework for language modeling. arXiv
preprint arXiv:1611.01462.

Yangfeng Ji, Trevor Cohn, Lingpeng Kong, Chris Dyer,
and Jacob Eisenstein. 2015. Document context lan-
guage models. arXiv preprint arXiv:1511.03962.

Rafal Jozefowicz, Oriol Vinyals, Mike Schuster, Noam
Shazeer, and Yonghui Wu. 2016. Exploring
the limits of language modeling. arXiv preprint
arXiv:1602.02410.

Nan Rosemary Ke, Anirudh Goyal ALIAS PARTH
GOYAL, Olexa Bilaniuk, Jonathan Binas,
Michael C Mozer, Chris Pal, and Yoshua Ben-
gio. 2018. Sparse attentive backtracking: Temporal
credit assignment through reminding. In Advances
in Neural Information Processing Systems, pages
7650–7661.

Urvashi Khandelwal, He He, Peng Qi, and Dan Ju-
rafsky. 2018. Sharp nearby, fuzzy far away: How
neural language models use context. arXiv preprint
arXiv:1805.04623.

Bryon Knol. 2017. cmix v13. http://www.
byronknoll.com/cmix.html.

Ben Krause, Liang Lu, Iain Murray, and Steve Renals.
2016. Multiplicative lstm for sequence modelling.
arXiv preprint arXiv:1609.07959.

Oleksii Kuchaiev and Boris Ginsburg. 2017. Factor-
ization tricks for lstm networks. arXiv preprint
arXiv:1703.10722.

Quoc V Le, Navdeep Jaitly, and Geoffrey E Hin-
ton. 2015. A simple way to initialize recurrent
networks of rectified linear units. arXiv preprint
arXiv:1504.00941.

Shuai Li, Wanqing Li, Chris Cook, Ce Zhu, and Yanbo
Gao. 2018. Independently recurrent neural network
(indrnn): Building a longer and deeper rnn. In Pro-
ceedings of the IEEE Conference on Computer Vi-
sion and Pattern Recognition, pages 5457–5466.

Hanxiao Liu, Karen Simonyan, and Yiming Yang.
2018. Darts: Differentiable architecture search.
arXiv preprint arXiv:1806.09055.

MultiMedia LLC. 2009. Large text compression
benchmark.

Gábor Melis, Charles Blundell, Tomáš Kočiskỳ,
Karl Moritz Hermann, Chris Dyer, and Phil Blun-
som. 2018. Pushing the bounds of dropout. arXiv
preprint arXiv:1805.09208.

Stephen Merity, Nitish Shirish Keskar, and Richard
Socher. 2017. Regularizing and optimizing lstm lan-
guage models. arXiv preprint arXiv:1708.02182.

Stephen Merity, Nitish Shirish Keskar, and Richard
Socher. 2018. An analysis of neural language
modeling at multiple scales. arXiv preprint
arXiv:1803.08240.

Stephen Merity, Caiming Xiong, James Bradbury, and
Richard Socher. 2016. Pointer sentinel mixture
models. arXiv preprint arXiv:1609.07843.

Tomáš Mikolov, Martin Karafiát, Lukáš Burget, Jan
Černockỳ, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In
Eleventh Annual Conference of the International
Speech Communication Association.

Tomas Mikolov and Geoffrey Zweig. 2012. Context
dependent recurrent neural network language model.
SLT, 12(234-239):8.

Asier Mujika, Florian Meier, and Angelika Steger.
2017. Fast-slow recurrent neural networks. In Ad-
vances in Neural Information Processing Systems,
pages 5915–5924.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. arXiv preprint arXiv:1802.05365.

Hieu Pham, Melody Y Guan, Barret Zoph, Quoc V
Le, and Jeff Dean. 2018. Efficient neural architec-
ture search via parameter sharing. arXiv preprint
arXiv:1802.03268.

Alec Radford, Karthik Narasimhan, Tim Salimans, and
Ilya Sutskever. 2018. Improving language under-
standing by generative pre-training. URL https://s3-
us-west-2. amazonaws. com/openai-assets/research-
covers/languageunsupervised/language under-
standing paper. pdf.

Jack W Rae, Chris Dyer, Peter Dayan, and Tim-
othy P Lillicrap. 2018. Fast parametric learn-
ing with activation memorization. arXiv preprint
arXiv:1803.10049.

Peter Shaw, Jakob Uszkoreit, and Ashish Vaswani.
2018. Self-attention with relative position represen-
tations. arXiv preprint arXiv:1803.02155.

Noam Shazeer, Youlong Cheng, Niki Parmar, Dustin
Tran, Ashish Vaswani, Penporn Koanantakool, Peter
Hawkins, HyoukJoong Lee, Mingsheng Hong, Cliff
Young, et al. 2018. Mesh-tensorflow: Deep learning
for supercomputers. In Advances in Neural Infor-
mation Processing Systems, pages 10434–10443.

Noam Shazeer, Azalia Mirhoseini, Krzysztof Maziarz,
Andy Davis, Quoc Le, Geoffrey Hinton, and Jeff
Dean. 2017. Outrageously large neural networks:
The sparsely-gated mixture-of-experts layer. arXiv
preprint arXiv:1701.06538.

http://www.byronknoll.com/cmix.html
http://www.byronknoll.com/cmix.html


2988

Noam Shazeer, Joris Pelemans, and Ciprian Chelba.
2014. Skip-gram language modeling using sparse
non-negative matrix probability estimation. arXiv
preprint arXiv:1412.1454.

Trieu H Trinh, Andrew M Dai, Thang Luong, and
Quoc V Le. 2018. Learning longer-term dependen-
cies in rnns with auxiliary losses. arXiv preprint
arXiv:1803.00144.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. In Advances in Neural Information Pro-
cessing Systems, pages 5998–6008.

Tian Wang and Kyunghyun Cho. 2015. Larger-
context language modelling. arXiv preprint
arXiv:1511.03729.

Wenlin Wang, Zhe Gan, Wenqi Wang, Dinghan Shen,
Jiaji Huang, Wei Ping, Sanjeev Satheesh, and
Lawrence Carin. 2017. Topic compositional neural
language model. arXiv preprint arXiv:1712.09783.

Jason Weston, Sumit Chopra, and Antoine Bor-
des. 2014. Memory networks. arXiv preprint
arXiv:1410.3916.

Yuhuai Wu, Saizheng Zhang, Ying Zhang, Yoshua
Bengio, and Ruslan R Salakhutdinov. 2016. On
multiplicative integration with recurrent neural net-
works. In Advances in neural information process-
ing systems, pages 2856–2864.

Zhilin Yang, Zihang Dai, Ruslan Salakhutdinov, and
William W Cohen. 2017. Breaking the softmax bot-
tleneck: A high-rank rnn language model. arXiv
preprint arXiv:1711.03953.

Julian Georg Zilly, Rupesh Kumar Srivastava,
Jan Koutník, and Jürgen Schmidhuber. 2016.
Recurrent highway networks. arXiv preprint
arXiv:1607.03474.

Barret Zoph and Quoc V Le. 2016. Neural architecture
search with reinforcement learning. arXiv preprint
arXiv:1611.01578.


