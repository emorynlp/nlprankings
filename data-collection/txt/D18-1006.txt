



















































Reasoning about Actions and State Changes by Injecting Commonsense Knowledge


Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 57–66
Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics

57

Reasoning about Actions and State Changes
by Injecting Commonsense Knowledge

Niket Tandon*, Bhavana Dalvi Mishra∗, Joel Grus,
Wen-tau Yih, Antoine Bosselut, Peter Clark

Allen Institute for AI, Seattle, WA
{nikett,bhavanad,joelg,scottyih,antoineb,peterc}@allenai.org

Abstract

Comprehending procedural text, e.g., a para-
graph describing photosynthesis, requires
modeling actions and the state changes they
produce, so that questions about entities at dif-
ferent timepoints can be answered. Although
several recent systems have shown impressive
progress in this task, their predictions can be
globally inconsistent or highly improbable. In
this paper, we show how the predicted effects
of actions in the context of a paragraph can
be improved in two ways: (1) by incorporat-
ing global, commonsense constraints (e.g., a
non-existent entity cannot be destroyed), and
(2) by biasing reading with preferences from
large-scale corpora (e.g., trees rarely move).
Unlike earlier methods, we treat the problem
as a neural structured prediction task, allow-
ing hard and soft constraints to steer the model
away from unlikely predictions. We show that
the new model significantly outperforms ear-
lier systems on a benchmark dataset for proce-
dural text comprehension (+8% relative gain),
and that it also avoids some of the nonsensical
predictions that earlier systems make.

1 Introduction

Procedural text is ubiquitous (e.g., scientific proto-
cols, news articles, how-to guides, recipes), but is
challenging to comprehend because of the dynamic
nature of the world being described. Comprehend-
ing such text requires a model of the actions de-
scribed in the text and the state changes they pro-
duce, so that questions about the states of entities
at different timepoints can be answered (Bosselut
et al., 2018).

Despite these challenges, substantial progress
has been made recently in this task. Recent work
– such as EntNet (Henaff et al., 2017), QRN (Seo
et al., 2017b), ProLocal/ProGlobal (Dalvi et al.,

∗*Niket Tandon and Bhavana Dalvi Mishra contributed
equally to this work.

Procedural Text:
How hydroelectric electricity is generated:
1 Water flows downwards thanks to gravity.
2 The moving water spins the turbines in the
power plant.
3 The turbines turn the generators.
4 The generators spin, and produce electricity.

Prior Neural Model’s Predictions:

Figure 1: Poor predictions (in red) made by a prior neu-
ral model (ProGlobal) applied to an (abbreviated) para-
graph from the ProPara dataset. ProGlobal predicts en-
tity locations at each sentence, but the implied move-
ments violate commonsense constraints (e.g., an object
cannot move from itself (1)) and corpus-based prefer-
ences (e.g., it is rare to see turbines move (2)).

2018), and NPN (Bosselut et al., 2018) – has fo-
cused on learning to predict individual entity states
at various points in the text, thereby approximating
the underlying dynamics of the world. However,
while these models can learn to make local pre-
dictions with fair accuracy, their results are often
globally unlikely or inconsistent. For example, in
Figure 1, the neural ProGlobal model from Dalvi
et al. (2018) learns to predict the impossible ac-
tion of an object moving from itself (1), and the
unlikely action of a turbine changing location (2).
We observe similar mistakes in other neural mod-
els, indicating that these models have little notion
of global consistency. Unsurprisingly, mistakes
in local predictions compound as the process be-
comes longer, further reducing the plausibility of
the overall result.



58

To address this challenge, we treat process com-
prehension as a structured prediction task and ap-
ply hard and soft constraints during reading. Dur-
ing training, our model, called ProStruct, learns
to search for the most likely action sequence that
is consistent with global constraints (e.g., entities
cannot be destroyed after they have already been
destroyed) and priors from background knowledge
(e.g., turbines rarely change location). The model is
trained end-to-end, with gradients backpropagating
through the search path. We find that this approach
significantly outperforms existing approaches on
a benchmark dataset for process comprehension,
mainly by avoiding the nonsensical predictions that
earlier systems make.

Our contributions are twofold. First, we reformu-
late procedural text comprehension in a novel way:
as a (neural) structured prediction task. This lets
hard and soft constraints steer the model away from
unlikely and nonsensical predictions. Second, we
present a novel, end-to-end model that integrates
these constraints and achieves state-of-the-art per-
formance on an existing process comprehension
dataset (Dalvi et al., 2018).

2 Related Work

Our work builds off a recent body of work that fo-
cuses on using neural networks to explicitly track
the states of entities while reading long texts. These
works have focused on answering simple common-
sense questions (Henaff et al., 2017), tracking en-
tity states in scientific processes (Dalvi et al., 2018;
Clark et al., 2018), tracking ingredients in cooking
recipes (Bosselut et al., 2018), and tracking the
emotional reactions and motivations of characters
in simple stories (Rashkin et al., 2018). Our work
extends these methods and addresses their most
common issues by using background knowledge
about entities to prune the set of state changes they
can experience as the model reads new text.

Prior to these neural approaches, some earlier
systems for process comprehension did make use
of world knowledge, and motivated this work. Like
us, the system ProRead (Berant et al., 2014; Scaria
et al., 2013) also treated process comprehension as
structure prediction, using an Integer Linear Pro-
gramming (ILP) formalism to enforce global con-
straints (e.g., if the result of event1 is the agent of
event2, then event1 must enable event2). Similarly,
Kiddon et al. (2015) used corpus-based priors to
guide extraction of an “action graph” from recipes.

Our work here can viewed as incorporating these
approaches within the neural paradigm.

Neural methods for structure prediction have
been used extensively in other areas of NLP, and we
leverage these methods here. In particular we use
a neural encoder-decoder architecture with beam
search decoding, representative of several current
state-of-the-art systems (Bahdanau et al., 2014;
Wiseman and Rush, 2016; Vinyals et al., 2015). As
our model’s only supervision signal comes from
the final prediction (of state changes), our work is
similar to previous work in semantic parsing that
extracts structured outputs from text with no inter-
mediate supervision (Krishnamurthy et al., 2017).

State tracking also appears in other areas of AI,
such as dialog. A typical dialog state tracking task
(e.g., the DSTC competitions) involves gradually
uncovering the user’s state (e.g., their constraints,
preferences, and goals for booking a restaurant),
until an answer can be provided. Although this
context is somewhat different (the primary goal
being state discovery from weak dialog evidence),
state tracking techniques originally designed for
procedural text have been successfully applied in
this context also (Liu and Perez, 2017).

Finally, our model learns to search over the best
candidate structures using hard constraints and soft
KB priors. Previous work in Neural Machine Trans-
lation (NMT) has used sets of example-specific lex-
ical constraints in beam search decoding to only
produce translations that satisfy every constraint in
the set (Hokamp and Liu, 2017). In contrast, our
work uses a set of global example-free constraints
to prune the set of possible paths the search algo-
rithm can explore. Simultaneously, a recent body
of work has explored encoding soft constraints as
an additional loss term in the training objective for
dialogue (Wen et al., 2015), machine translation
(Tu et al., 2016), and recipe generation (Kiddon
et al., 2016). Our work instead uses soft constraints
to re-rank candidate structures and is not directly
encoded in the loss function.

3 Problem Definition

We first define the general task that we are ad-
dressing, before presenting our approach.

3.1 General Formulation
We define the task as follows. Given:

• A paragraph of procedural text S = an or-
dered set of sentences {s1, ..., sT } describing



59

Figure 2: How the (simplified) paragraph in Figure 1
is annotated in ProPara. Each filled row shows the lo-
cation of entities between each step (“?” denotes “un-
known”, “-” denotes “does not exist”). For example, in
the last line (state4), the water is at the turbine.

a sequence of actions1 about a given topic (a
word or phrase).
• A set of entities E = {e j} representing the en-

tities mentioned in the procedure or process.
Each entity e j is denoted by the set of its men-
tions in the paragraph, e.g., {leaf, leaves}
• A set of properties P = {pk} of entities to be

tracked (e.g., location, existence)

predict:

• The state of each entity e j after each sentence
sk, where an entity’s state is the values of all
its properties {pk}. For example, in Figure 2,
the state of the water after step 2 is {loca-
tion(water) = turbine; exists(water) = true}.

This task definition covers the tasks used in earlier
procedural text comprehension datasets. In bAbI
tasks 1-3, a single propert (location) was tracked
for a single entity throughout a paragraph (Weston
et al., 2015). In the state tracking task of Bosselut
et al. (2018), six properties (temperature, shape,
etc.) were tracked for each ingredient in the recipe.

3.2 Data

In our work, we use the ProPara dataset (Dalvi
et al., 2018) for both illustration and evalution.
ProPara contains 488 paragraphs (3100 sentences)
of a particular genre of procedural text, namely sci-
ence processes (e.g., how hydroelectricity is gen-
erated). The dataset tracks two entity properties,
existence and location, for all entities involved in
each process, resulting in 81,000 annotations in the

1We use a broad definition of action to mean any event that
changes the state of the world (including non-volitional events
such as roots absorbing water).

dataset. Figure 2 gives a (simplified) example of
the data, visualized as an (entity x sentence) grid,
where each column tracks a different entity (time
progressing vertically downwards), and each row
denotes the entities’ state (existence and location)
after each sentence. To evaluate the predictions,
a set of templated questions whose answers can
be computed from the predictions is posed (e.g.,
“What was destroyed, when and where?”).

4 Model

We now describe our model, called ProStruct.

4.1 Overview

We approach the task by predicting the state
changes that occur at each step of the text, us-
ing a vocabulary (size K) of the possible state
change types that can occur given the domain and
properties being modeled. For example, for the
ProPara dataset, we model K = 4 types of state
change: move, create, destroy, and none.
move changes an entity’s location from one place to
another, create from non-existence to a location,
and destroy from a location to non-existence.
State changes can be parameterized by text spans
in the paragraph, e.g., move takes a before and after
location parameter. If a parameterized state change
is predicted, then the model also must predict its
parameter values from the paragraph.

Previous models for process comprehension
make a sequence of local predictions about the
entities’ states, one sentence at a time, maintaining
a (typically neural) state at each sentence. However,
none have the ability to reverse earlier predictions
should an inconsistency arise later in the sequence.
ProStruct overcomes this limitation by reformu-
lating the task as structured prediction. To do this,
it uses a neural encoder-decoder from the semantic
parsing literature (Krishnamurthy et al., 2017; Yin
and Neubig, 2017) combined with a search proce-
dure that integrates soft and hard constraints for
finding the best candidate structure.

For each sentence and entity, the encoder first
uses a bidirectional LSTM to encode the sentence
and indicator variables identifying which entity is
currently being considered (Figure 3). It then pro-
duces a (distributed) representation of the action
that the sentence describes as being applied to that
entity. During decoding, the model decodes each
action embedding into a distribution over possi-
ble state changes that might result, then performs



60

Figure 3: The encoder, illustrated for the ProPara do-
main with the paragraph from Figure 1. During encod-
ing, ProStruct creates an action embedding ct j repre-
senting the action at step t on entity ek, for all entities
at all steps. The overall action sequence (right-hand
box) is the collection of these embeddings, for each en-
tity (listed horizontally) and each step (listed vertically
downwards).

a search over the space of possible state change
sequences. Each node in the space is a partial se-
quence of state changes, and each edge is a predic-
tion of the next state changes to add to the sequence
(Figure 4).

During training, the model only follows the path
along the gold sequence, and optimizes a loss func-
tion that drives up the likelihood of predictions
along that path (thus driving down the probabilities
for alternative, incorrect paths). At test time, the
model does not have access to the gold path, and
instead performs a beam search of the space to find
the best candidate sequence.

Most importantly, by mapping the state change
prediction problem to structured prediction, we can
perform a search over the set of candidate paths
that allows us to introduce hard and soft constraints
that capture commonsense knowledge. Hard con-
straints are used to prune the search space (Equa-
tion 4 later), and soft constraints bias the search
away from unlikely state changes via an additional
term in the scoring function (Equations 5 and 6).

4.2 Encoder

The encoder operates over every (st, e j) ∈ S × E
pair to create an encoded representation ct j of the
action described by sentence st, as applied to entity
e j. In other words, we can consider the overall

action to be represented by |E| embeddings, one
for each of the entities in E, encoding the action’s
effects on each. This novel feature allows us to
model different effects on different entities by the
same action. For example, a conversion action
may simultaneously destroy one entity and create
another. Figure 3 shows the encoder operating on
s4: “The generator spins, and produces electricity”
and e3: electricity from Figure 1.

Without loss of generality, we define an arbitrary
sentence in S as st = {w0, ...,wI}. Each word wi in
the input sentence is encoded as a vector xi = [vw :
ve : vv], which is the concatenation of a pre-trained
word embedding vw for wi, an indicator variable
ve for whether wi is a reference to the specified
entity e j, and an indicator variable vv for whether
wi is a verb. We use GloVe vectors as pre-trained
embeddings (Pennington et al., 2014) and a POS
tagger to extract verbs (Spacy, 2018).

Then, a BiLSTM is used to encode the word
representations extracted above, yielding a contex-
tualized vector hi for each embedded word xi that
is the concatenated output of the backward and for-
ward hidden states produced by the BiLSTM for
word wi. An attention over the contextualized em-
beddings hi is performed to predict a distribution
of weights over the sentence:

ai = hi ∗ B ∗ hev + b (1)

ct j =
I∑

i=1

ai ∗ hi (2)

where ai is the attention weight for each contex-
tualized embedding, ct j is the vector encoding the
action for the sentence-entity pair (st, e j), B and b
are learned parameters, and hev is the concatenation
of the contextual embeddings of the hidden states
where the entity he and verb hv are mentioned:

hev = [µ({hi : xi[ve] = 1}); µ({hi : xi[vv] = 1}]
(3)

where µ is an average function, and xi[ve] and xi[vv]
correspond to the entity indicator and verb indicator
variables defined above for any word wi, respec-
tively. The output vector ct j encodes the action at
step st on entity e j. This vector is computed for all
steps and entities, populating a grid of the actions
on each entity at each step (Figure 3).

4.3 Decoder
To decode the action vectors ct j into their resulting
state changes they imply, each is passed through a



61

feedforward layer to generate logit(π jt ), a set of lo-
gistic activations over the K possible state changes
π

j
t for entity e j in sentence st. (For ProPara, there

are K = 4 possible state changes: move, create,
destroy, none). These logits denote how likely
each state change π jt is for entity e j at sentence
st. The decoder then explores the search space of
possible state change sequences for the whole para-
graph (Figure 4), using these likelihoods to score
each visited sequence (Equation 6).

Let πt be the set of state changes for all entities
at time t, i.e., πt = {π jt } j=1..|E|, and let Πt be the
sequence of state changes from time 1 to t, i.e.,
Πt = [π1, ..., πt]. Each node in the search space
is a Πt, and each edge adds a πt+1 to it so that it
becomes Πt+1:

Πt
πt+1−−−→ Πt+1

Given there are K possible values for π jt , the num-
ber of possible configurations for πt at time t (i.e.,
the branching factor during search) is exponential:
K |E|, where |E| is the number of entities in the para-
graph.

To explore this exponential number of paths, af-
ter every sentence st, we prune branches Πt → Πt+1
where Πt+1 is impossible according to background
knowledge (described in Section 5.1). We define
the boolean function over state change sequences:

allowable(Π) = 1 if hard constraints satisfied

= 0 otherwise (4)
and prune paths Πt+1 where allowable(Πt+1) = 0.
For example for ProPara, a state transition such
as DESTROY → MOVE is not allowed because a
hard constraint prohibits non-existent entities from
being moved (Section 5.1).

While hard constraints remove impossible state
change predictions, there may also be other state
changes that are implausible with respect to back-
ground knowledge. For example, commonsense
dictates that it is unlikely (but not impossible) for
plants to be destroyed during photosynthesis. Ac-
cordingly, our inference procedure should discour-
age (but not prohibit) predicting plant destruction
when reading about photosynthesis. To discourage
unlikely state changes, we make use of soft con-
straints that estimate the likelihood of a particular
state change associated with an entity, denoted as:

P(π j|e j, topic) (5)
In Section 5.2, we describe how these likelihoods
can be estimated from large-scale corpora. We add
this bias as an additional term (the second term
below) when scoring the addition of πt+1 to the

Figure 4: The decoder, illustrated for the ProPara do-
main. Each action embedding ct j is first passed through
a feedforward layer to generate a distribution over the
(here K = 4) possible state changes that could result,
for each entity (listed horizontally) at each step (listed
vertically downwards). The decoder then explores the
space of state-change sequences, using these distribu-
tions to guide the search. During end-to-end train-
ing, ProStruct follows the correct (green) path, and
backpropagates to drive up probabilities along this path.
During testing, the system performs a beam search to
find the most globally plausible sequence.

sequence so far Πt:

φ′(πt+1) =
|E|∑
j=1

(
λ logit(π jt+1)

+ (1 − λ) log P(π jt+1|e j, topic)
)

(6)
where λ is a learned parameter controlling the de-
gree of bias.

During search, when making a transition along
a path from Πt to a valid Πt+1, Πt+1 is scored by
accumulating normalized scores along the path:

φ(Πt+1) = φ(Πt) +
φ′(πt+1)∑

π′t+1∈Πt+1 φ
′(π′t+1)

(7)

Continuing state transitions in this manner, when
we reach the finished state (i.e., last sentence), our
objective is to maximize the score of the state
changes produced when reading each sentence.
During training, we only materialize a valid node
when Πt ∈ Π∗t where Π∗t is the set of nodes along
the gold path.

We use this constrained decoding to predict the
state change sequence. For state changes that take
additional parameters, e.g., in the ProPara model
a move is parameterized by the before and after



62

locations, we also predict those parameter values
during decoding. This is done using standard span
prediction layers (inspired by BiDAF, Seo et al.
(2017a)) on top of the encoded input.

The model is trained to minimize the joint loss
of predicting the correct state changes and correct
state change parameters for every sentence in the
paragraph:

L = −
T∑

t=1

(
log P(πt)+

|E|∑
j=1

∑
p∈param(π jt )

log P(vp jt|π jt )
)

(8)
where param(π jt ) are the parameters of state change
π

j
t , and vp jt are the values of those parameters. For

example, move is parameterized by before/after lo-
cations, and the 2nd loss term refers to the predicted
values of those locations.

At test time, instead of following the gold state
change path, we use beam search. After reading
any sentence, we explore the top-k states sorted by
the score φ′(πt) that satisfy hard constraints. This
way, we predict a sequence of state changes that
have maximum score while being sensible w.r.t.
hard constraints.

5 Incorporating Commonsense
Knowledge

By formulating procedural text comprehension as
a structured prediction task, we can introduce com-
monsense knowledge as hard and soft constraints
into the model, allowing nonsensical and unlikely
predictions to be avoided, and allowing the system
to recover from early mistakes.

5.1 Hard Constraints
Hard constraints are introduced by defining the
(boolean) function over a candidate sequence of
state changes:

allowable(Π)
used in Equation 4.

While this function can be defined in any way,
for the ProPara application we use six constraints.
The first three below are based on basic “laws of
physics” or commonsense (CS) and are universally
applicable:

CS-1: An entity must exist before it can be moved
or destroyed

CS-2: An entity cannot be created if it already exists
CS-3: An entity cannot change until it is mentioned

in the paragraph

The next three constraints are observed in the
training data:

D-1: Maximum number of toggles for an entity be-
tween Exists and not Exist ≤ fmax_toggles

D-2: Max fraction of entities that are changed per
sentence ≤ fentities_per_sentence

D-3: Max fraction of sentences in which an entity
changes ≤ fsentences_per_entity

The thresholds used in D-1, D-2 and D-3 are hyper-
parameters that can be tuned on the dev set.

5.2 Soft Constraints
Soft constraints are introduced by defining the prior
probabilities used in Equation 6:

P(π j|e j, topic)
that entity e j undergoes state change π j in a sen-
tence of text about topic. These probabilities are
used to re-rank the candidate event sequences dur-
ing decoding (see Equation 6).

While any method can be used to estimate these
probabilities, we describe our corpus-based ap-
proach here. Although it was designed for ProPara,
it generalizes easily to other domains, and is it-
self a contribution of this work. For a given state
change π j, entity e j, and topic, we first gather a
corpus of Web sentences mentioning that topic (us-
ing Bing search APIs), then count the number of
times x that the entity is described as undergoing
that state change (e.g., that water is said to MOVE).
To determine this frequency, we first convert the
sentences into a set of SRL frames (verb + role-
argument pairs) using an off-the-shelf SRL labeler.
We then use an existing rulebase, derived from
VerbNet, that contains rules that map SRL frames
to state changes, e.g., e1/ARG0 “absorbs”/VERB
e2/ARG1 =⇒ e2 MOVES (Clark et al., 2018). Al-
though the rules and SRL labels are incomplete
and noisy, redundancy in the corpus provides some
robustness when estimating the frequency x. Fi-
nally, the observed frequency x is converted to a
likelihood using a logistic transformation:

P(π j|e j, topic) =
1

1 + exp−(x−x0)
(9)

where, x0 is a hyperparameter tuned on the dev set.

5.3 Commonsense Constraints for New
Domains

The commonsense constraints we have used for
ProPara are general, covering the large variety of
topics contain in ProPara (e.g., electricity, photo-
synthesis, earthquakes). However, if one wants to



63

apply ProStruct to other genres of procedural text
(e.g., fictional text, newswire articles), or broaden
the state change vocabulary, different common-
sense constraints may be needed. Note that our
model architecture itself is agnostic to the source
and quantity of hard and soft constraints. For
example, one might leverage commonsense rules
from existing ontologies such as SUMO (Niles and
Pease, 2001) or Cyc (Lenat et al., 1985) to identify
new hard constraints; and our corpus-based method
could be extended to cover new state change types
should the state change vocabulary be extended.

6 Evaluation

We evaluate our model using the ProPara dataset,
and compare against several strong baselines pub-
lished with the original dataset (Dalvi et al., 2018).

6.1 Evaluation setup

Given a paragraph and set of entities as input, the
task is to answer four templated questions, whose
answers are deterministically computed from the
state change sequence:
Q1. What are the inputs to the process?
Q2. What are the outputs of the process?
Q3. What conversions occur, when and where?
Q4. What movements occur, when and where?
Inputs are defined as entities that existed at the
start of the process, but not at the end. Outputs
are entities that did not exist at the start, but did at
the end. A conversion is when some entities are
destroyed and others created. Finally, a movement
is an event where an entity changes location.

For each process, as every question can have
multiple answers, we compute a separate F1 score
for each question by comparing the gold and pre-
dicted answers. For Q1 and Q2, this is straightfor-
ward as answers are atomic (i.e., individual names
of entities). For Q3, as each answer is a 4-tuple
(convert-from, convert-to, location, sentence-id),
some answers may only be partially correct. To
score partial correctness, we pair gold and pre-
dicted answers by requiring the sentence-id in each
to be the same, and then score each pair by the Ham-
ming distance of their tuples. For Q4, each answer
is also a 4-tuple (entity, from-location, to-location,
sentence-id), and the same procedure is applied.
The four F1 scores are then macro-averaged. The
total number of items to predict in the train/dev/test
partitions is 7043/913/1095.

6.2 Baselines

We compare results using the following process
comprehension models:
Recurrent Entity Networks (EntNet) (Henaff
et al., 2017) are a state-of-the-art model for the
bAbI tasks (Weston et al., 2015). The model uses a
dynamic memory to maintain a representation of
the world state as sentences are read, with a gated
update at each step. These states are decoded to
answer questions after each sentence is read.
Query Reduction Networks (QRN) (Seo et al.,
2017b) perform a gated propagation of their hidden
state across each time-step. Given a question, the
hidden state is used to modify the query to keep
pointing to the answer at each step.
ProLocal (Dalvi et al., 2018) predicts the state
changes described in individual sentences, and then
uses commonsense rules of inertia to propagate
state values forwards and backwards in time.
ProGlobal (Dalvi et al., 2018) predicts states of an
entity across all time steps. It considers the entire
paragraph while predicting states for an entity, and
learns to predict location spans at time-step t + 1
based on location span predictions at t.

7 Results

7.1 Comparison with Baselines

We compare our model (which make use of world
knowledge) with the four baseline systems on the
ProPara dataset. All models were trained on the
training partition, and the best model picked based
on prediction accuracy on the dev partition. Table 1
shows the precision, recall, and F1 for all models
on the the test partition. ProStruct significantly
outperforms the baselines, suggesting that world
knowledge helps ProStruct avoid spurious pre-
dictions. This hypothesis is supported by the fact
that the ProGlobal model has the highest recall and
worst precision, indicating that it is over-generating
state change predictions. Conversely, the ProLocal
model has the highest precision, but its recall is
much lower, likely because it makes predictions
for individual sentences, and thus has no access
to information in surrounding sentences that may
suggest a state change is occurring.

We also examined the role of the constraint rules
(both hard and soft) on efficiency. With all rules
disabled, the training does not complete even one
epoch in more than three hours. Because the num-
ber of valid states is exponential in the number of



64

Precision Recall F1
ProLocal 77.4 22.9 35.3
QRN 55.5 31.3 40.0
EntNet 50.2 33.5 40.2
ProGlobal 46.7 52.4 49.4
ProStruct 74.2 42.1 53.7

Table 1: Results on the prediction task (test set).

Precision Recall F1
ProStruct 70.4 47.8 56.9

- Soft constraints 61.9 47.4 53.7
- Hard constraints† 69.6 47.0 56.1

† Partial ablation, ablated at test only (training without these
is computationally infeasible).

Table 2: Ablating world knowledge on the dev set.

entities, the training is particularly slow on para-
graphs with many entities. In contrast, with all
rules enabled, training takes less than 10 minutes
per epoch. This illustrates that the constraints are
not only contributing to the model scores, but also
helping make the search efficient.

7.2 Ablations and Analysis

To explore the impact of world knowledge, we
also performed two ablations on the dev set: Re-
moving soft constraints (at both training and test
time), and a partial ablation of removing hard con-
straints at test time only - note that hard constraints
cannot be removed during training because model
training time becomes prohibitively large without
them, thus qualifying this second ablation. Table 4
shows that F1 drops when each type of knowledge
is removed, illustrating that they are helping. The
smaller drop for hard constraints suggests that they
have primarily been incorporated into the network
during training due to this ablation being partial.

Qualitatively, we compared dev set examples
where the predicted event sequence changed, com-
paring predictions made without world knowledge
to those made with world knowledge. For read-
ability, we only show the event type predictions
(M ,C,D, and N (shown as "-")) and not their from-
location/to-location arguments. If a prediction
changes from X (without knowledge) to Y (with
knowledge), we write this “X → Y”. For cases
where the prediction changed, we show incorrect
predictions in red, and correct predictions in green.

We first compare predictions made with and
without the BK (corpus-based background knowl-
edge, the soft constraints). Table 3 shows a para-
graph about the process of nuclear-powered elec-

tricity generation, in the problematic prediction of
the generator moving (M) was predicted in the sec-
ond to last sentence. However, the background
knowledge contains no examples of generators be-
ing moved. As a result, it drives the probability
mass away from the move (M) prediction, resulting
in a no state change (N) prediction instead.

Table 4 shows a second example where, with-
out knowledge, no event was predicted for the
spark entity. However, BK contains many exam-
ples of sparks being created (reflecting text about
this topic), shifting the probability mass towards
this prediction, resulting in the correct C (create).

Finally, Table 5 shows an example of a hard con-
straint preventing a nonsensical prediction (namely,
electricity is created after it already exists).

7.3 Error Analysis

There are also many cases where incorrect predic-
tions are made. The main causes are summarized
below, and offer opportunities for future work.

Implicit reference is a challenge for ProStruct,
where an entity affected by an event is not men-
tioned until a later sentence in the paragraph. For
example, in the following ProPara paragraph snip-
pet about combustion engines:

"...(3) A spark ignites fuel...(4) The pres-
sure pushes the piston down...."

both spark and pressure are created in sentence
3, even though pressure is not mentioned until
the subsequent sentence. Recognizing this type of
implicit mention is very hard. It is possible that
BK could help in such situations, particularly if
ignite were often associated with creating pres-
sure in the context of a combustion engines, but we
did not see such examples in practice.

A second challenge is coreference, in particular
when different entities have similar names. For
example, again for combustion, a snippet looks:

...(2) the fuel is injected... (6) the spent

Without vs. with BK
Fuel Heat Turbine Generator Elec.

Fuel produces heat. D C - - -
... Steam spins turbine. - - - - -
Generator is turned. - - - M→ N -
Makes electricity. - - - - C

Table 3: BK improves precision. In a nuclear powered
electricity generation scenario, BK drives the probabil-
ity mass away from the generator movement, as a gen-
erator does not generally change location.



65

Without vs. with BK
Fuel Air Spark

Fuels burns in the chamber. D - -
The burning fuel creates energy. - - -
The upward motion cause air ... - M -
The piston compresses the air. - - -
A spark ignites the fuel and air ... - - N→ C
... ... ... ...

Table 4: BK improves coverage. BK has a strong signal
that a spark is usually created in combustion engines,
shifting the probability mass towards spark-creation.

Without and with constraints
Electricity Signals ...

Electricity enters supply unit. M - -
The supply gives electricity to transistors. C→ D -
... ... ... ...
The energy is used to complete ... - -

Table 5: Hard constraints avoid nonsensical predictions.
In this example without CS-2, the electricity is pre-
dicted to be created after it already exists (impossible).
This mistake is avoided using the constraints.

fuel is ejected. (7) new fuel is injected....

Here fuel and spent fuel are the same entity,
while new fuel is a different entity. Correctly
tracking these references is challenging (in this
case, ProStruct misidentifies (7) as describing an
event on the original fuel/spent fuel).

A third, related problem is pronoun resolution.
For example, in:

The sound continues to bounce off of
things and produce echoes until it is to-
tally absorbed or dissipated.

the word it confuses ProStruct, and it predicts
that the echo (rather than the sound) is destroyed.
We observe several such failure cases.

Finally, we observed BK retrieval failures
when there was appropriate background knowl-
edge that was expressed in a lexically different
way. Consider the example in Table 6 about oil for-
mation. Without BK, the model correctly predicts
that sediment is destroyed (D). However, BK has
few examples of sediment being destroyed, and
so biases the prediction away from this (correct)
choice to an incorrect choice. Further examination
of BK shows that it does in fact have knowledge
about this destruction, but that is expressed using
the word deposit instead (e.g., "deposits break
down"). A soft (neural) means of accessing BK
would help alleviate this problem.

8 Conclusions

Answering questions about procedural text remains
challenging, requiring models of actions and the

Without BK vs. with BK
Algae Plankton Sediment

Algae and plankton die. D D -
The dead algae and plankton ... - - -
The sediment breaks down. - - D→M

Table 6: BK lookup limitation: though BK knows that
deposits can be destroyed (broken down), it does not
equate this with (synonymous) sediments being de-
stroyed, hence biases model away from correct answer.

state changes they produce. Predictions made lo-
cally throughout the text may together be globally
inconsistent or improbable. We have shown how
the predicted effects of actions can be improved by
treating the task as a structured prediction problem,
allowing commonsense knowledge to be injected
to avoid an overall inconsistent or improbable set
of predictions. In particular, we have shown how
two kinds of knowledge can be exploited: hard
constraints to exclude impossible and nonsensical
state changes, and soft constraints to encourage
likely state changes. The resulting system signif-
icantly outperforms previous state-of-the-art sys-
tems on a challenging dataset, and our ablations
and analysis suggest that the knowledge is play-
ing an important role. Our code is available at
https://github.com/allenai/propara.

Acknowledgements

We thank Oren Etzioni for his insightful feedback
and encouragement for this work. We are grateful
to Paul Allen whose long-term vision continues to
inspire our scientific endeavors.

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua

Bengio. 2014. Neural machine translation by
jointly learning to align and translate. CoRR,
abs/1409.0473.

Jonathan Berant, Vivek Srikumar, Pei-Chun Chen,
Abby Vander Linden, Brittany Harding, Brad Huang,
Peter Clark, and Christopher D Manning. 2014.
Modeling biological processes for reading compre-
hension. In Proc. EMNLP’14.

Antoine Bosselut, Omer Levy, Ari Holtzman, Corin
Ennis, Dieter Fox, and Yejin Choi. 2018. Simulat-
ing action dynamics with neural process networks.
6th International Conference on Learning Represen-
tations (ICLR).

Peter Clark, Bhavana Dalvi Mishra, and Niket Tandon.
2018. What happened? Leveraging VerbNet to pre-
dict the effects of actions in procedural text. arXiv
preprint arXiv:1804.05435.

https://github.com/allenai/propara


66

Bhavana Dalvi, Lifu Huang, Niket Tandon, Wen-tau
Yih, and Peter Clark. 2018. Tracking state changes
in procedural text: a challenge dataset and models
for process paragraph comprehension. In Proceed-
ings of the 2018 Conference of the North American
Chapter of the Association for Computational Lin-
guistics: Human Language Technologies, Volume
1 (Long Papers), pages 1595–1604, New Orleans,
Louisiana. Association for Computational Linguis-
tics.

Mikael Henaff, Jason Weston, Arthur Szlam, Antoine
Bordes, and Yann LeCun. 2017. Tracking the world
state with recurrent entity networks. In ICLR.

Chris Hokamp and Qun Liu. 2017. Lexically con-
strained decoding for sequence generation using grid
beam search. In ACL.

Chloé Kiddon, Ganesa Thandavam Ponnuraj, Luke
Zettlemoyer, and Yejin Choi. 2015. Mise en place:
Unsupervised interpretation of instructional recipes.
In Proc. EMNLP’15, pages 982–992.

Chloé Kiddon, Luke Zettlemoyer, and Yejin Choi.
2016. Globally coherent text generation with neural
checklist models. In Proc. EMNLP’16, pages 329–
339.

Jayant Krishnamurthy, Pradeep Dasigi, and Matthew
Gardner. 2017. Neural semantic parsing with type
constraints for semi-structured tables. In EMNLP.

Douglas B Lenat, Mayank Prakash, and Mary Shep-
herd. 1985. Cyc: Using common sense knowledge
to overcome brittleness and knowledge acquisition
bottlenecks. AI magazine, 6(4):65.

Fei Liu and Julien Perez. 2017. Dialog state tracking,
a machine reading approach using memory network.
In EACL.

Ian Niles and Adam Pease. 2001. Towards a standard
upper ontology. In FOIS.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. GloVe: Global vectors for word rep-
resentation. In Proceedings of the 2014 conference
on empirical methods in natural language process-
ing (EMNLP), pages 1532–1543.

Hannah Rashkin, Antoine Bosselut, Maarten Sap,
Kevin Knight, and Yejin Choi. 2018. Modeling
naive psychology of characters in simple common-
sense stories. In ACL.

Aju Thalappillil Scaria, Jonathan Berant, Mengqiu
Wang, Peter Clark, Justin Lewis, Brittany Hard-
ing, and Christopher D. Manning. 2013. Learn-
ing biological processes with global constraints. In
EMNLP.

Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, and
Hannaneh Hajishirzi. 2017a. Bidirectional attention
flow for machine comprehension. In Proc. ICLR’17.

Minjoon Seo, Sewon Min, Ali Farhadi, and Hannaneh
Hajishirzi. 2017b. Query-reduction networks for
question answering. In ICLR.

Spacy. 2018. Spacy tokenizer API reference
page. https://spacy.io/api/annotation#
pos-tagging. Accessed: 2018-04-10.

Zhaopeng Tu, Zhengdong Lu, Yang Liu, Xiaohua Liu,
and Hang Li. 2016. Coverage-based neural machine
translation. In ACL.

Oriol Vinyals, Lukasz Kaiser, Terry Koo, Slav Petrov,
Ilya Sutskever, and Geoffrey E. Hinton. 2015. Gram-
mar as a foreign language. In NIPS.

Tsung-Hsien Wen, Milica Gasic, Nikola Mrksic, Pei
hao Su, David Vandyke, and Steve J. Young. 2015.
Semantically conditioned lstm-based natural lan-
guage generation for spoken dialogue systems. In
EMNLP.

Jason Weston, Antoine Bordes, Sumit Chopra, Alexan-
der M Rush, Bart van Merriënboer, Armand Joulin,
and Tomas Mikolov. 2015. Towards AI-complete
question answering: A set of prerequisite toy tasks.
arXiv preprint arXiv:1502.05698.

Sam Wiseman and Alexander M. Rush. 2016.
Sequence-to-sequence learning as beam-search op-
timization. In EMNLP.

Pengcheng Yin and Graham Neubig. 2017. A syntactic
neural model for general-purpose code generation.
In ACL.

https://spacy.io/api/annotation#pos-tagging
https://spacy.io/api/annotation#pos-tagging

