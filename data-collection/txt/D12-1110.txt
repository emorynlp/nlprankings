










































Semantic Compositionality through Recursive Matrix-Vector Spaces


Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural
Language Learning, pages 1201–1211, Jeju Island, Korea, 12–14 July 2012. c©2012 Association for Computational Linguistics

Semantic Compositionality through Recursive Matrix-Vector Spaces

Richard Socher Brody Huval Christopher D. Manning Andrew Y. Ng
richard@socher.org, {brodyh,manning,ang}@stanford.edu

Computer Science Department, Stanford University

Abstract

Single-word vector space models have been
very successful at learning lexical informa-
tion. However, they cannot capture the com-
positional meaning of longer phrases, prevent-
ing them from a deeper understanding of lan-
guage. We introduce a recursive neural net-
work (RNN) model that learns compositional
vector representations for phrases and sen-
tences of arbitrary syntactic type and length.
Our model assigns a vector and a matrix to ev-
ery node in a parse tree: the vector captures
the inherent meaning of the constituent, while
the matrix captures how it changes the mean-
ing of neighboring words or phrases. This
matrix-vector RNN can learn the meaning of
operators in propositional logic and natural
language. The model obtains state of the art
performance on three different experiments:
predicting fine-grained sentiment distributions
of adverb-adjective pairs; classifying senti-
ment labels of movie reviews and classifying
semantic relationships such as cause-effect or
topic-message between nouns using the syn-
tactic path between them.

1 Introduction

Semantic word vector spaces are at the core of many
useful natural language applications such as search
query expansions (Jones et al., 2006), fact extrac-
tion for information retrieval (Paşca et al., 2006)
and automatic annotation of text with disambiguated
Wikipedia links (Ratinov et al., 2011), among many
others (Turney and Pantel, 2010). In these mod-
els the meaning of a word is encoded as a vector
computed from co-occurrence statistics of a word
and its neighboring words. Such vectors have been
shown to correlate well with human judgments of
word similarity (Griffiths et al., 2007).

…      very                        good                           movie          ...
       (  a  ,  A  )                (  b  ,  B  )                     (  c  ,  C  )  

Recursive Matrix-Vector Model

f(Ba, Ab)=

 Ba=                        Ab=

- vector

- matrix
...

…

Figure 1: A recursive neural network which learns se-
mantic vector representations of phrases in a tree struc-
ture. Each word and phrase is represented by a vector
and a matrix, e.g., very = (a,A). The matrix is applied
to neighboring vectors. The same function is repeated to
combine the phrase very good with movie.

Despite their success, single word vector models
are severely limited since they do not capture com-
positionality, the important quality of natural lan-
guage that allows speakers to determine the meaning
of a longer expression based on the meanings of its
words and the rules used to combine them (Frege,
1892). This prevents them from gaining a deeper
understanding of the semantics of longer phrases or
sentences. Recently, there has been much progress
in capturing compositionality in vector spaces, e.g.,
(Mitchell and Lapata, 2010; Baroni and Zamparelli,
2010; Zanzotto et al., 2010; Yessenalina and Cardie,
2011; Socher et al., 2011c) (see related work). We
extend these approaches with a more general and
powerful model of semantic composition.

We present a novel recursive neural network
model for semantic compositionality. In our context,
compositionality is the ability to learn compositional
vector representations for various types of phrases
and sentences of arbitrary length. Fig. 1 shows an
illustration of the model in which each constituent
(a word or longer phrase) has a matrix-vector (MV)

1201



representation. The vector captures the meaning of
that constituent. The matrix captures how it modifies
the meaning of the other word that it combines with.
A representation for a longer phrase is computed
bottom-up by recursively combining the words ac-
cording to the syntactic structure of a parse tree.
Since the model uses the MV representation with a
neural network as the final merging function, we call
our model a matrix-vector recursive neural network
(MV-RNN).

We show that the ability to capture semantic com-
positionality in a syntactically plausible way trans-
lates into state of the art performance on various
tasks. The first experiment demonstrates that our
model can learn fine-grained semantic composition-
ality. The task is to predict a sentiment distribution
over movie reviews of adverb-adjective pairs such as
unbelievably sad or really awesome. The MV-RNN
is the only model that is able to properly negate sen-
timent when adjectives are combined with not. The
MV-RNN outperforms previous state of the art mod-
els on full sentence sentiment prediction of movie
reviews. The last experiment shows that the MV-
RNN can also be used to find relationships between
words using the learned phrase vectors. The rela-
tionship between words is recursively constructed
and composed by words of arbitrary type in the
variable length syntactic path between them. On
the associated task of classifying relationships be-
tween nouns in arbitrary positions of a sentence the
model outperforms all previous approaches on the
SemEval-2010 Task 8 competition (Hendrickx et al.,
2010). It outperforms all but one of the previous ap-
proaches without using any hand-designed semantic
resources such as WordNet or FrameNet. By adding
WordNet hypernyms, POS and NER tags our model
outperforms the state of the art that uses significantly
more resources. The code for our model is available
at www.socher.org.

2 MV-RNN: A Recursive Matrix-Vector
Model

The dominant approach for building representations
of multi-word units from single word vector repre-
sentations has been to form a linear combination of
the single word representations, such as a sum or
weighted average. This happens in information re-

trieval and in various text similarity functions based
on lexical similarity. These approaches can work
well when the meaning of a text is literally “the sum
of its parts”, but fails when words function as oper-
ators that modify the meaning of another word: the
meaning of “extremely strong” cannot be captured
as the sum of word representations for “extremely”
and “strong.”

The model of Socher et al. (2011c) provided a
new possibility for moving beyond a linear combi-
nation, through use of a matrix W that multiplied
the word vectors (a, b), and a nonlinearity function
g (such as a sigmoid or tanh). They compute the
parent vector p that describes both words as

p = g

(
W

[
a
b

])
(1)

and apply this function recursively inside a binarized
parse tree so that it can compute vectors for multi-
word sequences. Even though the nonlinearity al-
lows to express a wider range of functions, it is al-
most certainly too much to expect a single fixed W
matrix to be able to capture the meaning combina-
tion effects of all natural language operators. After
all, inside the function g, we have the same linear
transformation for all possible pairs of word vectors.

Recent work has started to capture the behavior
of natural language operators inside semantic vec-
tor spaces by modeling them as matrices, which
would allow a matrix for “extremely” to appropri-
ately modify vectors for “smelly” or “strong” (Ba-
roni and Zamparelli, 2010; Zanzotto et al., 2010).
These approaches are along the right lines but so
far have been restricted to capture linear functions
of pairs of words whereas we would like nonlinear
functions to compute compositional meaning repre-
sentations for multi-word phrases or full sentences.

The MV-RNN combines the strengths of both of
these ideas by (i) assigning a vector and a matrix to
every word and (ii) learning an input-specific, non-
linear, compositional function for computing vector
and matrix representations for multi-word sequences
of any syntactic type. Assigning vector-matrix rep-
resentations to all words instead of only to words of
one part of speech category allows for greater flex-
ibility which benefits performance. If a word lacks
operator semantics, its matrix can be an identity ma-
trix. However, if a word acts mainly as an operator,

1202



such as “extremely”, its vector can become close to
zero, while its matrix gains a clear operator mean-
ing, here magnifying the meaning of the modified
word in both positive and negative directions.

In this section we describe the initial word rep-
resentations, the details of combining two words as
well as the multi-word extensions. This is followed
by an explanation of our training procedure.

2.1 Matrix-Vector Neural Word Representation

We represent a word as both a continuous vector
and a matrix of parameters. We initialize all word
vectors x ∈ Rn with pre-trained 50-dimensional
word vectors from the unsupervised model of Col-
lobert and Weston (2008). Using Wikipedia text,
their model learns word vectors by predicting how
likely it is for each word to occur in its context. Sim-
ilar to other local co-occurrence based vector space
models, the resulting word vectors capture syntactic
and semantic information. Every word is also asso-
ciated with a matrix X . In all experiments, we ini-
tialize matrices as X = I+ �, i.e., the identity plus a
small amount of Gaussian noise. If the vectors have
dimensionality n, then each word’s matrix has di-
mensionality X ∈ Rn×n. While the initialization is
random, the vectors and matrices will subsequently
be modified to enable a sequence of words to com-
pose a vector that can predict a distribution over se-
mantic labels. Henceforth, we represent any phrase
or sentence of length m as an ordered list of vector-
matrix pairs ((a,A), . . . , (m,M)), where each pair
is retrieved based on the word at that position.

2.2 Composition Models for Two Words

We first review composition functions for two
words. In order to compute a parent vector p from
two consecutive words and their respective vectors
a and b, Mitchell and Lapata (2010) give as their
most general function: p = f(a, b, R,K),where R
is the a-priori known syntactic relation and K is
background knowledge.

There are many possible functions f . For our
models, there is a constraint on p which is that it
has the same dimensionality as each of the input
vectors. This way, we can compare p easily with
its children and p can be the input to a composition
with another word. The latter is a requirement that
will become clear in the next section. This excludes

tensor products which were outperformed by sim-
pler weighted addition and multiplication methods
in (Mitchell and Lapata, 2010).

We will explore methods that do not require
any manually designed semantic resources as back-
ground knowledge K. No explicit knowledge about
the type of relation R is used. Instead we want the
model to capture this implicitly via the learned ma-
trices. We propose the following combination func-
tion which is input dependent:

p = fA,B(a, b) = f(Ba,Ab) = g

(
W

[
Ba
Ab

])
,

(2)
whereA,B are matrices for single words, the global
W ∈ Rn×2n is a matrix that maps both transformed
words back into the same n-dimensional space. The
element-wise function g could be simply the identity
function but we use instead a nonlinearity such as
the sigmoid or hyperbolic tangent tanh. Such a non-
linearity will allow us to approximate a wider range
of functions beyond purely linear functions. We can
also add a bias term before applying g but omit this
for clarity. Rewriting the two transformed vectors as
one vector z, we get p = g(Wz) which is a single
layer neural network. In this model, the word ma-
trices can capture compositional effects specific to
each word, whereas W captures a general composi-
tion function.

This function builds upon and generalizes several
recent models in the literature. The most related
work is that of (Mitchell and Lapata, 2010; Zan-
zotto et al., 2010) who introduced and explored the
composition function p = Ba + Ab for word pairs.
This model is a special case of Eq. 2 when we set
W = [II] (i.e. two concatenated identity matri-
ces) and g(x) = x (the identity function). Baroni
and Zamparelli (2010) computed the parent vector
of adjective-noun pairs by p = Ab, where A is an
adjective matrix and b is a vector for a noun. This
cannot capture nouns modifying other nouns, e.g.,
disk drive. This model too is a special case of the
above model with B = 0n×n. Lastly, the models of
(Socher et al., 2011b; Socher et al., 2011c; Socher et
al., 2011a) as described above are also special cases
with bothA andB set to the identity matrix. We will
compare to these special cases in our experiments.

1203



…  very      good    movie   …
   (a , A)     (b , B)    (c , C)  

Matrix-Vector Recursive Neural Network

(p1 , P1)

( p2, P2  ) p2  = g(W                )
P2 =  WM

Cp1 
P1c[   ]
P1
C[   ]

Figure 2: Example of how the MV-RNN merges a phrase
with another word at a nonterminal node of a parse tree.

2.3 Recursive Compositions of Multiple Words
and Phrases

This section describes how we extend a word-pair
matrix-vector-based compositional model to learn
vectors and matrices for longer sequences of words.
The main idea is to apply the same function f to
pairs of constituents in a parse tree. For this to
work, we need to take as input a binary parse tree
of a phrase or sentence and also compute matrices at
each nonterminal parent node. The function f can
be readily used for phrase vectors since it is recur-
sively compatible (p has the same dimensionality as
its children). For computing nonterminal phrase ma-
trices, we define the function

P = fM (A,B) = WM

[
A
B

]
, (3)

where WM ∈ Rn×2n, so P ∈ Rn×n just like each
input matrix.

After two words form a constituent in the parse
tree, this constituent can now be merged with an-
other one by applying the same functions f and
fM . For instance, to compute the vectors and ma-
trices depicted in Fig. 2, we first merge words a
and b and their matrices: p1 = f(Ba,Ab), P1 =
fM (A,B). The resulting vector-matrix pair (p1, P1)
can now be used to compute the full phrase when
combining it with word c and computing p2 =
f(Cp1, P1c), P2 = fM (P1, C). The model com-
putes vectors and matrices in a bottom-up fashion,
applying the functions f, fM to its own previous out-
put (i.e. recursively) until it reaches the top node of
the tree which represents the entire sentence.

For experiments with longer sequences we will
compare to standard RNNs and the special case of
the MV-RNN that computes the parent by p = Ab+

Ba, which we name the linear Matrix-Vector Re-
cursion model (linear MVR). Previously, this model
had not been trained for multi-word sequences. Sec.
6 talks about alternatives for compositionality.

2.4 Objective Functions for Training

One of the advantages of RNN-based models is that
each node of a tree has associated with it a dis-
tributed vector representation (the parent vector p)
which can also be seen as features describing that
phrase. We train these representations by adding on
top of each parent node a simple softmax classifier
to predict a class distribution over, e.g., sentiment or
relationship classes: d(p) = softmax(W labelp). If
there are K labels, then d ∈ RK is a K-dimensional
multinomial distribution. For the applications below
(excluding logic), the corresponding error function
E(s, t, θ) that we minimize for a sentence s and its
tree t is the sum of cross-entropy errors at all nodes.

The only other methods that use this type of ob-
jective function are (Socher et al., 2011b; Socher
et al., 2011c), who also combine it with either a
score or reconstruction error. Hence, for compar-
isons to other related work, we need to merge vari-
ations of computing the parent vector p with this
classifier. The main difference is that the MV-RNN
has more flexibility since it has an input specific re-
cursive function fA,B to compute each parent. In
the following applications, we will use the softmax
classifier to predict both sentiment distributions and
noun-noun relationships.

2.5 Learning

Let θ = (W,WM ,W label, L, LM ) be our model pa-
rameters and λ a vector with regularization hyperpa-
rameters for all model parameters. L andLM are the
sets of all word vectors and word matrices. The gra-
dient of the overall objective function J becomes:

∂J

∂θ
=

1

N

∑
(x,t)

∂E(x, t; θ)

∂θ
+ λθ. (4)

To compute this gradient, we first compute all tree
nodes (pi, Pi) from the bottom-up and then take
derivatives of the softmax classifiers at each node
in the tree from the top down. Derivatives are com-
puted efficiently via backpropagation through struc-
ture (Goller and Küchler, 1996). Even though the

1204



objective is not convex, we found that L-BFGS run
over the complete training data (batch mode) mini-
mizes the objective well in practice and convergence
is smooth. For more information see (Socher et al.,
2010).

2.6 Low-Rank Matrix Approximations

If every word is represented by an n-dimensional
vector and additionally by an n × n matrix, the di-
mensionality of the whole model may become too
large with commonly used vector sizes of n = 100.
In order to reduce the number of parameters, we rep-
resent word matrices by the following low-rank plus
diagonal approximation:

A = UV + diag(a), (5)

where U ∈ Rn×r, V ∈ Rr×n, a ∈ Rn and we set
the rank for all experiments to r = 3.

2.7 Discussion: Evaluation and Generality

Evaluation of compositional vector spaces is a com-
plex task. Most related work compares similarity
judgments of unsupervised models to those of hu-
man judgments and aims at high correlation. These
evaluations can give important insights. However,
even with good correlation the question remains
how these models would perform on downstream
NLP tasks such as sentiment detection. We ex-
perimented with unsupervised learning of general
vector-matrix representations by having the MV-
RNN predict words in their correct context. Ini-
tializing the models with these general representa-
tions, did not improve the performance on the tasks
we consider. For sentiment analysis, this is not sur-
prising since antonyms often get similar vectors dur-
ing unsupervised learning from co-occurrences due
to high similarity of local syntactic contexts. In our
experiments, the high prediction performance came
from supervised learning of meaning representations
using labeled data. While these representations are
task-specific, they could be used across tasks in a
multi-task learning setup. However, in order to fairly
compare to related work, we use only the super-
vised data of each task. Before we describe our full-
scale experiments, we analyze the model’s expres-
sive powers.

3 Model Analysis

This section analyzes the model with two proof-of-
concept studies. First, we examine its ability to learn
operator semantics for adverb-adjective pairs. If a
model cannot correctly capture how an adverb op-
erates on the meaning of adjectives, then there’s lit-
tle chance it can learn operators for more complex
relationships. The second study analyzes whether
the MV-RNN can learn simple boolean operators of
propositional logic such as conjunctives or negation
from truth values. Again, if a model did not have this
ability, then there’s little chance it could learn these
frequently occurring phenomena from the noisy lan-
guage of real texts such as movie reviews.

3.1 Predicting Sentiment Distributions of
Adverb-Adjective Pairs

The first study considers the prediction of fine-
grained sentiment distributions of adverb-adjective
pairs and analyzes different possibilities for com-
puting the parent vector p. The results show that
the MV-RNN operators are powerful enough to cap-
ture the operational meanings of various types of ad-
verbs. For example, very is an intensifier, pretty is an
attenuator, and not can negate or strongly attenuate
the positivity of an adjective. For instance not great
is still pretty good and not terrible; see Potts (2010)
for details.

We use a publicly available IMDB dataset of ex-
tracted adverb-adjective pairs from movie reviews.1

The dataset provides the distribution over star rat-
ings: Each consecutive word pair appears a certain
number of times in reviews that have also associ-
ated with them an overall rating of the movie. After
normalizing by the total number of occurrences, one
gets a multinomial distribution over ratings. Only
word pairs that appear at least 50 times are kept. Of
the remaining pairs, we use 4211 randomly sampled
ones for training and a separate set of 1804 for test-
ing. We never give the algorithm sentiment distribu-
tions for single words, and, while single words over-
lap between training and testing, the test set consists
of never before seen word pairs.

The softmax classifier is trained to minimize the
cross entropy error. Hence, an evaluation in terms of
KL-divergence is the most reasonable choice. It is

1http://compprag.christopherpotts.net/reviews.html

1205



Method Avg KL
Uniform 0.327
Mean train 0.193
p = 12(a+ b) 0.103
p = a⊗ b 0.103
p = [a; b] 0.101
p = Ab 0.103
RNN 0.093
Linear MVR 0.092
MV-RNN 0.091

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
fairly annoying

 

 

MV−RNN
RNN

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
fairly awesome

 

 

MV−RNN
RNN

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
fairly sad

 

 

MV−RNN
RNN

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
not annoying

 

 

MV−RNN
RNN

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
not awesome

 

 

MV−RNN
RNN

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
not sad

 

 

Training Pair

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
unbelievably annoying

 

 

MV−RNN
RNN

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
unbelievably awesome

 

 

MV−RNN
RNN

1 2 3 4 5 6 7 8 9 10
0

0.1

0.2

0.3

0.4

0.5
unbelievably sad

 

 

MV−RNN
RNN

Figure 3: Left: Average KL-divergence for predicting sentiment distributions of unseen adverb-adjective pairs of the
test set. See text for p descriptions. Lower is better. The main difference in the KL divergence comes from the few
negation pairs in the test set. Right: Predicting sentiment distributions (over 1-10 stars on the x-axis) of adverb-
adjective pairs. Each row has the same adverb and each column the same adjective. Many predictions are similar
between the two models. The RNN and linear MVR are not able to modify the sentiment correctly: not awesome is
more positive than fairly awesome and not annoying has a similar shape as unbelievably annoying. Predictions of the
linear MVR model are almost identical to the standard RNN for these examples.

defined as KL(g||p) =
∑

i gi log(gi/pi), where g is
the gold distribution and p is the predicted one.

We compare to several baselines and ablations of
the MV-RNN model. An (adverb,adjective) pair is
described by its vectors (a, b) and matrices (A,B).
1 p = 0.5(a+ b), vector average
2. p = a⊗ b, element-wise vector multiplication
3. p = [a; b], vector concatenation
4. p = Ab, similar to (Baroni and Lenci, 2010)
5. p = g(W [a; b]), RNN, similar to Socher et al.
6. p = Ab+Ba, Linear MVR, similar to (Mitchell
and Lapata, 2010; Zanzotto et al., 2010)
7. p = g(W [Ba;Ab]), MV-RNN
The final distribution is always predicted by a
softmax classifier whose inputs p vary for each of
the models. This objective function (see Sec. 2.4)
is different to all previously published work except
that of (Socher et al., 2011c).

We cross-validated all models over regulariza-
tion parameters for word vectors, the softmax clas-
sifier, the RNN parameter W and the word op-
erators (10−4, 10−3) and word vector sizes (n =
6, 8, 10, 12, 15, 20). All models performed best at
vector sizes of below 12. Hence, it is the model’s
power and not the number of parameters that deter-

mines the performance. The table in Fig. 3 shows
the average KL-divergence on the test set. It shows
that the idea of matrix-vector representations for all
words and having a nonlinearity are both impor-
tant. The MV-RNN which combines these two ideas
is best able to learn the various compositional ef-
fects. The main difference in KL divergence comes
from the few negation cases in the test set. Fig. 3
shows examples of predicted distributions. Many
of the predictions are accurate and similar between
the top models. However, only the MV-RNN has
enough expressive power to allow negation to com-
pletely shift the sentiment with respect to an adjec-
tive. A negated adjective carrying negative senti-
ment becomes slightly positive, whereas not awe-
some is correctly attenuated. All three top models
correctly capture the U-shape of unbelievably sad.
This pair peaks at both the negative and positive
spectrum because it is ambiguous. When referring
to the performance of actors, it is very negative, but,
when talking about the plot, many people enjoy sad
and thought-provoking movies. The p = Ab model
does not perform well because it cannot model the
fact that for an adjective like “sad,” the operator of
“unbelievably” behaves differently.

1206



false

false ∧ false

false

true ∧ false

false

false ∧ true

true

true ∧ true

true

¬ false

false

¬ true

Figure 4: Training trees for the MV-RNN to learn propositional operators. The model learns vectors and operators for
∧ (and) and ¬ (negation). The model outputs the exact representations of false and true respectively at the top node.
Hence, the operators can be combined recursively an arbitrary number of times for more complex logical functions.

3.2 Logic- and Vector-based Compositionality

Another natural question is whether the MV-RNN
can, in general, capture some of the simple boolean
logic that is sometimes found in language. In other
words, can it learn some of the propositional logic
operators such as and, or, not in terms of vectors and
matrices from a few examples. Answering this ques-
tion can also be seen as a first step towards bridg-
ing the gap between logic-based, formal semantics
(Montague, 1974) and vector space models.

The logic-based view of language accounts nicely
for compositionality by directly mapping syntac-
tic constituents to lambda calculus expressions. At
the word level, the focus is on function words, and
nouns and adjectives are often defined only in terms
of the sets of entities they denote in the world. Most
words are treated as atomic symbols with no rela-
tion to each other. There have been many attempts
at automatically parsing natural language to a logi-
cal form using recursive compositional rules.

Conversely, vector space models have the attrac-
tive property that they can automatically extract
knowledge from large corpora without supervision.
Unlike logic-based approaches, these models allow
us to make fine-grained statements about the seman-
tic similarity of words which correlate well with hu-
man judgments (Griffiths et al., 2007). Logic-based
approaches are often seen as orthogonal to distribu-
tional vector-based approaches. However, Garrette
et al. (2011) recently introduced a combination of a
vector space model inside a Markov Logic Network.

One open question is whether vector-based mod-
els can learn some of the simple logic encountered
in language such as negation or conjunctives. To
this end, we illustrate in a simple example that our
MV-RNN model and its learned word matrices (op-
erators) have the ability to learn propositional logic
operators such as ∧,∨,¬ (and, or, not). This is a
necessary (though not sufficient) condition for the
ability to pick up these phenomena in real datasets

and tasks such as sentiment detection which we fo-
cus on in the subsequent sections.

Our setup is as follows. We train on 6 strictly
right-branching trees as in Fig. 4. We consider the 1-
dimensional case and fix the representation for true
to (t = 1, T = 1) and false to (f = 0, F = 1).
Fixing the operators to the 1 × 1 identity matrix 1
is essentially ignoring them. The objective is then
to create a perfect reconstruction of (t, T ) or (f, F )
(depending on the formula), which we achieve by
the least squares error between the top vector’s rep-
resentation and the corresponding truth value, e.g.
for ¬false: min ||ptop − t||2 + ||Ptop − T ||2.

As our function g (see Eq. 2), we use a linear
threshold unit: g(x) = max(min(x, 1), 0). Giving
the derivatives computed for the objective function
for the examples in Fig. 4 to a standard L-BFGS op-
timizer quickly yields a training error of 0. Hence,
the output of these 6 examples has exactly one of the
truth representations, making it recursively compati-
ble with further combinations of operators. Thus, we
can combine these operators to construct any propo-
sitional logic function of any number of inputs (in-
cluding xor). Hence, this MV-RNN is complete in
terms of propositional logic.

4 Predicting Movie Review Ratings

In this section, we analyze the model’s performance
on full length sentences. We compare to previous
state of the art methods on a standard benchmark
dataset of movie reviews (Pang and Lee, 2005; Nak-
agawa et al., 2010; Socher et al., 2011c). This
dataset consists of 10,000 positive and negative sin-
gle sentences describing movie sentiment. In this
and the next experiment we use binarized trees from
the Stanford Parser (Klein and Manning, 2003). We
use the exact same setup and parameters (regulariza-
tion, word vector size, etc.) as the published code of
Socher et al. (2011c).2

2www.socher.org

1207



Method Acc.
Tree-CRF (Nakagawa et al., 2010) 77.3
RAE (Socher et al., 2011c) 77.7
Linear MVR 77.1
MV-RNN 79.0

Table 1: Accuracy of classification on full length movie
review polarity (MR).

S. C. Review sentence
1

√
The film is bright and flashy in all the right ways.

0
√

Not always too whimsical for its own good this
strange hybrid of crime thriller, quirky character
study, third-rate romance and female empowerment
fantasy never really finds the tonal or thematic glue
it needs.

0
√

Doesn’t come close to justifying the hype that sur-
rounded its debut at the Sundance film festival two
years ago.

0 x Director Hoffman, his writer and Kline’s agent
should serve detention.

1 x A bodice-ripper for intellectuals.

Table 2: Hard movie review examples of positive (1) and
negative (0) sentiment (S.) that of all methods only the
MV-RNN predicted correctly (C:

√
) or could not classify

as correct either (C: x).

Table 1 shows comparisons to the system of (Nak-
agawa et al., 2010), a dependency tree based classifi-
cation method that uses CRFs with hidden variables.
The state of the art recursive autoencoder model of
Socher et al. (2011c) obtained 77.7% accuracy. Our
new MV-RNN gives the highest performance, out-
performing also the linear MVR (Sec. 2.2).

Table 2 shows several hard examples that only the
MV-RNN was able to classify correctly. None of the
methods correctly classified the last two examples
which require more world knowledge.

5 Classification of Semantic Relationships

The previous task considered global classification of
an entire phrase or sentence. In our last experiment
we show that the MV-RNN can also learn how a syn-
tactic context composes an aggregate meaning of the
semantic relationships between words. In particular,
the task is finding semantic relationships between
pairs of nominals. For instance, in the sentence
“My [apartment]e1 has a pretty large [kitchen]e2.”,
we want to predict that the kitchen and apartment are
in a component-whole relationship. Predicting such

…          the [movie] showed [wars]    …

MV-RNN for Relationship Classification
…

…

Classifier: Message-Topic

Figure 5: The MV-RNN learns vectors in the path con-
necting two words (dotted lines) to determine their se-
mantic relationship. It takes into consideration a variable
length sequence of various word types in that path.

semantic relations is useful for information extrac-
tion and thesaurus construction applications. Many
approaches use features for all words on the path
between the two words of interest. We show that
by building a single compositional semantics for the
minimal constituent including both terms one can
achieve a higher performance.

This task requires the ability to deal with se-
quences of words of arbitrary type and length in be-
tween the two nouns in question.Fig. 5 explains our
method for classifying nominal relationships. We
first find the path in the parse tree between the two
words whose relation we want to classify. We then
select the highest node of the path and classify the
relationship using that node’s vector as features. We
apply the same type of MV-RNN model as in senti-
ment to the subtree spanned by the two words.

We use the dataset and evaluation framework
of SemEval-2010 Task 8 (Hendrickx et al., 2010).
There are 9 ordered relationships (with two direc-
tions) and an undirected other class, resulting in
19 classes. Among the relationships are: message-
topic, cause-effect, instrument-agency (etc. see Ta-
ble 3 for list). A pair is counted as correct if the
order of the words in the relationship is correct.

Table 4 lists results for several competing meth-
ods together with the resources and features used
by each method. We compare to the systems of
the competition which are described in Hendrickx
et al. (2010) as well as the RNN and linear MVR.
Most systems used a considerable amount of hand-
designed semantic resources. In contrast to these
methods, the MV-RNN only needs a parser for the
tree structure and learns all semantics from unla-
beled corpora and the training data. Only the Se-
mEval training dataset is specific to this task, the re-

1208



Relationship Sentence with labeled nouns for which to predict relationships
Cause-Effect(e2,e1) Avian [influenza]e1 is an infectious disease caused by type a strains of the influenza [virus]e2.
Entity-Origin(e1,e2) The [mother]e1 left her native [land]e2 about the same time and they were married in that city.
Message-Topic(e2,e1) Roadside [attractions]e1 are frequently advertised with [billboards]e2 to attract tourists.
Product-Producer(e1,e2) A child is told a [lie]e1 for several years by their [parents]e2 before he/she realizes that ...
Entity-Destination(e1,e2) The accident has spread [oil]e1 into the [ocean]e2.
Member-Collection(e2,e1) The siege started, with a [regiment]e1 of lightly armored [swordsmen]e2 ramming down the gate.
Instrument-Agency(e2,e1) The core of the [analyzer]e1 identifies the paths using the constraint propagation [method]e2.
Component-Whole(e2,e1) The size of a [tree]e1 [crown]e2 is strongly correlated with the growth of the tree.
Content-Container(e1,e2) The hidden [camera]e1, found by a security guard, was hidden in a business card-sized [leaflet

box]e2 placed at an unmanned ATM in Tokyo’s Minato ward in early September.

Table 3: Examples of correct classifications of ordered, semantic relations between nouns by the MV-RNN. Note that
the final classifier is a recursive, compositional function of all the words in the syntactic path between the bracketed
words. The paths vary in length and the words vary in type.

Classifier Feature Sets F1
SVM POS, stemming, syntactic patterns 60.1
SVM word pair, words in between 72.5
SVM POS, WordNet, stemming, syntactic

patterns
74.8

SVM POS, WordNet, morphological fea-
tures, thesauri, Google n-grams

77.6

MaxEnt POS, WordNet, morphological fea-
tures, noun compound system, the-
sauri, Google n-grams

77.6

SVM POS, WordNet, prefixes and other
morphological features, POS, depen-
dency parse features, Levin classes,
PropBank, FrameNet, NomLex-Plus,
Google n-grams, paraphrases, Tex-
tRunner

82.2

RNN - 74.8
Lin.MVR - 73.0
MV-RNN - 79.1
RNN POS,WordNet,NER 77.6
Lin.MVR POS,WordNet,NER 78.7
MV-RNN POS,WordNet,NER 82.4

Table 4: Learning methods, their feature sets and F1
results for predicting semantic relations between nouns.
The MV-RNN outperforms all but one method without
any additional feature sets. By adding three such features,
it obtains state of the art performance.

maining inputs and the training setup are the same
as in previous sentiment experiments.

The best method on this dataset (Rink and
Harabagiu, 2010) obtains 82.2% F1. In order to
see whether our system can improve over this sys-
tem, we added three features to the MV-RNN vec-
tor and trained another softmax classifier. The fea-
tures and their performance increases were POS tags
(+0.9); WordNet hypernyms (+1.3) and named en-

tity tags (NER) of the two words (+0.6). Features
were computed using the code of Ciaramita and Al-
tun (2006).3 With these features, the performance
improved over the state of the art system. Table 3
shows random correct classification examples.

6 Related work

Distributional approaches have become omnipresent
for the recognition of semantic similarity between
words and the treatment of compositionality has
seen much progress in recent years. Hence, we can-
not do justice to the large amount of literature. Com-
monly, single words are represented as vectors of
distributional characteristics – e.g., their frequencies
in specific syntactic relations or their co-occurrences
with given context words (Pado and Lapata, 2007;
Baroni and Lenci, 2010; Turney and Pantel, 2010).
These representations have proven very effective in
sense discrimination and disambiguation (Schütze,
1998), automatic thesaurus extraction (Lin, 1998;
Curran, 2004) and selectional preferences.

There are several sophisticated ideas for com-
positionality in vector spaces. Mitchell and Lap-
ata (2010) present an overview of the most impor-
tant compositional models, from simple vector ad-
dition and component-wise multiplication to tensor
products, and convolution (Metcalfe, 1990). They
measured the similarity between word pairs such
as compound nouns or verb-object pairs and com-
pared these with human similarity judgments. Sim-
ple vector averaging or multiplication performed
best, hence our focus on related baselines above.

3sourceforge.net/projects/supersensetag/

1209



Other important models are tensor products (Clark
and Pulman, 2007), quantum logic (Widdows,
2008), holographic reduced representations (Plate,
1995) and the Compositional Matrix Space model
(Rudolph and Giesbrecht, 2010). RNNs are related
to autoencoder models such as the recursive autoas-
sociative memory (RAAM) (Pollack, 1990) or recur-
rent neural networks (Elman, 1991). Bottou (2011)
and Hinton (1990) discussed related models such as
recursive autoencoders for text understanding.

Our model builds upon and generalizes the mod-
els of (Mitchell and Lapata, 2010; Baroni and Zam-
parelli, 2010; Zanzotto et al., 2010; Socher et al.,
2011c) (see Sec. 2.2). We compare to them in
our experiments. Yessenalina and Cardie (2011) in-
troduce a sentiment analysis model that describes
words as matrices and composition as matrix mul-
tiplication. Since matrix multiplication is associa-
tive, this cannot capture different scopes of nega-
tion or syntactic differences. Their model, is a spe-
cial case of our encoding model (when you ignore
vectors, fix the tree to be strictly branching in one
direction and use as the matrix composition func-
tion P = AB). Since our classifiers are trained on
the vectors, we cannot compare to this approach di-
rectly. Grefenstette and Sadrzadeh (2011) learn ma-
trices for verbs in a categorical model. The trained
matrices improve correlation with human judgments
on the task of identifying relatedness of subject-
verb-object triplets.

7 Conclusion

We introduced a new model towards a complete
treatment of compositionality in word vector spaces.
Our model builds on a syntactically plausible parse
tree and can handle compositional phenomena. The
main novelty of our model is the combination of
matrix-vector representations with a recursive neu-
ral network. It can learn both the meaning vectors of
a word and how that word modifies its neighbors (via
its matrix). The MV-RNN combines attractive the-
oretical properties with good performance on large,
noisy datasets. It generalizes several models in the
literature, can learn propositional logic, accurately
predicts sentiment and can be used to classify se-
mantic relationships between nouns in a sentence.

Acknowledgments

We thank for great discussions about the paper:
John Platt, Chris Potts, Josh Tenenbaum, Mihai Sur-
deanu, Quoc Le and Kevin Miller. The authors
gratefully acknowledges the support of the Defense
Advanced Research Projects Agency (DARPA) Ma-
chine Reading Program under Air Force Research
Laboratory (AFRL) prime contract no. FA8750-09-
C-0181, and the DARPA Deep Learning program
under contract number FA8650-10-C-7020. Any
opinions, findings, and conclusions or recommen-
dations expressed in this material are those of the
authors and do not necessarily reflect the view of
DARPA, AFRL, or the US government.

References
M. Baroni and A. Lenci. 2010. Distributional mem-

ory: A general framework for corpus-based semantics.
Computational Linguistics, 36(4):673–721.

M. Baroni and Roberto Zamparelli. 2010. Nouns
are vectors, adjectives are matrices: Representing
adjective-noun constructions in semantic space. In
EMNLP.

L. Bottou. 2011. From machine learning to machine
reasoning. CoRR, abs/1102.1808.

M. Ciaramita and Y. Altun. 2006. Broad-coverage sense
disambiguation and information extraction with a su-
persense sequence tagger. In EMNLP.

S. Clark and S. Pulman. 2007. Combining symbolic and
distributional models of meaning. In Proceedings of
the AAAI Spring Symposium on Quantum Interaction,
pages 52–55.

R. Collobert and J. Weston. 2008. A unified architecture
for natural language processing: deep neural networks
with multitask learning. In ICML.

J. Curran. 2004. From Distributional to Semantic Simi-
larity. Ph.D. thesis, University of Edinburgh.

J. L. Elman. 1991. Distributed representations, simple
recurrent networks, and grammatical structure. Ma-
chine Learning, 7(2-3).

G. Frege. 1892. Über Sinn und Bedeutung. In Zeitschrift
für Philosophie und philosophische Kritik, 100.

D. Garrette, K. Erk, and R. Mooney. 2011. Integrat-
ing Logical Representations with Probabilistic Infor-
mation using Markov Logic. In Proceedings of the In-
ternational Conference on Computational Semantics.

C. Goller and A. Küchler. 1996. Learning task-
dependent distributed representations by backpropaga-
tion through structure. In Proceedings of the Interna-
tional Conference on Neural Networks (ICNN-96).

1210



E. Grefenstette and M. Sadrzadeh. 2011. Experimental
support for a categorical compositional distributional
model of meaning. In EMNLP.

T. L. Griffiths, J. B. Tenenbaum, and M. Steyvers. 2007.
Topics in semantic representation. Psychological Re-
view, 114.

I. Hendrickx, S.N. Kim, Z. Kozareva, P. Nakov,
D. Ó Séaghdha, S. Padó, M. Pennacchiotti, L. Ro-
mano, and S. Szpakowicz. 2010. Semeval-2010 task
8: Multi-way classification of semantic relations be-
tween pairs of nominals. In Proceedings of the 5th
International Workshop on Semantic Evaluation.

G. E. Hinton. 1990. Mapping part-whole hierarchies into
connectionist networks. Artificial Intelligence, 46(1-
2).

R. Jones, B. Rey, O. Madani, and W. Greiner. 2006. Gen-
erating query substitutions. In Proceedings of the 15th
international conference on World Wide Web.

D. Klein and C. D. Manning. 2003. Accurate unlexical-
ized parsing. In ACL.

D. Lin. 1998. Automatic retrieval and clustering of sim-
ilar words. In Proceedings of COLING-ACL, pages
768–774.

E. J. Metcalfe. 1990. A compositive holographic asso-
ciative recall model. Psychological Review, 88:627–
661.

J. Mitchell and M. Lapata. 2010. Composition in dis-
tributional models of semantics. Cognitive Science,
34(8):1388–1429.

R. Montague. 1974. English as a formal language. Lin-
guaggi nella Societa e nella Tecnica, pages 189–224.

T. Nakagawa, K. Inui, and S. Kurohashi. 2010. Depen-
dency tree-based sentiment classification using CRFs
with hidden variables. In NAACL, HLT.

M. Paşca, D. Lin, J. Bigham, A. Lifchits, and A. Jain.
2006. Names and similarities on the web: fact extrac-
tion in the fast lane. In ACL.

S. Pado and M. Lapata. 2007. Dependency-based con-
struction of semantic space models. Computational
Linguistics, 33(2):161–199.

B. Pang and L. Lee. 2005. Seeing stars: Exploiting class
relationships for sentiment categorization with respect
to rating scales. In ACL, pages 115–124.

T. A. Plate. 1995. Holographic reduced representations.
IEEE Transactions on Neural Networks, 6(3):623–
641.

J. B. Pollack. 1990. Recursive distributed representa-
tions. Artificial Intelligence, 46, November.

C. Potts. 2010. On the negativity of negation. In David
Lutz and Nan Li, editors, Proceedings of Semantics
and Linguistic Theory 20. CLC Publications, Ithaca,
NY.

L. Ratinov, D. Roth, D. Downey, and M. Anderson.
2011. Local and global algorithms for disambiguation
to wikipedia. In ACL.

B. Rink and S. Harabagiu. 2010. UTD: Classifying se-
mantic relations by combining lexical and semantic re-
sources. In Proceedings of the 5th International Work-
shop on Semantic Evaluation.

S. Rudolph and E. Giesbrecht. 2010. Compositional
matrix-space models of language. In ACL.

H. Schütze. 1998. Automatic word sense discrimination.
Computational Linguistics, 24:97–124.

R. Socher, C. D. Manning, and A. Y. Ng. 2010. Learning
continuous phrase representations and syntactic pars-
ing with recursive neural networks. In Proceedings of
the NIPS-2010 Deep Learning and Unsupervised Fea-
ture Learning Workshop.

R. Socher, E. H. Huang, J. Pennington, A. Y. Ng, and
C. D. Manning. 2011a. Dynamic Pooling and Unfold-
ing Recursive Autoencoders for Paraphrase Detection.
In NIPS. MIT Press.

R. Socher, C. Lin, A. Y. Ng, and C.D. Manning. 2011b.
Parsing Natural Scenes and Natural Language with
Recursive Neural Networks. In ICML.

R. Socher, J. Pennington, E. H. Huang, A. Y. Ng, and
C. D. Manning. 2011c. Semi-Supervised Recursive
Autoencoders for Predicting Sentiment Distributions.
In EMNLP.

P. D. Turney and P. Pantel. 2010. From frequency to
meaning: Vector space models of semantics. Journal
of Artificial Intelligence Research, 37:141–188.

D. Widdows. 2008. Semantic vector products: Some ini-
tial investigations. In Proceedings of the Second AAAI
Symposium on Quantum Interaction.

A. Yessenalina and C. Cardie. 2011. Composi-
tional matrix-space models for sentiment analysis. In
EMNLP.

F.M. Zanzotto, I. Korkontzelos, F. Fallucchi, and S. Man-
andhar. 2010. Estimating linear models for composi-
tional distributional semantics. COLING.

1211


