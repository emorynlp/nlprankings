










































A Probabilistic Model of Syntactic and Semantic Acquisition from Child-Directed Utterances and their Meanings


Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics, pages 234–244,
Avignon, France, April 23 - 27 2012. c©2012 Association for Computational Linguistics

A Probabilistic Model of Syntactic and Semantic Acquisition from
Child-Directed Utterances and their Meanings

Tom Kwiatkowski* †
tomk@cs.washington.edu

Sharon Goldwater∗
sgwater@inf.ed.ac.uk

Luke Zettlemoyer†
lsz@cs.washington.edu

Mark Steedman∗
steedman@inf.ed.ac.uk

∗ ILCC, School of Informatics
University of Edinburgh

Edinburgh, EH8 9AB, UK

†Computer Science & Engineering
University of Washington
Seattle, WA, 98195, USA

Abstract

This paper presents an incremental prob-
abilistic learner that models the acquis-
tion of syntax and semantics from a cor-
pus of child-directed utterances paired with
possible representations of their meanings.
These meaning representations approxi-
mate the contextual input available to the
child; they do not specify the meanings of
individual words or syntactic derivations.
The learner then has to infer the meanings
and syntactic properties of the words in the
input along with a parsing model. We use
the CCG grammatical framework and train
a non-parametric Bayesian model of parse
structure with online variational Bayesian
expectation maximization. When tested on
utterances from the CHILDES corpus, our
learner outperforms a state-of-the-art se-
mantic parser. In addition, it models such
aspects of child acquisition as “fast map-
ping,” while also countering previous crit-
icisms of statistical syntactic learners.

1 Introduction

Children learn language by mapping the utter-
ances they hear onto what they believe those ut-
terances mean. The precise nature of the child’s
prelinguistic representation of meaning is not
known. We assume for present purposes that
it can be approximated by compositional logical
representations such as (1), where the meaning is
a logical expression that describes a relationship
have between the person you refers to and the
object another(x, cookie(x)):

Utterance : you have another cookie (1)

Meaning : have(you, another(x, cookie(x)))

Most situations will support a number of plausi-
ble meanings, so the child has to learn in the face

of propositional uncertainty1, from a set of con-
textually afforded meaning candidates, as here:

Utterance : you have another cookie

Candidate
Meanings


have(you, another(x, cookie(x)))

eat(you, your(x, cake(x)))
want(i, another(x, cookie(x)))

The task is then to learn, from a sequence of such
(utterance, meaning-candidates) pairs, the correct
lexicon and parsing model. Here we present a
probabilistic account of this task with an empha-
sis on cognitive plausibility.

Our criteria for plausibility are that the learner
must not require any language-specific informa-
tion prior to learning and that the learning algo-
rithm must be strictly incremental: it sees each
training instance sequentially and exactly once.
We define a Bayesian model of parse structure
with Dirichlet process priors and train this on a
set of (utterance, meaning-candidates) pairs de-
rived from the CHILDES corpus (MacWhinney,
2000) using online variational Bayesian EM.

We evaluate the learnt grammar in three ways.
First, we test the accuracy of the trained model
in parsing unseen utterances onto gold standard
annotations of their meaning. We show that
it outperforms a state-of-the-art semantic parser
(Kwiatkowski et al., 2010) when run with similar
training conditions (i.e., neither system is given
the corpus based initialization originally used by
Kwiatkowski et al.). We then examine the learn-
ing curves of some individual words, showing that
the model can learn word meanings on the ba-
sis of a single exposure, similar to the fast map-
ping phenomenon observed in children (Carey
and Bartlett, 1978). Finally, we show that our

1Similar to referential uncertainty but relating to propo-
sitions rather than referents.

234



learner captures the step-like learning curves for
word order regularities that Thornton and Tesan
(2007) claim children show. This result coun-
ters Thornton and Tesan’s criticism of statistical
grammar learners—that they tend to exhibit grad-
ual learning curves rather than the abrupt changes
in linguistic competence observed in children.

1.1 Related Work
Models of syntactic acquisition, whether they
have addressed the task of learning both syn-
tax and semantics (Siskind, 1992; Villavicencio,
2002; Buttery, 2006) or syntax alone (Gibson
and Wexler, 1994; Sakas and Fodor, 2001; Yang,
2002) have aimed to learn a single, correct, deter-
ministic grammar. With the exception of Buttery
(2006) they also adopt the Principles and Param-
eters grammatical framework, which assumes de-
tailed knowledge of linguistic regularities2. Our
approach contrasts with all previous models in as-
suming a very general kind of linguistic knowl-
edge and a probabilistic grammar. Specifically,
we use the probabilistic Combinatory Categorial
Grammar (CCG) framework, and assume only
that the learner has access to a small set of general
combinatory schemata and a functional mapping
from semantic type to syntactic category. Further-
more, this paper is the first to evaluate a model
of child syntactic-semantic acquisition by parsing
unseen data.

Models of child word learning have focused
on semantics only, learning word meanings from
utterances paired with either sets of concept sym-
bols (Yu and Ballard, 2007; Frank et al., 2008; Fa-
zly et al., 2010) or a compositional meaning rep-
resentation of the type used here (Siskind, 1996).
The models of Alishahi and Stevenson (2008)
and Maurits et al. (2009) learn, as well as word-
meanings, orderings for verb-argument structures
but not the full parsing model that we learn here.

Semantic parser induction as addressed by
Zettlemoyer and Collins (2005, 2007, 2009), Kate
and Mooney (2007), Wong and Mooney (2006,
2007), Lu et al. (2008), Chen et al. (2010),
Kwiatkowski et al. (2010, 2011) and Börschinger
et al. (2011) has the same task definition as the
one addressed by this paper. However, the learn-
ing approaches presented in those previous pa-

2This linguistic use of the term ”parameter” is distinct
from the statistical use found elsewhere in this paper.

pers are not designed to be cognitively plausible,
using batch training algorithms, multiple passes
over the data, and language specific initialisations
(lists of noun phrases and additional corpus statis-
tics), all of which we dispense with here. In
particular, our approach is closely related that of
Kwiatkowski et al. (2010) but, whereas that work
required careful initialisation and multiple passes
over the training data to learn a discriminative
parsing model, here we learn a generative parsing
model without either.

1.2 Overview of the approach
Our approach takes, as input, a corpus of (ut-
terance, meaning-candidates) pairs {(si, {m}i) :
i = 1, . . . , N}, and learns a CCG lexicon Λ and
the probability of each production a → b that
could be used in a parse. Together, these define
a probabilistic parser that can be used to find the
most probable meaning for any new sentence.

We learn both the lexicon and production prob-
abilities from allowable parses of the training
pairs. The set of allowable parses {t} for a sin-
gle (utterance, meaning-candidates) pair consists
of those parses that map the utterance onto one of
the meanings. This set is generated with the func-
tional mapping T :

{t} = T (s,m), (2)
which is defined, following Kwiatkowski et al.
(2010), using only the CCG combinators and a
mapping from semantic type to syntactic category
(presented in in Section 4).

The CCG lexicon Λ is learnt by reading off
the lexical items used in all parses of all training
pairs. Production probabilities are learnt in con-
junction with Λ through the use of an incremen-
tal parameter estimation algorithm, online Varia-
tional Bayesian EM, as described in Section 5.

Before presenting the probabilistic model, the
mapping T , and the parameter training algorithm,
we first provide some background on the meaning
representations we use and on CCG.

2 Background

2.1 Meaning Representations
We represent the meanings of utterances in first-
order predicate logic using the lambda-calculus.
An example logical expression (henceforth also
referred to as a lambda expression) is:

like(eve,mummy) (3)

235



which expresses a logical relationship like be-
tween the entity eve and the entity mummy. In
Section 6.1 we will see how logical expressions
like this are created for a set of child-directed ut-
terances (to use in training our model).

The lambda-calculus uses λ operators to define
functions. These may be used to represent func-
tional meanings of utterances but they may also be
used as a ‘glue language’, to compose elements of
first order logical expressions. For example, the
function λxλy.like(y, x) can be combined with
the object mummy to give the phrasal mean-
ing λy.like(y,mummy) through the lambda-
calculus operation of function application.

2.2 CCG
Combinatory Categorial Grammar (CCG; Steed-
man 2000) is a strongly lexicalised linguistic for-
malism that tightly couples syntax and seman-
tics. Each CCG lexical item in the lexicon Λ is
a triple, written as word ` syntactic category :
logical expression . Examples are:

You ` NP : you
read ` S\NP/NP : λxλy.read(y, x)
the ` NP/N : λf.the(x, f(x))

book ` N : λx.book(x)

A full CCG category X : h has syntactic cate-
gory X and logical expression h. Syntactic cat-
egories may be atomic (e.g., S or NP) or com-
plex (e.g., (S\NP)/NP). Slash operators in com-
plex categories define functions from the range on
the right of the slash to the result on the left in
much the same way as lambda operators do in the
lambda-calculus. The direction of the slash de-
fines the linear order of function and argument.

CCG uses a small set of combinatory rules to
concurrently build syntactic parses and semantic
representations. Two example combinatory rules
are forward (>) and backward (<) application:

X/Y : f Y : g ⇒ X : f(g) (>)
Y : g X\Y : f ⇒ X : f(g) (<)

Given the lexicon above, the phrase “You read the
book” can be parsed using these rules, as illus-
trated in Figure 1 (with additional notation dis-
cussed in the following section)..

CCG also includes combinatory rules of
forward (> B) and backward (< B) composition:

X/Y : f Y/Z : g ⇒X/Z : λx.f(g(x)) (> B)
Y \Z : g X\Y : f ⇒X\Z : λx.f(g(x)) (< B)

3 Modelling Derivations

The objective of our learning algorithm is to
learn the correct parameterisation of a probabilis-
tic model P (s,m, t) over (utterance, meaning,
derivation) triples. This model assigns a proba-
bility to each of the grammar productions a → b
used to build the derivation tree t. The probabil-
ity of any given CCG derivation t with sentence
s and semantics m is calculated as the product of
all of its production probabilities.

P (s,m, t) =
∏

a→b∈t
P (b|a) (4)

For example, the derivation in Figure 1 contains
13 productions, and its probability is the product
of the 13 production probabilities. Grammar pro-
ductions may be either syntactic—used to build a
syntactic derivation tree, or lexical—used to gen-
erate logical expressions and words at the leaves
of this tree.

A syntactic production Ch → R expands a
head node Ch into a result R that is either an
ordered pair of syntactic parse nodes 〈Cl,Cr〉
(for a binary production) or a single parse node
(for a unary production). Only two unary syn-
tactic productions are allowed in the grammar:
START→ A to generate A as the top syntactic
node of a parse tree and A→ [A]lex to indicate
that A is a leaf node in the syntactic derivation
and should be used to generate a logical expres-
sion and word. Syntactic derivations are built by
recursively applying syntactic productions to non-
leaf nodes in the derivation tree. Each syntactic
production Ch → R has conditional probability
P (R|Ch). There are 3 binary and 5 unary syntac-
tic productions in Figure 1.

Lexical productions have two forms. Logical
expressions are produced from leaf nodes in the
syntactic derivation tree Alex → m with condi-
tional probability P (m|Alex). Words are then pro-
duced from these logical expressions with condi-
tional probability P (w|m). An example logical
production from Figure 1 is [NP]lex → you. An
example word production is you→ You.

Every production a → b used in a parse tree t
is chosen from the set of productions that could
be used to expand a head node a. If there are a
finite K productions that could expand a then a
K-dimensional Multinomial distribution parame-
terised by θa can be used to model the categorical

236



START

Sdcl

NP

[NP]lex

you

You

Sdcl\NP

(Sdcl\NP)/NP

[(Sdcl\NP)/NP]lex

λxλy.read(y, x)

read

NP

NP/N

[NP/N]lex

λfλx.the(x, f(x))

the

N

[N]lex

λx.book(x)

book

Figure 1: Derivation of sentence You read the
book with meaning read(you, the(x, book(x))).

choice of production:

b ∼ Multinomial(θa) (5)

However, before training a model of language ac-
quisition the dimensionality and contents of both
the syntactic grammar and lexicon are unknown.
In order to maintain a probability model with
cover over the countably infinite number of pos-
sible productions, we define a Dirichlet Process
(DP) prior for each possible production head a.
For the production head a, DP (αa, Ha) assigns
some probability mass to all possible production
targets {b} covered by the base distribution Ha.

It is possible to use the DP as an infinite prior
from which the parameter set of a finite dimen-
sional Multinomial may be drawn provided that
we can choose a suitable partition of {b}. When
calculating the probability of an (s,m, t) triple,
the choice of this partition is easy. For any given
production head a there is a finite set of usable
production targets {b1, . . . , bk−1} in t. We create
a partition that includes one entry for each of these
along with a final entry {bk, . . . } that includes all
other ways in which a could be expanded in dif-
ferent contexts. Then, by applying the distribution
Ga drawn from the DP to this partition, we get a
parameter vector θa that is equivalent to a draw
from a k dimensional Dirichlet distribution:

Ga ∼ DP (αa, Ha) (6)
θa = (Ga(b1), . . . , Ga(bk−1), Ga({bk, . . . })
∼ Dir(αaH(b1), . . . , αaHa(bk−1), (7)

αaHa({bk, . . . }))

Together, Equations 4-7 describe the joint distri-
bution P (X,S, θ) over the observed training data

X = {(si, {m}i) : i = 1, . . . , N}, the latent vari-
ables S (containing the productions used in each
parse t) and the parsing parameters θ.

4 Generating Parses

The previous section defined a parameterisation
over parses assuming that the CCG lexicon Λ was
known. In practice Λ is empty prior to training
and must be populated with the lexical items from
parses t consistent with training pairs (s, {m}).

The set of allowed parses {t} is defined by the
function T from Equation 2. Here we review the
splitting procedure of Kwiatkowski et al. (2010)
that is used to generate CCG lexical items and de-
scribe how it is used by T to create a packed chart
representation of all parses {t} that are consistent
with s and at least one of the meaning represen-
tations in {m}. In this section we assume that s
is paired at each point with only a single meaning
m. Later we will show how T is used multiple
times to create the set of parses consistent with s
and a set of candidate meanings {m}.

The splitting procedure takes as input a CCG
category X :h, such as NP : a(x, cookie(x)), and
returns a set of category splits. Each category split
is a pair of CCG categories (Cl :ml,Cr :mr) that
can be recombined to give X : h using one of the
CCG combinators in Section 2.2. The CCG cat-
egory splitting procedure has two parts: logical
splitting of the category semantics h; and syntac-
tic splitting of the syntactic category X. Each logi-
cal split of h is a pair of lambda expressions (f, g)
in the following set:

{(f, g) | h = f(g) ∨ h = λx.f(g(x))}, (8)

which means that f and g can be recombined us-
ing either function application or function com-
position to give the original lambda expression
h. An example split of the lambda expression
h = a(x, cookie(x)) is the pair

(λy.a(x, y(x)), λx.cookie(x)), (9)

where λy.a(x, y(x)) applied to λx.cookie(x) re-
turns the original expression a(x, cookie(x)).

Syntactic splitting assigns linear order and syn-
tactic categories to the two lambda expressions f
and g. The initial syntactic category X is split by
a reversal of the CCG application combinators in
Section 2.2 if f and g can be recombined to give

237



Syntactic Category Semantic Type Example Phrase
Sdcl 〈ev, t〉 I took it ` Sdcl :λe.took(i, it, e)
St t I

′m angry ` St :angry(i)
Swh 〈e, 〈ev, t〉〉 Who took it? ` Swh :λxλe.took(x, it, e)
Sq 〈ev, t〉 Did you take it? ` Sq :λe.Q(take(you, it, e))
N 〈e, t〉 cookie `N:λx.cookie(x)
NP e John `NP:john
PP 〈ev, t〉 on John ` PP:λe.on(john, e)

Figure 2: Atomic Syntactic Categories.

h with function application:

{(X/Y : f Y : g), (10)
(Y : g : X\Y : f)|h = f(g)}

or by a reversal of the CCG composition combi-
nators if f and g can be recombined to give hwith
function composition:

{(X/Z : f Z/Y : g, (11)
(Z\Y : g : X\Z : f)|h = λx.f(g(x))}

Unknown category names in the result of a
split (Y in (10) and Z in (11)) are labelled via a
functional mapping cat from semantic type T to
syntactic category:

cat(T ) =

 Atomic(T ) if T ∈ Figure 2cat(T1)/cat(T2) if T = 〈T1, T2〉
cat(T1)\cat(T2) if T = 〈T1, T2〉


which uses the Atomic function illustrated
in Figure 2 to map semantic-type to basic CCG
syntactic category. As an example, the logical
split in (9) supports two CCG category splits, one
for each of the CCG application rules.

(NP/N :λy.a(x, y(x)), N :λx.cookie(x)) (12)

(N :λx.cookie(x), NP\N :λy.a(x, y(x))) (13)

The parse generation algorithm T uses the func-
tion split to generate all CCG category pairs that
are an allowed split of an input category X :h:

{(Cl :ml,Cr :mr)} = split(X :h),

and then packs a chart representation of {t} in a
top-down fashion starting with a single cell entry
Cm :m for the top node shared by all parses {t}.
For the utterance and meaning in (1) the top parse
node, spanning the entire word-string, is

S :have(you, another(x, cookie(x))).

T cycles over all cell entries in increasingly small
spans and populates the chart with their splits. For
any cell entry X :h spanning more than one word
T generates a set of pairs representing the splits of
X :h. For each split (Cl :ml,Cr :mr) and every bi-
nary partition (wi:k, wk:j) of the word-span T cre-
ates two new cell entries in the chart: (Cl :ml)i:k
and (Cr :mr)k:j .

Input : Sentence [w1, . . . , wn], top node Cm :m
Output: Packed parse chart Ch containing {t}
Ch = [ [{}1, . . . , {}n]1, . . . , [{}1, . . . , {}n]n ]
Ch[1][n− 1] = Cm :m
for i = n, . . . , 2; j = 1 . . . (n− i) + 1 do

for X:h ∈ Ch[j][i] do
for (Cl :ml,Cr :mr) ∈ split(X:h) do

for k = 1, . . . , i− 1 do
Ch[j][k]← Cl :ml
Ch[j + k][i− k]← Cr :mr

Algorithm 1: Generating {t} with T .

Algorithm 1 shows how the learner uses T to
generate a packed chart representation of {t} in
the chart Ch. The function T massively overgen-
erates parses for any given natural language. The
probabilistic parsing model introduced in Sec-
tion 3 is used to choose the best parse from the
overgenerated set.

5 Training

5.1 Parameter Estimation
The probabilistic model of the grammar describes
a distribution over the observed training data X,
latent variables S, and parameters θ. The goal of
training is to estimate the posterior distribution:

p(S, θ|X) = p(S,X|θ)p(θ)
p(X)

(14)

which we do with online Variational Bayesian Ex-
pectation Maximisation (oVBEM; Sato (2001),
Hoffman et al. (2010)). oVBEM is an online

238



Bayesian extension of the EM algorithm that
accumulates observation pseudocounts na→b for
each of the productions a → b in the grammar.
These pseudocounts define the posterior over pro-
duction probabilities as follows:

(θa→b1 , . . . , θa→b{k,... })) | X,S ∼ (15)

Dir(αH(b1) + na→b1 , . . . ,

∞∑
j=k

αH(bj) + na→bj )

These pseudocounts are computed in two steps:

oVBE-step For the training pair (si, {m}i)
which supports the set of parses {t}, the expec-
tation E{t}[a → b] of each production a → b is
calculated by creating a packed chart representa-
tion of {t} and running the inside-outside algo-
rithm. This is similar to the E-step in standard
EM apart from the fact that each production is
scored with the current expectation of its parame-
ter weight θ̂i−1a→b, where:

θ̂i−1a→b =
eΨ(αaHa(a→b)+n

i−1
a→b)

e
Ψ
(∑K
{b′} αaHa(a→b′)+n

i−1
a→b′

) (16)
and Ψ is the digamma function (Beal, 2003).

oVBM-step The expectations from the oVBE
step are used to update the pseudocounts in Equa-
tion 15 as follows,

nia→b = n
i−1
a→b + ηi(N × E{t}[a→ b]− ni−1a→b)

(17)
where ηi is the learning rate and N is the size of
the dataset.

5.2 The Training Algorithm
Now the training algorithm used to learn the lex-
icon Λ and pseudocounts {na→b} can be defined.
The algorithm, shown in Algorithm 2, passes over
the training data only once and one training in-
stance at a time. For each (si, {m}i) it uses the
function T |{m}i| times to generate a set of con-
sistent parses {t}′. The lexicon is populated by
using the lex function to read all of the lexical
items off from the derivations in each {t}′. In
the parameter update step, the training algorithm
updates the pseudocounts associated with each of
the productions a → b that have ever been seen
during training according to Equation (17).

Only non-zero pseudocounts are stored in our
model. The count vector is expanded with a new
entry every time a new production is used. While

Input : Corpus D = {(si, {m}i)|i = 1, . . . , N},
Function T , Semantics to syntactic cate-
gory mapping cat, function lex to read
lexical items off derivations.

Output: Lexicon Λ, Pseudocounts {na→b}.
Λ = {}, {t} = {}
for i = 1, . . . , N do
{t}i = {}
for m′ ∈ {m}i do

Cm′ = cat(m′)
{t}′ = T (si,Cm′ :m′)
{t}i = {t}i ∪ {t}′, {t} = {t} ∪ {t}′
Λ = Λ ∪ lex ({t}′)

for a→ b ∈ {t} do
nia→b = n

i−1
a→b + ηi(N × E{t}i [a→ b]−

ni−1a→b)

Algorithm 2: Learning Λ and {na→b}

the parameter update step cycles over all produc-
tions in {t} it is not neccessary to store {t}, just
the set of productions that it uses.

6 Experimental Setup

6.1 Data

The Eve corpus, collected by Brown (1973), con-
tains 14, 124 English utterances spoken to a sin-
gle child between the ages of 18 and 27 months.
These have been hand annotated by Sagae et al.
(2004) with labelled syntactic dependency graphs.
An example annotation is shown in Figure 3.

While these annotations are designed to rep-
resent syntactic information, the parent-child re-
lationships in the parse can also be viewed as a
proxy for the predicate-argument structure of the
semantics. We developed a template based de-
terministic procedure for mapping this predicate-
argument structure onto logical expressions of the
type discussed in Section 2.1. For example, the
dependency graph in Figure 3 is automatically
transformed into the logical expression

λe.have(you,another(y, cookie(y)), e) (18)

∧ on(the(z, table(z)), e),

where e is a Davidsonian event variable used to
deal with adverbial and prepositional attachments.
The deterministic mapping to logical expressions
uses 19 templates, three of which are used in this
example: one for the verb and its arguments, one
for the prepositional attachment and one (used
twice) for the quantifier-noun constructions.

239



SUBJ ROOT DET OBJ JCT DET POBJ

pro|you v|have qn|another n|cookie prep|on det|the n|table
You have another cookie on the table

Figure 3: Syntactic dependency graph from Eve corpus.

This mapping from graph to logical expression
makes use of a predefined dictionary of allowed,
typed, logical constants. The mapping is success-
ful for 31% of the child-directed utterances in the
Eve corpus3. The remaining data is mostly ac-
counted for by one-word utterances that have no
straightforward interpretation in our typed logi-
cal language (e.g. what; okay; alright; no; yeah;
hmm; yes; uhhuh; mhm; thankyou), missing ver-
bal arguments that cannot be properly guessed
from the context (largely in imperative sentences
such as drink the water), and complex noun con-
structions that are hard to match with a small set
of templates (e.g. as top to a jar). We also re-
move the small number of utterances containing
more than 10 words for reasons of computational
efficiency (see discussion in Section 8).

Following Alishahi and Stevenson (2010), we
generate a context set {m}i for each utterance si
by pairing that utterance with its correct logical
expression along with the logical expressions of
the preceding and following (|{m}i|−1)/2 utter-
ances.

6.2 Base Distributions and Learning Rate

Each of the production heads a in the grammar
requires a base distribution Ha and concentration
parameter αa. For word-productions the base dis-
tribution is a geometric distribution over character
strings and spaces. For syntactic-productions the
base distribution is defined in terms of the new
category to be named by cat and the probability
of splitting the rule by reversing either the appli-
cation or composition combinators.

Semantic-productions’ base distributions are
defined by a probabilistic branching process con-
ditioned on the type of the syntactic category.
This distribution prefers less complex logical ex-
pressions. All concentration parameters are set to
1.0. The learning rate for parameter updates is
ηi = (0.8 + i)

−0.5.

3Data available at www.tomkwiat.com/resources.html

0.0 0.2 0.4 0.6 0.8 1.0
Proportion of Data Seen

0.0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

A
cc

ur
ac

y

Our Approach

Our Approach + Guess

UBL1

UBL10

Figure 4: Meaning Prediction: Train on files 1, . . . , n
test on file n+ 1.

7 Experiments

7.1 Parsing Unseen Sentences

We test the parsing model that is learnt by training
on the first i files of the longitudinally ordered Eve
corpus and testing on file i + 1, for i = 1 . . . 19.
For each utterance s′ in the test file we use the
parsing model to predict a meaning m∗ and com-
pare this to the target meaning m′. We report the
proportion of utterances for which the prediction
m∗ is returned correctly both with and without
word-meaning guessing. When a word has never
been seen at training time our parser has the abil-
ity to ‘guess’ a typed logical meaning with place-
holders for constant and predicate names.

For comparison we use the UBL semantic
parser of Kwiatkowski et al. (2010) trained in
a similar setting—i.e., with no language specific
initialisation4. Figure 4 shows accuracy for our
approach with and without guessing, for UBL

4Kwiatkowski et al. (2010) initialise lexical weights in
their learning algorithm using corpus-wide alignment statis-
tics across words and meaning elements. Instead we run
UBL with small positive weight for all lexical items. When
run with Giza++ parameter initialisations, UBL10 achieves
48.1% across folds compared to 49.2% for our approach.

240



when run over the training data once (UBL1) and
for UBL when run over the training data 10 times
(UBL10) as in Kwiatkowski et al. (2010). Each
of the points represents accuracy on one of the
19 test files. All of these results are from parsers
trained on utterances paired with a single candi-
date meaning. The lines of best fit show the up-
ward trend in parser performance over time.

Despite only seeing each training instance
once, our approach, due to its broader lexi-
cal search strategy, outperforms both versions of
UBL which performs a greedy search in the space
of lexicons and requires initialisation with co-
occurence statistics between words and logical
constants to guide this search. These statistics are
not justified in a model of language acquisition
and so they are not used here. The low perfor-
mance of all systems is due largely to the sparsity
of the data with 32.9% of all sentences containing
a previously unseen word.

7.2 Word Learning

Due to the sparsity of the data, the training algo-
rithm needs to be able to learn word-meanings on
the basis of very few exposures. This is also a de-
sirable feature from the perspective of modelling
language acquisition as Carey and Bartlett (1978)
have shown that children have the ability to learn
word meanings on the basis of one, or very few,
exposures through the process of fast mapping.

0 500 1000 1500 2000
0.0

0.2

0.4

0.6

0.8

1.0

P
(m
|w

)

1 Meaning

0 500 1000 1500 2000

3 Meanings

0 500 1000 1500 2000
Number of Utterances

0.0

0.2

0.4

0.6

0.8

1.0

P
(m
|w

)

5 Meanings

0 500 1000 1500 2000
Number of Utterances

7 Meanings

f = 168 a→ λf.a(x, f (x))
f = 10 another→ λf.another(x, f (x))
f = 2 any→ λf.any(x, f (x))

Figure 5: Learning quantifiers with frequency f.

Figure 5 shows the posterior probability of the
correct meanings for the quantifiers ‘a’, ‘another’
and ‘any’ over the course of training with 1, 3,
5 and 7 candidate meanings for each utterance5.
These three words are all of the same class but
have very different frequencies in the training
subset shown (168, 10 and 2 respectively). In all
training settings, the word ‘a’ is learnt gradually
from many observations but the rarer words ‘an-
other’ and ‘any’ are learnt (when they are learnt)
through large updates to the posterior on the ba-
sis of few observations. These large updates re-
sult from a syntactic bootstrapping effect (Gleit-
man, 1990). When the model has great confidence
about the derivation in which an unseen lexical
item occurs, the pseudocounts for that lexical item
get a large update under Equation 17. This large
update has a greater effect on rare words which
are associated with small amounts of probability
mass than it does on common ones that have al-
ready accumulated large pseudocounts. The fast
learning of rare words later in learning correlates
with observations of word learning in children.

7.3 Word Order Learning

Figure 6 shows the posterior probability of the
correct SVO word order learnt from increasing
amounts of training data. This is calculated by
summing over all lexical items containing transi-
tive verb semantics and sampling in the space of
parse trees that could have generated them. With
no propositional uncertainty in the training data
the correct word order is learnt very quickly and
stabilises. As the amount of propositional uncer-
tainty increases, the rate at which this rule is learnt
decreases. However, even in the face of ambigu-
ous training data, the model can learn the cor-
rect word-order rule. The distribution over word
orders also exhibits initial uncertainty, followed
by a sharp convergence to the correct analysis.
This ability to learn syntactic regularities abruptly
means that our system is not subject to the crit-
icisms that Thornton and Tesan (2007) levelled
at statistical models of language acquisition—that
their learning rates are too gradual.

5The term ‘fast mapping’ is generally used to refer to
noun learning. We chose to examine quantifier learning here
as there is a greater variation in quantifier frequencies. Fast
mapping of nouns is also achieved.

241



0 500 1000 1500 2000

Number of Utterances

7 Meanings

0 500 1000 1500 2000

Number of Utterances
0.0

0.2

0.4

0.6

0.8

1.0

P
(w

or
d

or
de

r)

5 Meanings

0 500 1000 1500 2000

3 Meanings

0 500 1000 1500 2000
0.0

0.2

0.4

0.6

0.8

1.0
P

(w
or

d
or

de
r)

1 Meaning

vso
svo

ovs
sov

vos
osv

Figure 6: Learning SVO word order.

8 Discussion

We have presented an incremental model of lan-
guage acquisition that learns a probabilistic CCG
grammar from utterances paired with one or
more potential meanings. The model assumes
no language-specific knowledge, but does assume
that the learner has access to language-universal
correspondences between syntactic and semantic
types, as well as a Bayesian prior encouraging
grammars with heavy reuse of existing rules and
lexical items. We have shown that this model
not only outperforms a state-of-the-art semantic
parser, but also exhibits learning curves similar
to children’s: lexical items can be acquired on a
single exposure and word order is learnt suddenly
rather than gradually.

Although we use a Bayesian model, our ap-
proach is different from many of the Bayesian
models proposed in cognitive science and lan-
guage acquisition (Xu and Tenenbaum, 2007;
Goldwater et al., 2009; Frank et al., 2009; Grif-
fiths and Tenenbaum, 2006; Griffiths, 2005; Per-
fors et al., 2011). These models are intended
as ideal observer analyses, demonstrating what
would be learned by a probabilistically optimal
learner. Our learner uses a more cognitively plau-
sible but approximate online learning algorithm.
In this way, it is similar to other cognitively plau-
sible approximate Bayesian learners (Pearl et al.,
2010; Sanborn et al., 2010; Shi et al., 2010).

Of course, despite the incremental nature of our
learning algorithm, there are still many aspects
that could be criticized as cognitively implausi-

ble. In particular, it generates all parses consistent
with each training instance, which can be both
memory- and processor-intensive. It is unlikely
that children do this once they have learnt at least
some of the target language. In future, we plan
to investigate more efficient parameter estimation
methods. One possibility would be an approxi-
mate oVBEM algorithm in which the expectations
in Equation 17 are calculated according to a high
probability subset of the parses {t}. Another op-
tion would be particle filtering, which has been
investigated as a cognitively plausible method for
approximate Bayesian inference (Shi et al., 2010;
Levy et al., 2009; Sanborn et al., 2010).

As a crude approximation to the context in
which an utterance is heard, the logical represen-
tations of meaning that we present to the learner
are also open to criticism. However, Steedman
(2002) argues that children do have access to
structured meaning representations from a much
older apparatus used for planning actions and we
wish to eventually ground these in sensory input.

Despite the limitations listed above, our ap-
proach makes several important contributions to
the computational study of language acquisition.
It is the first model to learn syntax and seman-
tics concurrently; previous systems (Villavicen-
cio, 2002; Buttery, 2006) learnt categorial gram-
mars from sentences where all word meanings
were known. Our model is also the first to be
evaluated by parsing sentences onto their mean-
ings, in contrast to the work mentioned above and
that of Gibson and Wexler (1994), Siskind (1992)
Sakas and Fodor (2001), and Yang (2002). These
all evaluate their learners on the basis of a small
number of predefined syntactic parameters.

Finally, our work addresses a misunderstand-
ing about statistical learners—that their learn-
ing curves must be gradual (Thornton and Tesan,
2007). By demonstrating sudden learning of word
order and fast mapping, our model shows that sta-
tistical learners can account for sudden changes in
children’s grammars. In future, we hope to extend
these results by examining other learning behav-
iors and testing the model on other languages.

9 Acknowledgements

We thank Mark Johnson for suggesting an analy-
sis of learning rates. This work was funded by the
ERC Advanced Fellowship 24952 GramPlus and
EU IP grant EC-FP7-270273 Xperience.

242



References

Alishahi and Stevenson, S. (2008). A computa-
tional model for early argument structure ac-
quisition. Cognitive Science, 32:5:789–834.

Alishahi, A. and Stevenson, S. (2010). Learning
general properties of semantic roles from usage
data: a computational model. Language and
Cognitive Processes, 25:1.

Beal, M. J. (2003). Variational algorithms for ap-
proximate Bayesian inference. Technical re-
port, Gatsby Institute, UCL.

Börschinger, B., Jones, B. K., and Johnson, M.
(2011). Reducing grounded learning tasks
to grammatical inference. In Proceedings of
the 2011 Conference on Empirical Methods
in Natural Language Processing, pages 1416–
1425, Edinburgh, Scotland, UK. Association
for Computational Linguistics.

Brown, R. (1973). A First Language: the Early
Stages. Harvard University Press, Cambridge
MA.

Buttery, P. J. (2006). Computational models for
first language acquisition. Technical Report
UCAM-CL-TR-675, University of Cambridge,
Computer Laboratory.

Carey, S. and Bartlett, E. (1978). Acquring a sin-
gle new word. Papers and Reports on Child
Language Development, 15.

Chen, D. L., Kim, J., and Mooney, R. J. (2010).
Training a multilingual sportscaster: Using per-
ceptual context to learn language. J. Artif. In-
tell. Res. (JAIR), 37:397–435.

Fazly, A., Alishahi, A., and Stevenson, S. (2010).
A probabilistic computational model of cross-
situational word learning. Cognitive Science,
34(6):1017–1063.

Frank, M., Goodman, S., and Tenenbaum, J.
(2009). Using speakers referential intentions
to model early cross-situational word learning.
Psychological Science, 20(5):578–585.

Frank, M. C., Goodman, N. D., and Tenenbaum,
J. B. (2008). A bayesian framework for cross-
situational word-learning. Advances in Neural
Information Processing Systems 20.

Gibson, E. and Wexler, K. (1994). Triggers. Lin-
guistic Inquiry, 25:355–407.

Gleitman, L. (1990). The structural sources of
verb meanings. Language Acquisition, 1:1–55.

Goldwater, S., Griffiths, T. L., and Johnson, M.
(2009). A Bayesian framework for word seg-
mentation: Exploring the effects of context.
Cognition, 112(1):21–54.

Griffiths, T. L., . T. J. B. (2005). Structure and
strength in causal induction. Cognitive Psy-
chology, 51:354–384.

Griffiths, T. L. and Tenenbaum, J. B. (2006). Op-
timal predictions in everyday cognition. Psy-
chological Science.

Hoffman, M., Blei, D. M., and Bach, F. (2010).
Online learning for latent dirichlet allocation.
In NIPS.

Kate, R. J. and Mooney, R. J. (2007). Learning
language semantics from ambiguous supervi-
sion. In Proceedings of the 22nd Conference
on Artificial Intelligence (AAAI-07).

Kwiatkowski, T., Zettlemoyer, L., Goldwater, S.,
and Steedman, M. (2010). Inducing proba-
bilistic CCG grammars from logical form with
higher-order unification. In Proceedings of the
Conference on Emperical Methods in Natural
Language Processing.

Kwiatkowski, T., Zettlemoyer, L., Goldwater, S.,
and Steedman, M. (2011). Lexical general-
ization in ccg grammar induction for semantic
parsing. In Proceedings of the Conference on
Emperical Methods in Natural Language Pro-
cessing.

Levy, R., Reali, F., and Griffiths, T. (2009). Mod-
eling the effects of memory on human online
sentence processing with particle filters. In Ad-
vances in Neural Information Processing Sys-
tems 21.

Lu, W., Ng, H. T., Lee, W. S., and Zettlemoyer,
L. S. (2008). A generative model for parsing
natural language to meaning representations. In
Proceedings of The Conference on Empirical
Methods in Natural Language Processing.

MacWhinney, B. (2000). The CHILDES project:
tools for analyzing talk. Lawrence Erlbaum,
Mahwah, NJ u.a. EN.

Maurits, L., Perfors, A., and Navarro, D. (2009).
Joint acquisition of word order and word refer-
ence. In Proceedings of the 31th Annual Con-
ference of the Cognitive Science Society.

Pearl, L., Goldwater, S., and Steyvers, M. (2010).
How ideal are we? Incorporating human limi-

243



tations into Bayesian models of word segmen-
tation. pages 315–326, Somerville, MA. Cas-
cadilla Press.

Perfors, A., Tenenbaum, J. B., and Regier, T.
(2011). The learnability of abstract syntactic
principles. Cognition, 118(3):306 – 338.

Sagae, K., MacWhinney, B., and Lavie, A.
(2004). Adding syntactic annotations to tran-
scripts of parent-child dialogs. In Proceed-
ings of the 4th International Conference on
Language Resources and Evaluation. Lisbon,
LREC.

Sakas, W. and Fodor, J. D. (2001). The struc-
tural triggers learner. In Bertolo, S., editor,
Language Acquisition and Learnability, pages
172–233. Cambridge University Press, Cam-
bridge.

Sanborn, A. N., Griffiths, T. L., and Navarro,
D. J. (2010). Rational approximations to ratio-
nal models: Alternative algorithms for category
learning. Psychological Review.

Sato, M. (2001). Online model selection based
on the variational bayes. Neural Computation,
13(7):1649–1681.

Shi, L., Griffiths, T. L., Feldman, N. H., and San-
born, A. N. (2010). Exemplar models as a
mechanism for performing bayesian inference.
Psychonomic Bulletin & Review, 17(4):443–
464.

Siskind, J. M. (1992). Naive Physics, Event Per-
ception, Lexical Semantics, and Language Ac-
quisition. PhD thesis, Massachusetts Institute
of Technology.

Siskind, J. M. (1996). A computational study of
cross-situational techniques for learning word-
to-meaning mappings. Cognition, 61(1-2):1–
38.

Steedman, M. (2000). The Syntactic Process.
MIT Press, Cambridge, MA.

Steedman, M. (2002). Plans, affordances, and
combinatory grammar. Linguistics and Philos-
ophy, 25.

Thornton, R. and Tesan, G. (2007). Categori-
cal acquisition: Parameter setting in universal
grammar. Biolinguistics, 1.

Villavicencio, A. (2002). The acquisition of a
unification-based generalised categorial gram-
mar. Technical Report UCAM-CL-TR-533,

University of Cambridge, Computer Labora-
tory.

Wong, Y. W. and Mooney, R. (2006). Learning for
semantic parsing with statistical machine trans-
lation. In Proceedings of the Human Language
Technology Conference of the NAACL.

Wong, Y. W. and Mooney, R. (2007). Learn-
ing synchronous grammars for semantic pars-
ing with lambda calculus. In Proceedings of
the Association for Computational Linguistics.

Xu, F. and Tenenbaum, J. B. (2007). Word learn-
ing as Bayesian inference. Psychological Re-
view, 114:245–272.

Yang, C. (2002). Knowledge and Learning in Nat-
ural Language. Oxford University Press, Ox-
ford.

Yu, C. and Ballard, D. H. (2007). A unified model
of early word learning: Integrating statisti-
cal and social cues. Neurocomputing, 70(13-
15):2149 – 2165.

Zettlemoyer, L. S. and Collins, M. (2005). Learn-
ing to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In Proceedings of the Conference on
Uncertainty in Artificial Intelligence.

Zettlemoyer, L. S. and Collins, M. (2007). Online
learning of relaxed CCG grammars for pars-
ing to logical form. In Proc. of the Joint Con-
ference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural
Language Learning.

Zettlemoyer, L. S. and Collins, M. (2009). Learn-
ing context-dependent mappings from sen-
tences to logical form. In Proceedings of The
Joint Conference of the Association for Com-
putational Linguistics and International Joint
Conference on Natural Language Processing.

244


