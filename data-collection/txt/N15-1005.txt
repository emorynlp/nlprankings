



















































Randomized Greedy Inference for Joint Segmentation, POS Tagging and Dependency Parsing


Human Language Technologies: The 2015 Annual Conference of the North American Chapter of the ACL, pages 42–52,
Denver, Colorado, May 31 – June 5, 2015. c©2015 Association for Computational Linguistics

Randomized Greedy Inference for Joint Segmentation, POS Tagging and
Dependency Parsing

Yuan Zhang, Chengtao Li, Regina Barzilay
Computer Science and Artificial Intelligence Laboratory

Massachusetts Institute of Technology
{yuanzh, ctli, regina}@csail.mit.edu

Kareem Darwish
ALT Research Group

Qatar Computing Research Institute
kdarwish@qf.org.qa

Abstract

In this paper, we introduce a new approach
for joint segmentation, POS tagging and de-
pendency parsing. While joint modeling of
these tasks addresses the issue of error prop-
agation inherent in traditional pipeline archi-
tectures, it also complicates the inference task.
Past research has addressed this challenge by
placing constraints on the scoring function.
In contrast, we propose an approach that can
handle arbitrarily complex scoring functions.
Specifically, we employ a randomized greedy
algorithm that jointly predicts segmentations,
POS tags and dependency trees. Moreover,
this architecture readily handles different seg-
mentation tasks, such as morphological seg-
mentation for Arabic and word segmentation
for Chinese. The joint model outperforms the
state-of-the-art systems on three datasets, ob-
taining 2.1% TedEval absolute gain against
the best published results in the 2013 SPMRL
shared task.1

1 Introduction

Parsing accuracy is greatly impacted by the qual-
ity of preprocessing steps such as tagging and word
segmentation. Li et al. (2011) report that the dif-
ference between using the gold POS tags and us-
ing the automatic counterparts reaches about 6% in
dependency accuracy. Prior research has demon-
strated that joint prediction alleviates error propaga-
tion inherent in pipeline architectures, where mis-
takes cascade from one task to the next (Bohnet et

1The source code is available at https://github.
com/yuanzh/SegParser.

al., 2013; Tratz, 2013; Hatori et al., 2012; Zhang
et al., 2014a). However, jointly modeling all the
processing tasks inevitably increases inference com-
plexity. Prior work addressed this challenge by in-
troducing constraints on scoring functions to keep
inference tractable (Qian and Liu, 2012).

In this paper, we propose a method for joint pre-
diction that imposes no constraints on the scoring
function. The method is able to handle high-order
and global features for each individual task (e.g.,
parsing), as well as features that capture interactions
between tasks. The algorithm achieves this flexibil-
ity by operating over full assignments that specify
segmentation, POS tags and dependency tree, mov-
ing from one complete configuration to another.

Our approach is based on the randomized greedy
algorithm from our earlier dependency parsing sys-
tem (Zhang et al., 2014b). We extend this algorithm
to jointly predict the segmentation and the POS tags
in addition to the dependency parse. The search
space for the algorithm is a combination of parse
trees and lattices that encode alternative morpho-
logical and POS analyses. The inference algorithm
greedily searches over this space, iteratively mak-
ing local modifications to POS tags and dependency
trees. To overcome local optima, we employ multi-
ple restarts.

This simple, yet powerful approach can be eas-
ily applied to a range of joint prediction tasks. In
prior work, joint models have been designed for a
specific language. For instance, joint models for
Chinese are designed with word segmentation in
mind (Hatori et al., 2012), while algorithms for pro-
cessing Semitic languages are tailored for morpho-

42



logical analysis (Tratz, 2013; Goldberg and Elhadad,
2011). In contrast, we show that our algorithm
can be effortlessly applied to all these distinct lan-
guages. Language-specific characteristics drive the
lattice construction and the feature selection, while
the learning and inference methods are language-
agnostic.

We evaluate our model on three datasets: SPMRL
(Modern Standard Arabic), classical Arabic and
CTB5 (Chinese). Our model consistently outper-
forms state-of-the-art systems designed for these
languages. We obtain a 2.1% TedEval gain against
the best published results in the 2013 SPMRL shared
task (Seddah et al., 2013). The joint model results
in significant gains against its pipeline counterpart,
yielding 2.4% absolute F-score increase in depen-
dency parsing on the same dataset. Our analysis re-
veals that most of this gain comes from the improved
prediction on OOV words.

2 Related Work

Joint Segmentation, POS tagging and Syntactic
Parsing It has been widely recognized that joint
prediction is an appealing alternative for pipeline ar-
chitectures (Goldberg and Tsarfaty, 2008; Hatori et
al., 2012; Habash and Rambow, 2005; Gahbiche-
Braham et al., 2012; Zhang and Clark, 2008; Bohnet
and Nivre, 2012). These approaches have been par-
ticularly prominent for languages with difficult pre-
processing, such as morphologically rich languages
(e.g., Arabic and Hebrew) and languages that re-
quire word segmentation (e.g., Chinese). For the for-
mer, joint prediction models typically rely on a lat-
tice structure to represent alternative morphological
analyses (Goldberg and Tsarfaty, 2008; Tratz, 2013;
Cohen and Smith, 2007). For instance, transition-
based models intertwine operations on the lattice
with operations on a dependency tree. Other joint
architectures are more decoupled: in Goldberg and
Tsarfaty (2008), a lattice is used to derive the best
morphological analysis for each part-of-speech al-
ternative, which is in turn provided to the pars-
ing algorithm. In both cases, tractable inference is
achieved by limiting the representation power of the
scoring function. Our model also uses a lattice to
encode alternative analyses. However, we employ
this structure in a different way. The model samples

the full path from the lattice, which corresponds to
a valid segmentation and POS tagging assignment.
Then the model improves the path and the corre-
sponding tree via a hill-climbing strategy. This ar-
chitecture allows us to incorporate arbitrary features
for segmentation, POS tagging and parsing.

In joint prediction models for Chinese, lattice
structures are not typically used. Commonly these
models are formulated in a transition-based frame-
work at the character level (Zhang and Clark, 2008;
Zhang et al., 2014a; Wang and Xue, 2014). While
this formulation can handle a large space of possible
word segmentations, it can only capture features that
are instantiated based on the stack and queue status.
Our approach offers two advantages over prior work:
(1) we can incorporate arbitrary features for word
segmentation and parsing; (2) we demonstrate that
a lattice-based approach commonly used for other
languages can be effectively utilized for Chinese.

Randomized Greedy Inference Our prior work
has demonstrated that a simple randomized greedy
approach delivers near optimal dependency pars-
ing (Zhang et al., 2014b). Our analysis explains
this performance with the particular properties of the
search space in dependency parsing. We show how
to apply this strategy to a more challenging infer-
ence task and demonstrate that a randomized greedy
algorithm achieves excellent performance in a sig-
nificantly larger search space.

3 Randomized Greedy System for Joint
Prediction

In this section, we introduce our model for joint mor-
phological segmentation, tagging and parsing. Our
description will first assume that word boundaries
are provided (e.g., the case of Arabic). Later, we
will describe how this model can be applied to a
joint prediction task that involves word segmenta-
tion (e.g., Chinese).

3.1 Notation
Let x = {xi}|x|i=1 be a sentence of length |x| that
consists of tokens xi. We use s = {si}|x|i=1 to de-
note a segmentation of all the tokens in sentence x,
and si = {si,j}|si|j=1 to denote a segmentation of the
token xi, where si,j is the jth morpheme of the to-
ken xi. Similarly, we use t, ti and ti,j for the POS

43



w/PRT

w/C

kAn/V

w/C
k/P

An/N

An/C

ti,1 2 Ti,1 = {C, PRT}

ti,2 2 Ti,2 = {V }

Si

Ti = Ti,1 ⇥ Ti,2

1

si = w+ kAn
xi = wkAn

si,1 = w
ti,1ti,1 2 Ti,1 = {C, PRT}

ti,2 2 Ti,2 = {V }

Si

Ti = Ti,1 ⇥ Ti,2

1

= {C,PRT}

ti,1 2 Ti,1 = {C, PRT}

ti,2 2 Ti,2 = {V }

Si

Ti = Ti,1 ⇥ Ti,2

1

Figure 1: Example lattice structures for the Arabic
token “wkAn”. It has two candidate segmentations:
w+kAn or w+k+An. The first segmentation consists
of two morphemes. The first morpheme w has two
candidate POS.

tags for each sentence, token and morpheme. We
use y to denote a dependency tree over morphemes,
and yi,j to denote the head of morpheme si,j . Dur-
ing training, the algorithm is provided with tuples
that specify ground truth values for all the variables
D = {(x, ŝ, t̂, ŷ)}.

We also assume access to a morphological ana-
lyzer and a POS tagger that provide candidate anal-
yses. Specifically, for each token xi, the algorithm is
provided with candidate segmentations Si, and can-
didate POS tags Ti and Ti,j . These alternative anal-
yses are captured in the lattice structure (see Fig-
ure 1 for an example). Finally, we use Y to denote
the set of all valid dependency trees defined over
morphemes.

3.2 Decoding

We parameterize the scoring function as

score(x, s, t, y) = θ · f(x, s, t, y) (1)

where θ is the parameter vector and f(x, s, t, y) is
the feature vector associated with the sentence and
all variables.

The goal of decoding is to find a set of valid val-
ues for (s, t, y) ∈ S × T × Y that maximizes the
score defined in Eq. 1. Our randomized greedy al-
gorithm finds a high scoring assignment for (s, t, y)
via a hill-climbing process with multiple random
restarts. (Section 3.3 describes how the parameters
θ are learned.)

Figure 2 shows the framework of our random-
ized greedy algorithm. First, we draw a full path
from the lattice structure in two steps: (1) sampling
a morphological segmentation s from S; (2) sam-
pling POS tags t for each morpheme. Next, we

sample a dependency tree y from the parse space.
Based on this random starting point, we iteratively
hill-climb t and y in a bottom-up order.2 In our
earlier work (Zhang et al., 2014b), we showed this
strategy guarantees that we can climb to any target
tree in a finite number of steps. We repeat the sam-
pling and the hill-climbing processes above until we
do not find a better solution for K iterations. We
introduce the details of this process below.

SampleSeg and SamplePOS: Given a sentence
x, we first draw segmentations s and POS tags t(0)

from the first-order distribution using the current
learned parameter values. For segmentation, first-
order features only depend on each token xi and its
morphemes si,j . Similarly, for POS, first-order fea-
tures are defined based on si,j and ti,j . The sam-
pling process is straightforward due to the fact that
the candidate sets |Si| and |Ti,j | are both small. We
can enumerate and compute the probabilities propor-
tional to the exponential of the first-order scores as
follows.3

p(si) ∝ exp{θ · f(x, si)}
p(ti,j) ∝ exp{θ · f(x, si, ti,j)}

(2)

SampleTree: Given a random sample of the seg-
mentations s and the POS tags t(0), we draw a ran-
dom tree y(0) from the first-order distribution using
Wilson’s algorithm (Wilson, 1996).4

HillClimbPOS: After sampling the initial values
s, t(0) and y(0), the hill-climbing algorithm improves
the solution via locally greedy changes. The hill-
climbing algorithm iterates between improving the
POS tags and the dependency tree. For POS tagging,
it updates each ti,j in a bottom-up order as follows

ti,j ← arg max
ti,j∈Ti,j

score(x, s, ti,j , t−(i,j), y) (3)

where t−(i,j) are the rest of the POS tags when we
update ti,j .

2We do not hill-climb segmentation, or else we have to
jointly find the optimal t and y, and the resulting computational
cost is too high.

3We notice that the distribution becomes significantly
sharper after training for several epochs. Therefore, we also
smooth the distribution by multiplying the score with a scaling
factor.

4We also smooth the distribution in the same way as in seg-
mentation and POS tagging.

44



Input: parameter θ, sentence x
Output: segmentations s, POS tags t and depen-

dency tree y

1: s← SampleSeg(x)
2: t(0) ← SamplePos(x, s)
3: y(0) ← SampleTree(x, s, t(0))
4: k = 0
5: repeat
6: t(k+1) ← HillClimbPOS(x, s, t(k), y(k))
7: y(k+1) ← HillClimbTree(x, s, t(k+1), y(k))
8: k ← k + 1
9: until no change in this iteration

10: return (s, t(k), y(k))

Figure 2: The hill-climbing algorithm with random
initializations. Details of the sampling and hill-
climbing functions in Line 1-3 and 6-7 are provided
in Section 3.2.

HillClimbTree: We improve the dependency tree
y via a similar hill-climbing process. Specifically,
we greedily update the head yi,j of each morpheme
in a bottom-up order as follows

yi,j ← arg max
yi,j∈Yi,j

score(x, s, t, yi,j , y−(i,j)) (4)

where Yi,j is the set of candidate heads such that
changing yi,j to any candidate does not violate the
tree constraint.

3.3 Training

We learn the parameters θ in a max-margin frame-
work, using on-line updates. For each update, we
need to compute the segmentations, POS tags and
the tree that maximize the cost-augmented score:

(s̃, t̃, ỹ) = arg max
s∈S,t∈T ,y∈Y

{θ·f(x, s, t, y)+Err(s, t, y)}
(5)

whereErr(s, t, y) is the number of errors of (s, t, y)
against the ground truth (ŝ, t̂, ŷ). The parameters are
then updated to guide the selection against the vio-
lation. This is done via standard passive-aggressive
updates (Crammer et al., 2006).

3.4 Adapting to Chinese Joint Prediction

In this section we describe how the proposed model
can be adapted to languages that do not delineate

!
Xinhua News Agency

!
Xinhua

!
society

 !
February  13th

 !
February

!
13th

!
Beijing

!
report

Figure 3: Example lattice structures for the Chi-
nese sentence “新华社北京二月十三日电” (Xin-
hua Press at Beijing reports on February 13th). The
token新华社 has two candidate segmentations: 新
华社 or新华 +社.

words with spaces, and thus require word segmen-
tation. The main difference lies in the construction
of the lattice structure. We employ a state-of-the-art
word segmenter to produce candidate word bound-
aries. We consider boundaries common across all
the top-k candidates as true word boundaries. The
remaining tokens (i.e., strings between these bound-
aries) are treated as words to be further segmented
and labeled with POS tags. Figure 3 shows an ex-
ample of the Chinese word lattice structure we con-
struct. Once the lattice is constructed, the joint pre-
diction model is applied as described above.

4 Features

Segmentation Features For both Arabic and Chi-
nese, each segmentation is represented by its score
from the preprocessing system, and by the corre-
sponding morphemes (or words in Chinese). Fol-
lowing previous work (Zhang and Clark, 2010), we
also add character-based features for Chinese word
segmentation, including the first and the last charac-
ters in the word, and the length of the word.

POS Tag Features Table 1 summarizes the POS
tag features employed by the model. First, we
use the feature templates proposed in our previ-
ous work on Arabic joint parsing and POS correc-
tion (Zhang et al., 2014c). In addition, we incor-
porate character-based features specifically designed
for Chinese. These features are mainly inspired by
previous transition-based models on Chinese joint
POS tagging and word segmentation (Zhang and
Clark, 2010).

Dependency Parsing Features The feature tem-
plates for dependency parsing are mainly drawn
from our previous work (Zhang et al., 2014b). Fig-

45



1-gram
〈t0, w−2〉, 〈t0, w−1〉, 〈t0, w0〉, 〈t0, w1〉, 〈t0, w2〉,
〈t0, w−1, w0〉, 〈t0, w0, w1〉, 〈s(t0)〉, 〈t0, s(t0)〉

2-gram 〈t−1, t0〉, 〈t−2, t0〉, 〈t−1, t0, w−1〉, 〈t−1, t0, w0〉
3-gram

〈t−1, t0, t1〉, 〈t−2, t0, t1, 〉, 〈t−1, t0, t2〉,
〈t−2, t0, t2〉

4-gram
〈t−2, t−1, t0, t+1〉, 〈t−2, t−1, t0, t2〉,
〈t−2, t0, t1, t2〉

5-gram 〈t−2, t−1, t0, t1, t2〉
Character

〈t0, pre1(w0)〉, 〈t0, pre2(w0)〉, 〈t0, suf1(w0)〉,
〈t0, suf2(w0)〉, 〈t0, cn(w0)〉, 〈t0, len(w0)〉

Table 1: POS tag feature templates. t0 and w0 de-
notes the POS tag and the word at the current posi-
tion. t−x and tx denote left and right context tags,
and similarly for words. s(·) denotes the score of
the POS tag produced by the preprocessing tagger.
The last row shows the “Character”-based features
for Chinese. pre1(·) and pre2(·) denote the word
prefixes with one and two characters respectively.
suf 1(·) and suf 2(·) denote the word suffixes simi-
larly. cn(·) denotes the n-th character in the word.
len(·) denotes the length of the word, capped at 5 if
longer.

arc!

h m

consecutive sibling!

h m s

grandparent!

g h m

grand-sibling!

g h m s

tri-siblings!

h m s t

Figure 4: First- to third-order dependency parsing
features.

ure 4 shows the first- to third-order feature templates
that we use in our model. We also use global fea-
tures to capture the adjacent conjuncts agreement in
a coordination structure, and the valency patterns for
each POS category. Note that most dependency fea-
tures are implicitly cross-task in that they include
POS tag and segmentation information. For exam-
ple, the standard feature involves the POS tags of the
words on both ends of the arc.

5 Experimental Setup

5.1 Datasets

We evaluate our model on two Arabic datasets and
one Chinese dataset. For the first Arabic dataset,
we use the dataset used in the Statistical Parsing of

Dataset SPMRL Classical CTB5
Language Arabic Arabic Chinese

Train #sent 14.4k 15.4k 17.5k#token 451k 573k 442k

Dev. #sent 1.8k – 348#token 56.9k – 6.6k

Test. #sent 1.8k 163 348#token 55.6k 7.9k 8.0k

Table 2: Statistics of datasets.

Morphologically Rich Languages (SPMRL) Shared
Task 2013 (Seddah et al., 2013).5 We follow the
official split for training, development and testing
set. We use the core set of 12 POS categories pro-
vided by Marton et al. (2013). In the second Ara-
bic dataset, the training set is a dependency con-
version of the Arabic Treebank, which primarily in-
cludes Modern Standard Arabic (MSA) text. How-
ever, we test on a new corpus, which consists of
classical Arabic text obtained from the Comprehen-
sive Islamic Library (CIS).6 A native Arabic speaker
with background in computational linguistics anno-
tated the morphological segmentation and POS tags.
This corpus is an excellent testbed for a joint model
because classical Arabic may use rather different vo-
cabulary from MSA, while their syntactic grammars
are very similar to each other. Therefore incorporat-
ing syntactic information should be particularly ben-
eficial to morphological segmentation and POS tag-
ging. For Chinese, we use the Chinese Penn Tree-
bank 5.0 (CTB5) and follow the split in previous
work (Zhang and Clark, 2010).

Table 2 summarizes the statistics of the datasets.
For the SPMRL test set, we follow the common
practice which limits the sentence lengths up to
70 (Seddah et al., 2013). For classical Arabic and
Chinese, we evaluate on all the test sentences.

5.2 Generating Lattice Structures

In this section we introduce the methodology for
constructing candidate sets for segmentation and

5This dataset is originally provided by the LDC (Maamouri
et al., 2004), specifically its SPMRL 2013 dependency in-
stance, derived from the Columbia Catib Treebank (Habash and
Roth, 2009; Habash et al., 2009) and extended according to the
SPMRL 2013 extension scheme (Seddah et al., 2013).

6This classical Arabic dataset is publicly available at http:
//farasa.qcri.org/

46



MADA analysis

Word Emlyp
Emly/NOUN+p/NSUFF, gen:f/num:s/per:na
Emly/ADJ+p/NSUFF, gen:f/num:s/per:na

Eml/NOUN+y/NSUFF+p/PRON, gen:m/num:d/per:na

Lattice structure

Emly/NOUN

Emly/ADJ

p/NSUFF
gen:f/num:s/per:na

Eml/NOUN
y/NSUFF

p/PRON
gen:m/num:d/per:na

Figure 5: Example MADA analysis for the word
Emlyp and the corresponding lattice structure.

POS tagging. Table 3 provides statistics on the gen-
erated candidate sets.

SPMRL 2013 Following Marton et al. (2013), we
use the MADA system to generate candidate mor-
phological analyses and POS tags. For each token
in the sentence, MADA provides a list of possible
morphological analyses and POS tags, each associ-
ated with a score. The score of each segmentation or
POS tag equals the highest score of the MADA anal-
ysis in which it appears. In addition, we associate
each segmentation with MADA analyses on gender,
number and person. Figure 5 shows an example of
MADA output for the token Emlyp and the corre-
sponding lattice structure.

Classical Arabic We construct the lattice for this
corpus in a similar fashion to the SPMRL dataset
with two main departures. First, we use the Ara-
bic morphological analyzer developed by Darwish
et al. (2014) because MADA is primarily trained for
MSA and performs poorly on classical Arabic. Sec-
ond, we implement a CRF-based morpheme-level
POS tagger and generate the POS tag candidates for
each morpheme based on their marginal probabili-
ties, truncated by a probability threshold.

CTB5 We first re-train the Stanford Chinese word
segmenter on CTB5 and generate a top-10 list for
each sentence.7 We treat the word boundaries shared
across all the 10 candidates as the confident ones,

7We use 10-fold cross validation to avoid overfitting on the
training set.

Dataset Seg POSF1 Oracle Avg. |Si| F1 Avg. |Ti,j |
SPMRL 99.4 99.8 1.23 96.9 1.71
Classical 92.4 97.0 1.16 82.4 3.01
CTB5 95.3 99.0 1.22 91.4 2.02

Table 3: Quality of the lattice structures on each
dataset. For SPMRL and CTB5, we show the statis-
tics on the development sets. For classical Arabic,
we directly show the statistics on the testing set be-
cause the development set is not available.

and construct the lattice as described in Section 3.4.
Our model then focuses on disambiguating the rest
of the word boundaries in the candidates. To gen-
erate POS candidates, we apply a CRF-based tag-
ger with Chinese-specific features used in previous
work (Hatori et al., 2011).

5.3 Evaluation Measures

Following standard practice in previous work (Ha-
tori et al., 2012; Zhang et al., 2014a), we use F-
score as the evaluation metric for segmentation, POS
tagging and dependency parsing. We report the
morpheme-level F-score for Arabic and the word-
level F-score for Chinese. In addition, we use TedE-
val (Tsarfaty et al., 2012) to evaluate the joint pre-
diction on the SPMRL dataset, because TedEval
score is the only evaluation metric used in the of-
ficial report. We directly use the evaluation tools
provided on the SPMRL official website.8

5.4 Baselines

State-of-the-Art Systems For the SPMRL
dataset, we directly compare with Björkelund et al.
(2013). This system achieves the best TedEval
score in the track of dependency parsing with
predicted information and we directly republish
the official result. We also compute the F-score of
this system on each task using our own evaluation
script.9 For the CTB5 dataset, we directly compare
to the arc-eager system by Zhang et al. (2014a),
which slightly outperforms the arc-standard system
by Hatori et al. (2012).

8http://www.spmrl.org/spmrl2013-sharedtask.html
9F-score evaluation for Arabic is not straightforward due to

the stem changes in the morphological analysis. Therefore, the
comparison of F-scores is only approximate.

47



Model
SPMRL Classical Arabic CTB5

Seg POS Dep TedEval Seg POS Seg POS Dep
Pipeline 99.18 95.76 84.79 92.86 92.37 82.40 97.45 93.42 79.46
Joint 99.52 97.43 87.23 93.87 94.35 84.44 98.04 94.47 82.01
Best Published 96.42 91.66 82.41 91.74 – – 97.76 94.36 81.70

Table 4: Segmentation, POS tagging and unlabeled attachment dependency F-scores (%) and TedEval score
(%) on different datasets. The first line denotes the performance by the pipeline variation of our model.
The second row shows the results by our joint model. “Best Published” includes the best reported re-
sults: Björkelund et al. (2013) for the SPMRL 2013 shared task and Zhang et al. (2014a) for the CTB5
dataset. Note that the POS F-scores are not directly comparable because Björkelund et al. (2013) use a
different POS tagset from us.

Seg POS Dep
0

0.5
1

1.5
2

2.5
3

3.5
4

Seen
OOV

(a) SPMRL

Seg POS
0

2

4

6

8

10 Seen
OOV

(b) Classical Arabic

Seg POS Dep
0
1
2
3
4
5
6
7
8 Seen

OOV

(c) CTB5

Figure 6: Absolute F-score (%) improvement of the joint model over the pipeline counterpart on seen and
out-of-vocabulary (OOV) words.

System Variants We also compare against a
pipeline variation of our model. In our pipeline
model, we predict segmentations and POS tags by
the same system that we use to generate candidates.
The subsequent standard parsing model then oper-
ates on the predicted segmentations and POS tags.

5.5 Experimental Details

Following our earlier work (Zhang et al., 2014b), we
train a first-order classifier to prune the dependency
tree space.10 Following common practice, we aver-
age parameters over all iterations after training with
passive-aggressive online learning algorithm (Cram-
mer et al., 2006; Collins, 2002). We use the same
adaptive random restart strategy as in our earlier
work (Zhang et al., 2014b) and set K = 300. In ad-
dition, we also apply an aggressive early-stop strat-
egy during training for efficiency. If we have found
a violation against the ground truth during the first
50 iterations, we immediately stop and update the

10We set the probability threshold to 0.05 and limit the num-
ber of candidate heads up to 20, which gives a 99.5% pruning
recall on both the SPMRL and the CTB5 development sets.

parameters based on the current violation. The rea-
soning behind this early-stop strategy is that weaker
violations for some training sentences are already
sufficient for separable training sets (Huang et al.,
2012).

6 Results

Comparison to State-of-the-art Systems Table 4
summarizes the performance of our model and the
best published results for the SPMRL and the CTB5
datasets.11 On both datasets, our system outper-
forms the baselines. On the SPMRL 2013 shared
task, our approach yields a 2.1% TedEval score gain
over the top performing system (Björkelund et al.,
2013). We also improve the segmentation and de-
pendency F-scores by 3.1% and 4.8% respectively.
Note that the POS F-scores are not directly com-
parable because Björkelund et al. (2013) use a dif-
ferent POS tagset from us. On the CTB5 dataset,
we outperform the state-of-the-art with respect to all

11We are not aware of any published results on the Classical
Arabic Dataset.

48



0 5 10 15 2085

90

95

100

# MADA Analysis

Sc
or

e 
(%

)

 

 

Seg
Pos
Dep
TedEval

Figure 7: Performance with different sizes of the
candidate sets on the SPMRL dataset. The graph
shows the TedEval and F-scores when considering
the best k analyses by MADA, and the variation is
achieved by changing k.

# Restarts
0 200 400 600 800 1000

Sc
or

e

0.92

0.94

0.96

0.98

1

Figure 8: The normalized score of the output tree as
the function of the number of restarts. We normalize
scores of each sentence by the highest score among
3,000 restarts for this sentence. We show the curve
up to 1,000 restarts because it reaches convergence
after 500 restarts.

tasks: segmentation (0.3%), tagging (0.1%), and de-
pendency parsing (0.3%).12

Impact of the Joint Prediction As Table 4 shows,
our joint prediction model consistently outperforms
the corresponding pipeline model in all three tasks.
This observation is consistent with findings in pre-
vious work (Hatori et al., 2012; Tratz, 2013). We
also observe that gains are higher (2%) on the clas-
sical Arabic dataset, which demonstrates that joint
prediction is particularly helpful in bridging the gap
between MSA and classical Arabic.

12Zhang et al. (2014a) improve the dependency F-score to
82.14% by adding manually annotated intra-word dependency
information. Even without such gold word structure annota-
tions, our model still achieves a comparable result.

Dataset
Seg POS Dep

Seen OOV Seen OOV Seen OOV
SPMRL 48.4 27.8 44.7 15.0 15.9 17.5
Classical 13.8 34.8 4.2 17.2 – –
CTB5 20.3 25.7 14.2 19.9 13.0 15.6

Table 5: F-score error reductions (%) of the joint
model over the pipeline counterpart on seen and
OOV words.

Figure 6 shows the break of the improvement
based on seen and out-of-vocabulary (OOV) words.
As expected, across all languages OOV words bene-
fit more from the joint prediction, as they constitute
a common source of error propagation in a pipeline
model. The extent of improvement depends on the
underlying accuracy of the preprocessing for seg-
mentation and POS tagging on OOV words. For
instance, we observe a higher gain (7%) on Chinese
OOV words which have a 61.5% accuracy when pro-
cessed by the original stand-along POS tagger. On
the SPMRL dataset, the gain on OOV words is lower
(3%), while preprocessing accuracy is higher (82%).
Their error reductions on OOV words are neverthe-
less close to each other. Table 5 summarizes the re-
sults on F-score error reduction.

We also observe that the error reductions of OOV
words/morphemes on the Chinese and the Classi-
cal Arabic dataset are larger than that of the in-
vocabulary counterparts (e.g. 26% vs. 20% on Chi-
nese word segmentation). However, we have the op-
posite observation on the segmentation and POS tag-
ging on the SPMRL dataset (28% vs. 48%). This
can be explained by analyzing the oracle perfor-
mance in which we select the best solution from pos-
sible candidates. The oracle error reduction of OOV
morphemes in the SPMRL dataset is relatively low
(44%), compared to the 61% oracle error reduction
of OOV morphemes in the Classical Arabic dataset.

Impact of the Number of Alternative Analyses
In Figure 7, we plot the performance on the SPMRL
dataset as a function of the number k of MADA
analyses that we use to construct the candidate sets.
For low k, increasing the number of analyses im-
proves performance across all evaluation metrics.
However, the performance converges at around k =
15.

49



Scoremax-Scorelocal
0 10 20 30 40 50

%
 L

oc
al

 O
pt

im
a

0

20

40

60

80

100

Figure 9: Cumulative distribution function (CDF)
for the number of local optima versus the score of
these local optima obtained from each restart, on the
SPMRL dataset. The score captures the difference
between a local optimum and the best one among
3,000 restarts.

Convergence Properties To assess the quality
of the approximation obtained by the randomized
greedy inference, we would like to compare it
against the optimal solution. Following our earlier
work (Zhang et al., 2014b), we use the highest score
among 3,000 restarts for each sentence as a proxy for
the optimal solution. Figure 8 shows the normalized
score of the retrieved solution as a function of the
number of restarts. We observe that most sentences
converge quickly.13 Specifically, more than 97%
of the sentences converge within first 300 restarts.
Since for the vast majority of cases our system con-
verges fast, we achieve a comparable speed to that
of other state-of-the-art joint systems. For example,
our model achieves high performance on Chinese at
about 0.5 sentences per second. The speed is about
the same as that of the transition-based system (Ha-
tori et al., 2012) with beam size 64, the setting that
achieved best accuracy in their work.

Quality of Local Optima Figure 9 shows the cu-
mulative distribution function (CDF) for the num-
ber of local optima versus the score of these local
optima obtained from each restart. More specifi-
cally, the score captures the difference between a lo-
cal optimum and the maximal score among 3,000
restarts. We can see that most of the local op-
tima reached by hill-climbing have scores close to

13As expected, we also observe that convergence is slower
when comparing to standard dependency parsing with a simi-
lar randomized greedy algorithm (Zhang et al., 2014b), because
joint prediction results in a harder inference problem.

the maximum. For instance, about 30% of the lo-
cal optima are identical to the best solution, namely
scoremax − scorelocal = 0.

7 Conclusions

In this paper, we propose a general randomized
greedy algorithm for joint segmentation, POS tag-
ging and dependency parsing. On both Arabic and
Chinese, our model achieves improvement on the
three tasks over state-of-the-art systems and pipeline
variants of our system. In particular, we demonstrate
that OOV words benefits more from the power of
joint prediction. Finally, our experimental results
show that increasing candidate sizes improves per-
formance across all evaluation metrics.

Acknowledgments

This research is developed in a collaboration
of MIT with the Arabic Language Technologies
(ALT) group at Qatar Computing Research Institute
(QCRI) within the Interactive sYstems for Answer
Search (IYAS) project. The authors acknowledge
the support of the U.S. Army Research Office un-
der grant number W911NF-10-1-0533, and of the
DARPA BOLT program. We thank Meishan Zhang
and Anders Björkelund for answering questions and
sharing the outputs of their systems. We also thank
the MIT NLP group and the ACL reviewers for their
comments. Any opinions, findings, conclusions, or
recommendations expressed in this paper are those
of the authors, and do not necessarily reflect the
views of the funding organizations.

References

Anders Björkelund, Ozlem Cetinoglu, Richárd Farkas,
Thomas Mueller, and Wolfgang Seeker. 2013.
(re)ranking meets morphosyntax: State-of-the-art re-
sults from the SPMRL 2013 shared task. In Pro-
ceedings of the Fourth Workshop on Statistical Pars-
ing of Morphologically-Rich Languages, pages 135–
145, Seattle, Washington, USA, October. Association
for Computational Linguistics.

Bernd Bohnet and Joakim Nivre. 2012. A transition-
based system for joint part-of-speech tagging and la-
beled non-projective dependency parsing. In Proceed-
ings of the 2012 Joint Conference on Empirical Meth-
ods in Natural Language Processing and Computa-

50



tional Natural Language Learning, pages 1455–1465.
Association for Computational Linguistics.

Bernd Bohnet, Joakim Nivre, Igor Boguslavsky, Richárd
Farkas, Filip Ginter, and Jan Hajic. 2013. Joint mor-
phological and syntactic analysis for richly inflected
languages. TACL, 1:415–428.

Shay B Cohen and Noah A Smith. 2007. Joint morpho-
logical and syntactic disambiguation. In Proceedings
of EMNLP.

Michael Collins. 2002. Discriminative training meth-
ods for hidden markov models: Theory and experi-
ments with perceptron algorithms. In Proceedings of
the Conference on Empirical Methods in Natural Lan-
guage Processing - Volume 10, EMNLP ’02. Associa-
tion for Computational Linguistics.

Koby Crammer, Ofer Dekel, Joseph Keshet, Shai Shalev-
Shwartz, and Yoram Singer. 2006. Online passive-
aggressive algorithms. The Journal of Machine Learn-
ing Research.

Kareem Darwish, Ahmed Abdelali, and Hamdy
Mubarak. 2014. Using stem-templates to improve
arabic pos and gender/number tagging. In Inter-
national Conference on Language Resources and
Evaluation (LREC-2014).

Souhir Gahbiche-Braham, Hélene Bonneau-Maynard,
Thomas Lavergne, and François Yvon. 2012. Joint
segmentation and pos tagging for arabic using a crf-
based classifier. In LREC, pages 2107–2113.

Yoav Goldberg and Michael Elhadad. 2011. Joint he-
brew segmentation and parsing using a pcfg-la lattice
parser. In Proceedings of the 49th Annual Meeting
of the Association for Computational Linguistics: Hu-
man Language Technologies: short papers-Volume 2,
pages 704–709. Association for Computational Lin-
guistics.

Yoav Goldberg and Reut Tsarfaty. 2008. A single gener-
ative model for joint morphological segmentation and
syntactic parsing. In ACL, pages 371–379. Citeseer.

Nizar Habash and Owen Rambow. 2005. Arabic tok-
enization, part-of-speech tagging and morphological
disambiguation in one fell swoop. In Proceedings of
the 43rd Annual Meeting on Association for Compu-
tational Linguistics, pages 573–580. Association for
Computational Linguistics.

Nizar Habash and Ryan Roth. 2009. Catib: The
columbia arabic treebank. In Proceedings of the ACL-
IJCNLP 2009 Conference Short Papers, pages 221–
224, Suntec, Singapore, August. Association for Com-
putational Linguistics.

Nizar Habash, Reem Faraj, and Ryan Roth. 2009. Syn-
tactic Annotation in the Columbia Arabic Treebank. In
Proceedings of MEDAR International Conference on
Arabic Language Resources and Tools, Cairo, Egypt.

Jun Hatori, Takuya Matsuzaki, Yusuke Miyao, and
Jun’ichi Tsujii. 2011. Incremental joint pos tagging
and dependency parsing in chinese. In IJCNLP, pages
1216–1224. Citeseer.

Jun Hatori, Takuya Matsuzaki, Yusuke Miyao, and
Jun’ichi Tsujii. 2012. Incremental joint approach to
word segmentation, pos tagging, and dependency pars-
ing in chinese. In Proceedings of the 50th Annual
Meeting of the Association for Computational Linguis-
tics: Long Papers-Volume 1, pages 1045–1053. Asso-
ciation for Computational Linguistics.

Liang Huang, Suphan Fayong, and Yang Guo. 2012.
Structured perceptron with inexact search. In Proceed-
ings of the 2012 Conference of the North American
Chapter of the Association for Computational Linguis-
tics: Human Language Technologies, pages 142–151.
Association for Computational Linguistics.

Zhenghua Li, Min Zhang, Wanxiang Che, Ting Liu, Wen-
liang Chen, and Haizhou Li. 2011. Joint models for
chinese pos tagging and dependency parsing. In Pro-
ceedings of the 2011 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1180–
1191. Association for Computational Linguistics, July.

Mohamed Maamouri, Ann Bies, Tim Buckwalter, and
Wigdan Mekki. 2004. The Penn Arabic Treebank:
Building a Large-Scale Annotated Arabic Corpus. In
NEMLAR Conference on Arabic Language Resources
and Tools.

Yuval Marton, Nizar Habash, Owen Rambow, and Sarah
Alkhulani. 2013. Spmrl’13 shared task system:
The cadim arabic dependency parser. In Proceed-
ings of the Fourth Workshop on Statistical Parsing of
Morphologically-Rich Languages, pages 76–80.

Xian Qian and Yang Liu. 2012. Joint chinese word seg-
mentation, pos tagging and parsing. In Proceedings
of the 2012 Joint Conference on Empirical Methods
in Natural Language Processing and Computational
Natural Language Learning, pages 501–511. Associa-
tion for Computational Linguistics.

Djamé Seddah, Reut Tsarfaty, Sandra Kübler, Marie Can-
dito, Jinho D. Choi, Richárd Farkas, Jennifer Fos-
ter, Iakes Goenaga, Koldo Gojenola Galletebeitia,
Yoav Goldberg, Spence Green, Nizar Habash, Marco
Kuhlmann, Wolfgang Maier, Joakim Nivre, Adam
Przepiórkowski, Ryan Roth, Wolfgang Seeker, Yan-
nick Versley, Veronika Vincze, Marcin Woliński, Alina
Wróblewska, and Eric Villemonte de la Clergerie.
2013. Overview of the SPMRL 2013 shared task:
A cross-framework evaluation of parsing morpholog-
ically rich languages. In Proceedings of the Fourth
Workshop on Statistical Parsing of Morphologically-
Rich Languages, pages 146–182, Seattle, Washington,
USA, October. Association for Computational Lin-
guistics.

51



Stephen Tratz. 2013. A cross-task flexible transition
model for arabic tokenization, affix detection, affix
labeling, pos tagging, and dependency parsing. In
Fourth Workshop on Statistical Parsing of Morpholog-
ically Rich Languages, page 34. Citeseer.

Reut Tsarfaty, Joakim Nivre, and Evelina Andersson.
2012. Joint evaluation of morphological segmenta-
tion and syntactic parsing. In Proceedings of the 50th
Annual Meeting of the Association for Computational
Linguistics: Short Papers-Volume 2, pages 6–10. As-
sociation for Computational Linguistics.

Zhiguo Wang and Nianwen Xue. 2014. Joint pos tag-
ging and transition-based constituent parsing in chi-
nese with non-local features. In Proceedings of the
52nd Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
733–742, Baltimore, Maryland, June. Association for
Computational Linguistics.

David Wilson. 1996. Generating random spanning trees
more quickly than the cover time. In Proceedings of
the twenty-eighth annual ACM symposium on Theory
of computing, pages 296–303. ACM.

Yue Zhang and Stephen Clark. 2008. Joint word seg-
mentation and pos tagging using a single perceptron.
In ACL, pages 888–896.

Yue Zhang and Stephen Clark. 2010. A fast decoder
for joint word segmentation and pos-tagging using a
single discriminative model. In Proceedings of the
2010 Conference on Empirical Methods in Natural
Language Processing, pages 843–852. Association for
Computational Linguistics.

Meishan Zhang, Yue Zhang, Wanxiang Che, and Ting
Liu. 2014a. Character-level chinese dependency pars-
ing. In ACL.

Yuan Zhang, Tao Lei, Regina Barzilay, and Tommi
Jaakkola. 2014b. Greed is good if randomized: New
inference for dependency parsing. In EMNLP.

Yuan Zhang, Tao Lei, Regina Barzilay, Tommi Jaakkola,
and Amir Globerson. 2014c. Steps to excellence:
Simple inference with refined scoring of dependency
trees. In ACL.

52


