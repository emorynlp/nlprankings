










































Identifying Multiple Userids of the Same Author


Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 1124–1135,
Seattle, Washington, USA, 18-21 October 2013. c©2013 Association for Computational Linguistics

Identifying Multiple Userids of the Same Author 

 
 

Tieyun Qian Bing Liu 
State Key Laboratory of Software Eng.  

Wuhan University 

Department of Computer Science 

University of Illinois at Chicago 

16 Luojiashan Road 851 South Morgan St., Chicago 

Wuhan, Hubei 430072, China  IL, USA, 60607 

qty@whu.edu.cn liub@cs.uic.edu 

 

  

 

Abstract 

This paper studies the problem of identifying 

users who use multiple userids to post in so-

cial media. Since multiple userids may belong 

to the same author, it is hard to directly apply 

supervised learning to solve the problem. This 

paper proposes a new method, which still uses 

supervised learning but does not require train-

ing documents from the involved userids. In-

stead, it uses documents from other userids 

for classifier building. The classifier can be 

applied to documents of the involved userids. 

This is possible because we transform the 

document space to a similarity space and 

learning is performed in this new space. Our 

evaluation is done in the online review do-

main. The experimental results using a large 

number of userids and their reviews show that 

the proposed method is highly effective. 

1 Introduction 

It is common knowledge that some users in social 

media register multiple accounts/userids to post 

articles, blogs, reviews, etc. There are many rea-

sons for doing this. For example, due to past post-

ings, a user may become despised by others. 

He/she then registers another userid in order to 

regain his/her status. A user may also use multiple 

userids to instigate controversy or debates to popu-

larize a topic to make it “hot” or even just to pro-

mote activities at a website. Yet, a user may also 

use multiple userids to post fake or deceptive opin-

ions to promote or demote some products (Liu, 

2012). It is thus important to develop technologies 

to identify such multi-id users. This paper deals 

with this problem based on writing style and other 

linguistic clues.  

Problem definition: Given a set of userids ID = 

{id1, …, idn} and each idi has a set of documents 

Di, we want to identify userids that belong to the 

same physical author.  

The main related works to ours are in the area of 

authorship attribution (AA), which aims to identify 

authors of documents. AA is often solved using 

supervised learning. Let A = {a1, …, ak} be a set of 

authors (or classes) and each author ai  A has a 

set of training documents Di. A classifier is then 

built to decide the author a of each test document 

d, where a  A. We will discuss this and other re-

lated works in Section 2.  

This supervised AA formulation, however, is 

not suitable for our task because we only have 

userids but not real authors. Since some of the 

userids may belong to the same author, we cannot 

treat each userid as a class because in that case, we 

will be classifying based on userids, which won’t 

help us find authors with multiple userids (see Sec-

tion 7 also).  

This paper proposes a novel algorithm. To sim-

plify the presentation, we assume that at most two 

userids can belong to a single author, but the algo-

rithm can be extended to handle more than two 

userids from the same author. Using this assump-

tion, the algorithm works in two steps:  

1.  Candidate identification: For each userid idi, 

we first find the most likely userid idj (i ≠ j) that 

may have the same author as idi. We call idj the 

candidate of idi. We also call this function can-

did-iden, i.e., idj = candid-iden(idi). For easy 

presentation, here we only use one argument for 
*  The work was mainly done when the first author was visit-

ing the University of Illinois at Chicago.  

1124



candid-iden. In the computation, it needs more 

arguments (see Section 4).  

2.  Candidate confirmation: In the reverse order, 

we apply the function candid-iden on idj, which 

produces idk, i.e., idk = candid-iden(idj). 

Decision making: If k = i, we conclude that idi 

and idj are from the same author. Otherwise, idi 

and idj are not from the same author.   

The key of the algorithm is candid-iden. An ob-

vious approach for candid-iden is to use an infor-

mation retrieval method. We can first split the 

documents Di of each idi into two subsets, a query 

set Qi and a sample set Si. We then compare each 

query document in Qi with each sample document 

in Sj from other userids idj ( ID – {idi}). Cosine 

can be used here for similarity comparison. All the 

similarity scores are then aggregated and used to 

rank the userids in ID – {idi}. The top ranked 

userid is the candidate for idi. Note that partition-

ing the documents of a userid idi into the query set 

Qi and the sample set Si is crucial here. We cannot 

use all documents in Di to compare with all docu-

ments in Dj. If so and we get candid-iden(idi) = idj, 

we will definitely get candid-iden(idj) = idi since 

the similarity function is symmetric.  

This cosine similarity based method, however, 

does not work well (see Section 7). We propose a 

supervised learning method to compute the scores. 

For this, we need to reformulate the problem.  

The idea of this reformulation is to learn in a 

similarity space rather than in the original docu-

ment space as in traditional AA. In the new formu-

lation, each document d is still represented as a 

feature vector, but the vector no longer represents 

the document d itself. Instead, it represents a set of 

similarities between the document d and a query q. 

We call this method learning in the similarity 

space (LSS).  

Specifically, in LSS, each document d is first 

represented with a document space vector (called a 

d-vector) based on the document itself as in the 

traditional classification learning of AA. Each fea-

ture in the d-vector is called a d-feature (docu-

ment-feature). A query document q is represented 

in the same way. We then produce a similarity vec-

tor sv (called s-vector) for d. sv consists of a set of 

similarity values between document d (in a d-

vector) and query q (in a d-vector):  

sv =Sim(d, q), 

where Sim is a similarity function consists of a set 

of similarity measures. Thus, the d-vector for doc-

ument d in the document space is transformed to 

an s-vector sv for d in the similarity space. Each 

feature in sv is called an s-feature. For example, 

we have the following d-vector for query q:  

 q: 1:1 2:1 6:2 

where x:z represents a d-feature x (a word) and its 

frequency z in q. We also have two non-query 

documents, one is d1 which is written by the author 

of query q and the other is d2 which is not written 

by query author q. Their d-vectors are: 

 d1:  1:2 2:1 3:1  d2:  2:2 3:1 5:2   

If we use cosine as the first similarity measure in 

Sim, we can generate an s-feature 1:0.50 for d1 

(cosine(q, d1) = 0.50) and an s-feature 1:0.27 for d2 
(cosine(q, d2) = 0.27). If we have more similarity 

measures more s-features can be produced. The 

resulting two s-vectors for d1 and d2 with their 

class labels, 1 and -1, are as follows:  

 d1: 1 1:0.50 … d2:  -1  1:0.27 … 

Class 1 means “written by author of query q”, also 

called q-positive, and class -1 means “not written 

by author of query q”, also called q-negative.  

LSS gives us a two-class classification problem. 

In this formulation, a test userid and his/her docu-

ments do not have to be seen in training as long as 

a set of known documents from this userid is 

available. Any supervised learning method can be 

used to build a classifier. We use SVM. The result-

ing classifier is employed to compute a score for 

each review to be used in the two-step algorithm 

above to find the candidate for each userid and 

then the userids with the same authors.  

Due to the use of query documents, the LSS 

formulation has some resemblance to document 

ranking based on learning to rank (Li, 2011; Liu, 

2011). However, LSS is very different because we 

turn the problem into a supervised classification 

problem. The key difference between learning to 

rank and classification is that ranking will always 

put some documents at the top even if the desired 

documents do not exist. However, classification 

will not return any document if the desired docu-

ments do not exist in the test data (unless there are 

classification errors). Our Type II experiments in 

Section 7 were specifically designed for testing 

such non-existence situations. 

1125



Using online review as the application domain, 

we conduct experiments on a large number of re-

views and their author/reviewer userids from Am-

azon.com. The results show that the proposed 

algorithm is highly accurate and outperforms three 

strong baselines markedly. 

2 Related Work 

A similar problem was attempted in (Chen et al., 

2004) in the context of open forums where users 

interact with each other in their discussions. Their 

method is based on post relationships and intervals 

between posts. It does not use any linguistic clues. 

It is thus not applicable to domains like online re-

views. Reviews do not involve user interactions 

since each review is independent of other reviews. 

Novak et al. also solved the same problem under 

the name of “Anti-aliasing” (Novak et al., 2004). 

They used a clustering based method which as-

sumed the number of actual authors is known. This 

is unrealistic in practice as there is no way to know 

which author has and does not have multiple ids. 

Our work is also related to authorship attribu-

tion (AA). However, to our knowledge, our prob-

lem has not been attempted in AA. Existing works 

focused on two main themes: finding good writing 

style features, and developing effective classifica-

tion methods. On finding good features (d-features 

in our case), it was found that the most promising 

features are function words (Mosteller, 1964; Ar-

gamon and Levitan, 2004; Argamon et al., 2007) 

and rewrite rules (Halteren et al., 1996). Length 

(Gamon 2004; Graham et al., 2005), richness (Hal-

teren et al., 1996; Koppel and Schler, 2004), punc-

tuations (Graham et al., 2005), character n-grams 

(Grieve, 2007; Hedegaard and Simonsen, 2011), 

word n-grams (Burrows, 1992; Sanderson and 

Guenter 2006), POS n-grams (Gamon, 2004; Hirst 

and Feiguina, 2007), syntactic category pairs (Na-

rayanan et al., 2012) are also useful.  

On classification, numerous methods have been 

tried, e.g., Bayesian analysis (Mosteller, 1964), 

discriminant analysis (Stamatatos et al., 2000), 

PCA (Hoover, 2001), neural networks (Graham et 

al., 2005; Zheng et al., 2006; Graham et al., 2005), 

clustering (Sanderson and Guenter, 2006), decision 

trees (Uzuner and Katz, 2005; Zhao and Zobel, 

2005), regularized least squares classification 

(Narayanan et al., 2012),   and SVM (Diederich et 

al., 2000; Gamon 2004; Koppel and Schler, 2004; 

Hedegaard and Simonsen, 2011). Among them, 

SVM was found to be most accurate (Li et al., 

2006; Kim et al., 2011). Although we also use 

supervised learning, we do not learn in the original 

document space as these existing methods do. The 

transformation is important because it enables us 

to use documents from other authors in training. 

The traditional supervised learning (TSL) cannot 

do that. In our case, the only documents that TSL 

can use for training are the queries in the testing 

set. However, as we will see in our experiments, 

such a method performs poorly.  

Since we use online reviews as our experiment 

domain, our work is related to fake review detec-

tion (Jindal and Liu, 2008) as imposters can use 

multiple userids to post fake reviews. Existing re-

search has proposed many methods to detect fake 

reviewers (Lim et al., 2010; Wang et al., 2011; 

Mukherjee et al., 2012) and fake reviews (Jindal 

and Liu, 2008; Ott et al., 2011, 2012; Li et al., 

2011; Feng et al., 2012). However, none of them 

identifies userids belonging to the same person. 

3 Learning in the Similarity Space 

We now formulate the proposed supervised 

learning in the similarity space (LSS), which will 

be used in the candid-iden function in our algo-

rithm to be discussed in Section 4.  

The key difference between LSS and the classic 

document space learning is in the document repre-

sentation. Another difference is in the testing 

phase. We discuss testing first.  

Test data: We are given: 

 A query q from query author (userid) aq 

 A set of test documents DT = {dt1, …, dtm}. 

Goal: classify the test documents into those au-

thored by aq and those not authored by aq.  

We note the following points:  

i)  This is like a retrieval scenario, but we use su-

pervised learning to perform the task.  

ii) Unlike traditional supervised classification, 

here the test query author aq does not have to 

be used in training. But we are given a query 

document q from aq. Clearly, in practice, we 

can have multiple query documents from aq, 

which we will discuss in Section 4.  

Training document representation: As noted 

earlier, each document is represented with a simi-

larity vector (s-vector) computed using a similarity 

1126



function Sim. Sim takes a query document and a 

non-query document and produces a vector of sim-

ilarity values or s-features to represent the non-

query document. We present the detail below:  

Let the set of training authors be AR = {ar1, .., 

arn}. Each author ari has a set of documents DRi. 

Each document in DRi is first represented with a 

document vector (or d-vector). The algorithm for 

producing the training set, called s-training set, is 

given in Figure 1.  

We randomly select a small set of queries Qi 

from documents DRi of each author ari (lines 1, 

and 2). For each query qij  Qi (line 3), it selects a 

set of documents DRij also from DRi (excluding qij) 

of the same author (line 4) to be the positive doc-

uments for qij, called q-positive and labeled 1. 

Then, for each document drijk in DRij, a q-positive 

s-training example with the label 1 is generated for 

drijk by computing the similarities of qij and drijk 

using the similarity function Sim (lines 5, 6). In 

line 7, it selects a set of documents DRij,rest from 

other authors to be the negative documents for qij, 

called q-negative and labeled -1. For each docu-

ment drijk,rest in DRij,rest (line 8), a q-negative s-

training example with label -1 is generated for drijk 

by computing the similarities of qij and drijk,rest us-

ing Sim (line 9). How to select Qi, DRij and DRij,rest 

(lines 2, 4 and 7) is left open intentionally to give 

flexibility in implementation.  

This formulation gives us a two-class classifica-

tion problem. The classes are 1 (q-positive mean-

ing “written by author of query qij”) and -1 (q-

negative meaning “not written by author of query 

qij.”  Figure 2 shows what the s-training data looks 

like. For easy presentation, we assume that there 

are k queries in every Qi, and p documents in every 

DRij and u documents in every DRij,rest. The num-

ber of authors is n. Each author ari generates 

k×(p+u) s-training examples. As we will see in 

Section 7, k can be very small, even 1. 

Complexity: In the worst case, every document 

1. For each document set Di of idi  ID do 
2.  partition Di into two subsets:    
 (1) query set Qi and (2) sample set Si;   

3. For each document set Di of idi  ID do 
 // step 1: candidate identification 
4. idj = candid-iden(idi, ID), i < j; 
 // step 2: candidate confirmation  
5. idk = candid-iden(idj, ID), k ≠ j; 

6. If k = i then idi and idj are from the same author 
8. else  idi and idj are not from the same author  

Figure 3: Identifying userids from the same authors 

Function candidate-iden(idi, ID) 

1. For each sample document set Sj of idj  ID-{idi} do 
2.  pcount[idj],  psum[idj], psqsum[idj], max[idj] = 0; 

3.  For each query qi  Qi do 

4. For each sample sjf  Sj do 
5.  ssjf = <(idi, qi), (Sim(sjf, qi), ?)>;   
6.  Classify ssjf  using the classifier built earlier; 
7. If ssjf is classified positive, i.e., 1 then 
8.  pcount[idj] = pcount[idj] + 1; 
9.  psum[idj] = psum[idj] + ssjf.score 
10 psqsum[idj] = psqsum[idj] + (ssjf.score)2 
11. If ssif.score > max[idj] then 
12. max[idj] = srjf.score 

// Four methods to decide which idj is the candidate for idi 

13. If for all idj  ID-{idi}, pcount[idi] = 0 then 

14.  ])(max[maxarg
}{

j
idIDid

idcid
ij 

  

15. Else )
||

][
(maxarg

}{ j

j

idIDid S

idpcount
cid

ij 

  // 1. Voting 

16. )
||

][
(maxarg

}{ j

j

idIDid S

idpsum
cid

ij 

  // 2. ScoreSum 

17. )
||

])[(
(maxarg

2

}{ j

j

idIDid S

idpsum
cid

ij 

  // 3. ScoreSqSum 

18.         ])(max[maxarg
}{

j
idIDid

idcid
ij 

  // 4. ScoreMax 

19. return cid; 

Figure 4: Identifying the candidate 

1. For each author ari  AR 

2. select a set of query documents Qi   DRi  

3.  For each query qij  Qi  

 // produce positive s-training examples 

4. select a set of documents from author ari  

 DRij  DRi – {qij} 

5. For each document drijk  DRij  

6. produce an s-training example for drijk,  

 (Sim(drijk, qij), 1) 

 // produce negative s-training examples 

7. select a set of documents from the rest of authors  

 DRij,rest  (DR1  …  DRn) – DRi  

8. For each document drijk,rest  DRij,rest  

9. produce an s-training example for drijk,rest,  

 (Sim(drijk,rest, qij), -1) 

Figure 1: Generating s-training examples 

//  Author ar1 –  

// positive (1) s-training examples 

(Sim(dr111, q11), 1),  …,  (Sim(dr11p, q11), 1)  

… 

(Sim(dr1k1, q1k), 1),   …,   (Sim(dr1kp, q1k), 1)  

// negative (-1) s-training examples 

(Sim(dr111.rest, q11), -1),  …,  (Sim(dr11u.rest, q11), -1)  

… 

(Sim(dr1k1.rest, q1k), -1),  …,   (Sim(dr1ku.rest, q1k), -1)  

… 

Figure 2: s-training examples 

1127



can serve as a query or a non-query document. 

Then we need to compute all pairwise document 

similarities. If the number of training documents is 

m, the complexity is O(m2), which is both space 

and computation expensive. However, in practice, 

we don’t need all pairwise comparisons. Only a 

small subset is sufficient (see Section 7).  

Test document representation: Like training 

documents, test documents are represented as s-

vectors as well in the similarity space.  

Given a query q from author aq and a set of test 

documents DT, each test document dti is converted 

to a s-vector svi = Sim(dti, q). To reflect svi is com-

puted based on query q from author aq, a s-test 

case is thus represented as <(aq, q), (svi, ?)>.  

Training: A binary classifier is learned using the 

s-training data. Each s-training example is repre-

sented with (sv, y), where sv is an s-vector and y 

( {1, -1}) is its class. Any supervised learning 

algorithm, e.g., SVM, can be applied.  

Testing: The classifier is applied to each s-test 

case <(aq, q), (svi, ?)> (where svi = S(dti, q)) to 

give it a class q-positive or q-negative. Note that 

the classifier is only applied on svi.  

In most cases, classification based on a single que-

ry is inaccurate. Using multiple queries of an au-

thor can classify much more accurately.   

4 Identify Userids of the Same Author 

We now expand the sketch of the two-step algo-

rithm in Section 1 based on the problem statement 

in Section 1. The algorithm is given in Figure 3.   

Lines 1-2 partitions the documents set Di of 

each idi in ID = {id1, id2, …, idn}, the set of userids 

that we are working on. How to do the partition is 

flexible (see Section 7). Line 4 is the step 1 of 

candidate identification, and line 5 is the step2 of 

candidate confirmation. Lines 6-8 is the decision 

making of step 2 (see Section 1). Line 6 produced 

a classification score using the classifier described 

in Section 3. The key function here is candid-iden. 

Its algorithm is in Figure 4.  

The candid-iden function takes two arguments: 

the query userid idi and the whole set of userids 

ID. It classifies each sample ssjf in sample set Sj of 

idj  ID-{idi} to positive (qi-positive) or negative 

(qi-negative) (lines 4, 5, 6). We then aggregate the 

classification results to determine which userid is 

likely to have the same author as idi.   

One simple aggregation method is voting. We 

count the total number of positive classifications of 

the sample documents of each userid in ID-{idi}. 

The userid idj with the highest count is the candi-

date cid which may share the same author as query 

idi. cid is returned as the candidate.  

There are also other methods, which can depend 

on what output value the classifier produces. Here 

we propose four methods including the voting 

method above. The other three methods requires 

the classifier to produces a prediction score, which 

reflects the positive and negative certainty. Many 

classification algorithms produce such a score. 

Here we use SVM. For each classification, SVM 

outputs a positive or negative score indicating the 

certainty that the test case is positive or negative.  

To save space, all four alternative methods are 

given in Figure 4. Line 2 initializes some variables 

for recording the aggregated values for the final 

decision making. The four methods are as follows:  

1). Voting: For each sample from userid idj, if it is 

classified as positive, one vote/count is added 

to pcount[idj]. The userid with the highest 

pcount is regarded as the candidate userid, cid 

(line 15). Note that the normalization is ap-

plied because the sizes of the sample sets Sj 

can be different for different userids. Lines 13 

and 14 mean that if all documents of all 

userids are classified as negative (pcount[idj] = 

0, which also implies psum[idj] = psqsum[idj] 

= 0), we use method 4).  

2). ScoreSum: This method works similarly to the 

voting method above except that instead of 

counting positive classifications, this method 

sums up all scores of positive classifications in 

psum[idj] for each userid (line 9). The decision 

is also made similarly (line 16). 

3). ScoreSqSum: This method works similarly to 

ScoreSum above except that it sums up the 

squared scores of positive classifications in 

psqsum[idj] for each userid (line 10). The deci-

sion is also made similarly (line 17). 

4). ScoreMax: This method works similarly to the 

voting method as well except that it finds the 

maximum classification score for the docu-

ments of each userid (lines 11 and 12). The 

decision is made in line 18. 

5 D-features 

We now compute s-features (similarity features) 

1128



for each non-query document based on a query 

document. Since s-features are calculated using d-

features of a non-query document and a query 

document, we thus discuss d-features first, which 

are extracted from each document itself. We em-

ploy 26 d-features in four categories: length d-

features, frequency based d-features, tf.idf based d-

features, and richness d-features. Although many 

features below have been used in various tasks 

before, our key contribution is solving a new prob-

lem based on a new learning formulation (LSS).  

Length d-feature: We derive three length d-

features from each raw document: (1) average 

sentence length (in terms of word count); (2) 

average word length (in terms of character count 

in one word); (3) average document length (in 

terms of word count in one document). 

Frequency based d-features: We extract lexical, 

syntactic, and stylistic tokens from the raw docu-

ments and the parsed syntactic trees to produce the 

following features:   

 Lexical tokens: word unigrams 

 Syntactic tokens: content-independent struc-
tures: POS n-grams (1 ≤ n ≤ 3) and rewrite rules 

(Halteren et al., 1996; Hirst and Feiguina, 2007). 

A rewrite rule is a combination of a node and 

its immediate constituents in a syntactic tree. 

For example, the rewrite rule for "the best 

book" is NP->DT+JJS+NN. 

 Common stylistic token: K-length word (1 ≤ K ≤ 
15), punctuations, and 157 function words 

(www.flesl.net/Vocabulary/SinglewordLists/fun

ctionwordlist.php). 

 Review specific stylistic tokens: These tokens 
reflect styles of reviews: all cap words, pairs of 

quotation marks, pairs of brackets, exclamatory 

marks, contractions, two or more consecutive 

non-alphanumeric characters, model auxilia-

ries (e.g., should, must), word “recommend” or 

“recommended”, sentences with the first letter 

capitalized, sentences starting with This is (this 

is) or This was (this was). We then treat these 

tokens as pseudo-words and count their fre-

quency to form frequency d-features.  

TF-IDF based d-feature: For the tokens listed in 

the frequency based features above, we also com-

pute their tf.idf values. We list these two kinds of 

d-features separately because they will be used for 

different s-features later.  

Richness d-features: This is a set of vocabulary 

richness functions used to quantify the diversity of 

vocabulary in text (Holmes and Forsyth, 1995). In 

this paper, we apply them to the counts of word 

unigrams, POS n-grams (1 ≤ n ≤ 3), and rewrite 

rules. Here POS n-grams and rewrite rules are 

treated as pseudo-words. Let T be the total number 

of tokens (words or pseudo-words), and V(T) be 

the number of different tokens in a document, v be 

the highest frequency of occurrence of a token, and 

V(m, T) be the number of tokens which occur m 

times in the document. We use the following six 

richness measures (Yule, 1944; Burrows, 1992; 

Halteren et al., 1996) given in Table 1: Yule’s 

characteristic (K), Hapax dislegomena (S), Simp-

son’s index (D), Honorës measure (R), Brunet’s 

measure (W), and Hapax legomena (H). They give 

us a set of richness d-features about word uni-

grams, POS n-grams, and rewrite rules. 

Table 1. Richness metrics 

2

4 1

2

( * ( , ) )

10 *

v

m

m V m T T

K
T








 
(2, )

( )

V T
S

V T
  

1

( *( 1)* ( , ))

*( 1)

v

m

m m V m T

D
T T










 

100*log( )

1 (1, ) / ( )

T
R

V T V T


  

(1, )H V T
 

( ) , 0.17
aV TW T a



 
 

 

6 S-Features  

The extracted d-features are transformed into s-

features, which are a set of similarity functions on 

two documents. We adopt five types of s-features.  

Sim4 Length s-features: This is a set of four simi-

larity functions defined by us. They are used for d-

feature vectors of length. The four formulae are 

given in Table 2, where lwq. (lwd), lsq. (lsd), and  lrq. 

(lrd) denote the average word, sentence, and docu-

ment length respectively, either in query q or non-

query document d. They produce four s-features.  

Table 2. Sim4 for computing length s-features 

1/ (1 log(1 | |))wq wdl l    

1/ (1 log(1 | |))sq sdl l    

1/ (1 log(1 | |))rq rdl l    

{ , , } { , , } { , , }

22( * ) / ( ) * ( )
m w s r m w s r m w s r

mq md mq mdl l l l
  

    

1129



Sim3 Sentence s-features: This is a set of three 

sentence similarity functions (Metzler et al., 2005). 

We apply them (called Sim3) to documents. Sim3 

s-features are used for frequency based d-features. 

The three formulae are given in Table 3, where f(t, 

s) is the frequency count of token t in a document s, 

and lq and ld are the average document length of 

the query and non-query document, respectively. 

Table 3. Sim3 for computing sentence s-features 

( , ) / ( ( , ) ( , ) ( , ))
t q d t q t d t q d

f t d f t q f t d f t d
     

      

( , )

log ( )*
( , ) ( , ) ( , ) ( , )

t q d

t q d

t q t d t q d

f t d
N

f t d f t q f t d f t d

 

 

   

 



  
 

1 * ( )
*

1 log(1 | |) 1 | ( , ) ( , ) |t q dq d

N idf t

l l f t q f t d     
  

Sim7 Retrieval s-features: This is a set of seven 

similarity functions (Table 4) applicable to all fre-

quency based d-features. These functions were 

used in information retrieval (Cao et al., 2006).  

Table 4. Sim7 for computing retrieval s-features 

log( ( , ) 1)
t q d

f t d
 

  | |log( 1)
( , )t q d

D

f t d 
  

log( ( ))
t q d

idf t
 

  ( , )log( 1)
| |t q d

f t d

d 
  

( , )
log( * ( ) 1)

| |t q d

f t d
idf t

d 
  log( 25 )BM score  

( , ) | |
log( * 1)

| | ( , )t q d

f t d D

d f t d 
  

 

In Table 4, f(t, d) denotes the frequency count of 

token t in a non-query document d, q denotes the 

query, D is the entire collection, |.| is the size of a 

set, and idf is the inverse document frequency. 

These 7 formulae can produce 7 s-features. 

SimC tf-idf s-feature: This is the cosine similarity 

used for d-vectors represented by the tf.idf based 

d-features. SimC tf-idf produces one s-feature. 

SimC Richness s-feature: This is also cosine sim-

ilarity. However, it is applied to the richness d-

feature vectors, and produces one s-feature. 

7 Experimental Evaluation  

We now evaluate the proposed approach and com-

pare it with baselines. All our experiments use the 

SVMperf classifier (Joachims, 2006). 

7.1  Experiment Setup 

Experiment Data: We use a set of reviews and 

their authors/reviewers from Amazon.com as our 

experiment data. We select the authors who have 

posted more than 30 reviews in the book category. 

After cleaning, we have 831 authors, 731 authors 

for training and 100 authors for testing. The num-

bers of reviews in the training and test author set 

are 59256 and 14308, respectively. We use the 

Stanford parser (Klein and Manning, 2003) to gen-

erate the grammar structure of review sentences 

for extracting syntactic d-features. Note that the 

authors here are in fact userids. However, since 

they are randomly selected from a large number of 

userids, the probability that two sampled userids 

belong to the same person is very small. Thus, it 

should be safe to assume that each userid here rep-

resents a unique author.  

Training data: We randomly choose 1 (one) re-

view for each author as the query and all of his/her 

other reviews as q-positive reviews. The q-

negative reviews consist of reviews randomly se-

lected from the other 730 authors, two reviews per 

author. We also tried to use more queries from 

each author, but they make little difference.  

Test data: The test authors are all unseen, i.e., 

their reviews have not been used in training. We 

prepare the test case for each author as follows.  

We first divide the reviews of each author into 

two equal subsets. The purpose is to simulate the 

situation where there are two userids idia and idib 

from the same author ai. Our objective is that giv-

en one userid idia and its query set, we want to find 

the other userid idib from the same author.   

For the review subset of idia (or idib), we ran-

domly select 9 reviews as the query set and anoth-

er 10 reviews as the sample set for the userid. The 

two sets are disjoint. We don’t use more queries or 

sample reviews from each author since in the re-

view domain most authors do not have many re-

views (Jindal and Liu, 2008). In the experiments, 

we will vary the number of test userids, the num-

ber of queries, and the number of samples. We use 

the following format to describe each test data: 

T<n>_Q<n>S<n>, where T denotes the total num-

ber of test userids, Q the query set and S the sam-

ple set, and <n> a number. For example, 

T50_Q9S10 stands for a test data with 50 userids, 

and for each userid, 9 reviews are selected as que-

ries and 10 reviews are selected as samples. * rep-

1130



resents a wildcard whose value we can vary. 

Note that we use this “artificial” data rather than 

manually labeled data for our experiments because 

it is very hard to reliably label any gold-standard 

data manually in this case. The problem is similar 

to labeling fake reviews. In the fake review detec-

tion research, researchers have manually label fake 

reviews and reviewers (Yoo and Gretzel 2009; 

Lim et al., 2010; Li et al., 2011; Wang et al., 2011). 

However, based on the actual fake reviews written 

using Amazon Mechanical Turk, Ott et al. (2011) 

have showed that the accuracy of human labeling 

of fake reviews is very poor. We also believe that 

our test data is realistic for evaluation as we can 

image that the two sets of reviews are from two 

accounts (userids) of the same author (reviewer).   

Two types of experiments: For each author with 

two userids, we conduct two types of tests.   

 Type I: Identify two userids belong to the same 
author. The experiment runs iteratively to test 

every userid. In each iteration, we plant one 

userid of an author in the test set and use the 

other userid of the same author as the query 

userid. That is, in the ith run, the test data con-

sist of the following two components: 

1.  Query userid idia and its query set Qia 

2. Test userids {id1a, …, id(i-1)a, idib, …, idma} 

and their corresponding sample review sets 

{S1a, …, S(i-1)a, Sib, …, Sma}.  

Note that the query userid idia and the test 

userid idib are from the same author. Our objec-

tive is to use Qia to find idib through Sib. 

Evaluation measure: We use precision, recall, 

and F1 score to evaluate Type I experiments as 

we want to identify all matching pairs. The er-

rors are “no pair” and “wrong pair” found.  

 Type II: Type II experiments test the cases 
when no pair exists. That is, we do not plant 

any matching userid for the query userid. Then, 

the algorithm should not find anything. For the 

ith run, the test data has these components: 

1.  Query userid idia and its query set Qia 

2.Test userids {id1a, …, id(i-1)a, id(i+1)a, …, idma} 

and their sample review sets {S1a, …, S(i-1)a, 

S(i+1)a, …, Sma}. idib is not planted.  

Evaluation measure: Here we cannot use pre-

cision and recall because we are not trying to 

find any pairs. We thus use accuracy as our 

measure. For each idi, if no pair is found, it is 

correct. If a pair is found, it is wrong.  

Baseline methods:  As mentioned eariler, there 

are  only two works that tried to identify multi-id 

users. The first is that in (Chen et al., 2004). 

However, as we discussed in related work, their 

approach is not applicable to reviews. The other is 

that in (Novak et al., 2004), which used clustering 

but assumed that the number of actual authors (or 

clusters) is known. This is unrealistic in practice. 

Thus we designed three new baselines:  

TSL: This baseline is based on the traditional su-

pervised learning (TSL). We use it to evaluate 

how the traditional approach performs in the 

original feature space. In this case, each docu-

ment in TSL has to be represented as a vector of 

d-features or traditional n-gram features. For 

each test userid id, we build a SVM classifier 

based on the one vs. all strategy. That is, for 

training we use id’s queries in T*_Q*S10 as the 

positive documents, and all queries of the other 

test userids (e.g., 99 userids if the test data has 

100 userids) as the negative documents. Note 

that TSL cannot use the 731 userids for training 

as in LSS because they do not appear in the test 

data. In testing, userid id’s sample (non-query) 

documents in T*_Q*S10 are used as positive 

documents, and the sample documents of all oth-

er test userids are used as negative documents. 

SimUG: It uses the word unigrams to compare the 

cosine similarity of queries and samples. Cosine 

similarity with unigrams is the most widely used 

document similarity measure.  

SimAD: It uses all d-features to compare the cosine 

similarity of queries and samples.  

For both SimUG and SimAD, their cosine simi-

larity values are used in place of SVM scores of 

LSS or TSL. We then apply the same 4 strategies 

to decide the final author attribution except voting 

as cosine similarity cannot classify.  

7.2  Results and analysis 

1) Effects of positive/total ratio in training set: 

Since our data is highly skewed and too many neg-

ative cases may not be good for classification, we 

thus performed this experiment to find a good ratio.  

Table 5 shows the results for Type I experiments. 

From Table 5, we can see that the results are high-

ly accurate. Even for 100 userids, our method can 

correctly identify 85% cases. Here we use the data 

sets T*_Q9S10 and the decision method is 

ScoreSqSum, which produces the best result. The 

1131



results for Type II experiments (Table 6) are also 

accurate. In most cases, the values of accuracy are 

higher than 90%. For all our experiments below, 

we use the model/classifier trained with 0.4 ratio. 

Table 5. Positive(p)/total(t) ratio in training (Type I) 

 

F1 

 

p/t 10 30 50 80 100 
0.3 100.00 84.62 86.36 88.89 83.72 

0.4 100.00 91.91 90.11 88.89 85.71 

0.5 100.00 90.91 91.30 88.89 87.01 

0.6 94.74 82.35 87.64 85.71 86.36 

0.7 94.74 84.62 86.36 86.53 87.64 

Table 6. Positive(p)/total(t) ratio in training (Type II) 

 

Accuracy 

 

p/t 10 30 50 80 100 
0.3 90.00 90.00 92.00 97.50 94.00 

0.4 90.00 90.00 94.00 98.75 95.00 
0.5 80.00 86.67 94.00 97.75 95.00 

0.6 80.00 86.67 90.00 93.75 92.00 

0.7 80.00 86.67 90.00 95.00 92.00 

(2) Effects of different decision methods: We 

show the results of the four proposed decision 

methods: Voting, ScoreSum, ScoreSqSum, and 

ScoreMax, using our basic data of T*_Q9S10 with 

varied number of test userids. Figure 5(a) shows 

that ScoreSqSum is the best for Type I experi-

ments. Figure 5(b) shows ScoreMax is the best for 

Type II, but ScoreSqSum also does very well. Be-

low, ScoreSqSum is used as our default method 

because Type I is more important than Type II.  

 

              (a)  Type I                   (b) Type II 

Figure 5: Effect of different decision methods 

(3) Effects of number of queries per userid: 

Figure 6 shows the results of different numbers of 

queries. We see that more queries give better re-

sults, which is easy to understand because more 

queries give more information. We use 9 queries 

per userid in all other experiments. 

 

 (a)  Type I                   (b) Type II 

Figure 6: Effect of different numbers of queries 

(4) Effects of number of samples per userid: We 

tried 2, 4, 6, 8, 10 samples per userid. Although 

there are some fluctuations for Type II (Fig.7(b)), 

we can see an upward trend for Type I in Fig. 7(a). 

This indicates that more sample documents give 

better results in general. The main reason again is 

that more samples from a userid give more identi-

fying information about the userid. We use 10 test 

documents (samples) per userid in all experiments. 

 

 (a)  Type I                   (b) Type II 

Figure 7: Effect of different number of samples 

(5) Impact of individual s-feature sets: Here we 

show the effectiveness of individual s-feature sets. 

From Table 7, we see that Sim7Retrieval s-

features are extremely important for Type I test. 

Removing Sim7Retrieval causes about 10% to 

20% F1 score drop on different datasets. SimCT-

fidf s-features are also useful. The impacts of other 

s-features are small. The same applies to Type II 

test (Table 8). On average, using all features is the 

best. Hence we use all features in all other experi-

ments above.  

Table 7. Using different s-features (Type I) 

T*_Q9S10 F1 

10  

F1 

30 

F1 

50  

F1 

80 

F1 

100  

All features 100.00 90.91 90.11 88.89 85.71 

No Sim4Len 100.00 88.89 86.36 87.32 85.06 

No SimCRichness 100.00 88.89 91.30 88.89 85.71 

No SimCTfidf 100.00 80.00 86.36 86.53 83.72 

No Sim7Retrieval 82.35 72.34 75.80 78.79 77.30 

No Sim3Sent 94.74 84.62 86.36 88.11 87.64 

Table 8. Using different s-features (Type II) 

T*_Q9S10 Acc. 

10  

Acc 

30 

Acc. 

50  

Acc 

80 

Acc. 

100  

All features 90.00 90.00 94.00 98.75 99.00 

No Sim4Len 90.00 93.33 96.00 96.25 96.00 

No SimCRichness 90.00 90.00 94.00 96.25 96.00 

No SimCTfidf 90.00 86.67 94.00 93.75 97.00 

No Sim7Retrieval 80.00 90.00 94.00 94.00 96.00 

No Sim3Sent 90.00 93.33 92.00 98.75 93.00 

(6) Comparing with the three baselines: Similar 

to our method, the training data for TSL is highly 

skewed as it uses a one-vs.-all strategy. Hence we 

also investigate the effect of p/t ratio in training for 

TSL. Results show that 0.4 ratio is the best setting. 

1132



Thus this setting is adopted for TSL in the follow-

ing experiments. Note that we cannot conduct p/t 

ratio experiments for SimAD and SimUG as they 

are unsupervised methods. We use ScoreMax for 

TSL, ScoreSqSum for SimUG and SimAD, re-

spectively, since they perform the best for their 

corresponding approaches. Tables 9 and 10 show 

the results of our LSS method and the baseline 

methods for Type I and II tests respectively. For 

TSL, we use all d-features. Unigram features gave 

TSL much worse results and are thus not included 

here.  

Table 9: Comparison with baselines (Type I) 

 10 30 50 80 100 

LSS Pre 100.00 100.00 100.00 100.00 98.68 

Rec 100.00 83.33 82.00 80.00 75.76 

F1 100.00 90.91 90.11 88.89 85.71 

TSL Pre 50.00 50.00 33.33 0.00 0.00 

Rec 11.11 3.45 2.08 0.00 0.00 

F1 18.18 6.45 3.92 0.00 0.00 

SimUG Pre 100.00 100.00 100.00 100.00 100.00 

Rec 70.00 46.67 48.00 48.75 43.00 

F1 82.35 63.64 64.86 65.55 60.14 

SimAD Pre 100.00 75.00 100.00 33.33 0.00 

Rec 20.00 10.35 2.00 1.28 0.00 

F1 33.33 18.18 3.92 2.47 0.00 

Table 10: Comparison with baselines (Type II) 

Accuracy 10 30 50 80 100 
LSS 90.00 90.00 94.00 98.75 95.00 

TSL 90.00 96.67 98.00 98.75 99.00 

SimUG 96.00 93.33 96.00 96.25 97.00 

SimAD 90.00 96.67 98.00 98.75 99.00 

From Tables 9 and 10, we can make the follow-

ing observations. 

 For Type I, F1 scores of LSS are markedly bet-
ter than those of the three baselines. The results 

of SimUG also drop more quickly than LSS 

with the increased number of userids. SimAD’s 

results are extremely poor. These show that 

LSS is much more superior to the unsupervised 

methods. TSL performed the worst, indicating 

that traditional supervised learning is inappro-

priate for this task. There are two main reasons: 

First, for one vs. all learning, the negative train-

ing data actually contain positive documents 

which are written by the same author using an-

other userid as the positive data, which confus-

es the classifier. Second, TSL is unable to build 

an accurate classifier using the small number of 

queries (which are training data). In contrast, 

our LSS method can exploit a large number of 

other authors who do not have to appear in test-

ing and thus achieves the huge improvements.  

 For Type II, LSS also performs very well. The 
baselines perform well too and even better, 

which is not surprising because they have diffi-

culty in finding matching pairs for Type I. 

Since Type II datasets have no author with mul-

tiple userids, naturally the baselines will do 

well for Type II. But that is useless because 

when there are authors with multiple usersids 

(Type I), they are unable to find them well.  

In summary, we can conclude that for Type I tests 

(there are authors with multiple userids), LSS is 

dramatically better than all baseline methods. For 

Type II tests (there is no author with multiple 

userids), it also performs very well.   

8 Conclusion  

This paper proposed a novel method to identify 

userids that may be from the same author. The 

core of the method is a supervised learning method 

which learns in a similarity space rather than the 

document space. This learning method is able to 

better determine whether a document may be writ-

ten by a known author, although no document 

from the author has been used in training (as long 

as we have some documents from the author to 

serve as queries). To the best of our knowledge, 

there is no existing method based on linguistic 

analysis for solving the problem. Our experimental 

results based on a large number of reviewers and 

their reviews show that the proposed algorithm is 

highly accurate. It outperforms three baselines 

markedly.  

 

Acknowledgements 

We are grateful to the anonymous reviewers for 

their thoughtful comments. Tieyun Qian was sup-

ported in part by the NSFC Projects (61272275, 

61272110, 61202036), and the 111 Project 

(B07037). Bing Liu was supported in part by a 

grant from National Science Foundation (NSF) 

under no. IIS-1111092. 

 

References  

Shlomo Argamon and Shlomo Levitan. 2004. 
Measuring the usefulness of function words for 
authorship attribution. Literary and Linguistic 
Computing 1-3. 

1133



Shlomo Argamon, Casey Whitelaw, Paul Chase, 
Sobhan Raj Hota, Navendu Garg, and Shlomo 
Levitan. 2007. Stylistic text classification using 
functional lexical features: Research articles. J. 
Am. Soc. Inf. Sci. Technol. 58:802-822.  

John F. Burrows. 1992. Not unless you ask nicely: 
The interpretative nexus between analysis and 
information. Literary and Linguistic Computing 
7:91-109. 

Yunbo Cao, Jun Xu, Tie-Yan Liu, Hang Li, Yalou 
Huang, and Hsiao-Wuen Hon. 2006. Adapting 
ranking svm to document retrieval. Proc. of 
SIGIR, Pages 186-193. 

Hung-Ching Chen, Mark K. Goldberg, Malik 
Magdon-Ismail. 2004. Identifying multi-ID users 
in open forums. Intelligence and Security 
Informatics, Pages 176-186. 

Joachim Diederich, Jörg Kindermann, Edda 
Leopold, and Gerhard Paass, 2000. Authorship 
attribution with support vector machines. 
Applied Intelligence 19:109-123. 

Hugo Jair Escalante, Thamar Solorio, and Manuel 
Montes-y-Gómez. 2011. Local histograms of 
character n-grams for authorship attribution. 
Proc. of ACL-HLT, Volume I: 288-298. 

Song Feng, Longfei Xing, Anupam Gogar, and 
Yejin Choi. 2012. Distributional Footprints of 
Deceptive Product Reviews.  Proc. of ICWSM.  

Michael Gamon. 2004. Linguistic correlates of 
style: authorship classification with deep 
linguistic analysis features. Proc. of Coling. 

Neil Graham, Graeme Hirst, and Bhaskara Marthi. 
2005. Segmenting documents by stylistic 
character. Natural Language Engineering, 
11:397-415.  

Jack Grieve. 2007. Quantitative authorship 
attribution: An evaluation of techniques. Literary 
and Linguistic Computing 22:251-270. 

Hans van Halteren, Fiona Tweedie, and Harald 
Baayen. 1996. Outside the cave of shadows: 
using syntactic annotation to enhance authorship 
attribution. Literary and Linguistic Computing 
11:121-132. 

Steffen Hedegaard and Jakob Grue Simonsen. 
2011. Lost in translation: authorship attribution 
using frame semantics. Proc. of ACL-HLT, short 
papers - Volume 2, 65-70. 

Graeme Hirst and Ol’ga Feiguina. 2007. Bigrams 
of syntactic labels for authorship discrimination 
of short texts. Literary and Linguistic Computing 
22:405-417. 

David I. Holmes and R. S. Forsyth. 1995. The 
Federalist Revisited: New Directions in 
Authorship Attribution, Literary and Linguistic 
Computing, 10(2): 111-127. 

David L. Hoover. 2001. Statistical stylistics and 
authorship attribution: an empirical 
investigation. Literary and Linguistic Computing 
16:421-424. 

Nitin Jindal and Bing Liu. 2008. Opinion Spam 
and Analysis. Proc. of WSDM, California, USA. 

Thorsten Joachims. 2006. Training linear svms in 
linear time. Proc. of KDD. 

Sangkyum Kim, Hyungsul Kim, Tim Weninger, 
Jiawei Han, and Hyun Duk Kim. 2011. 
Authorship classification: a discriminative 
syntactic tree mining approach. Proc. of SIGIR, 
Pages 455-464. 

Dan Klein, and Christopher D. Manning. 2003. 
Accurate unlexicalized parsing. Proc. of ACL, 
423-430.  

Moshe Koppel and Jonathan Schler. 2004. 
Authorship verification as a one-class 
classification problem. Proc. of ICML.  

Moshe Koppel, Jonathan Schler, Shlomo 
Argamon. 2011. Authorship attribution in the 
wild. Lang Resources & Evaluation, 45:83-94 

Fangtao Li, Minlie Huang, Yi Yang and Xiaoyan 
Zhu. 2011. Learning to identify review Spam. 
Proc. of IJCAI. 

Hang Li. 2011. Learning to Rank for Information 
Retrieval and Natural Language Processing. 
Morgan & Claypool publishers. 

Jiexun Li, Rong Zheng, and Hsinchun Chen. 2006. 
From fingerprint to writeprint. Communications 
of the ACM, 49:76-82. 

Ee-Peng Lim, Viet-An Nguyen, Nitin Jindal, Bing 
Liu, Hady W. Lauw. 2010. Detecting product 
review spammers using rating behaviors. Proc. 
of CIKM, 2010. 

Bing Liu. 2012. Sentiment Analysis and Opinion 
Mining, Morgan & Claypool publishers.  

1134



Tieyan Liu. 2011. Learning to Rank for Infor-
mation Retrieval. Springer. 

Kim Luyckx, Walter Daelemans. 2008. Authorship 
Attribution and Verification with Many Authors 
and Limited Data. Proc. of Coling, pages 513-
520. 

David Madigan, Alexander Genkin, David D. 
Lewis, Shlomo Argamon, Dmitriy Fradkin, and 
Li Ye. 2005. Author Identification on the Large 
Scale. Proc. of CSNA.  

Donald Metzler, Yaniv Bernstein, W. Bruce Croft, 
Alistair Moffat, and Justin Zobel. 2005. 
Similarity measures for tracking information 
flow. Proc. of CIKM. Pages 517-524. 

Frederick Mosteller, David Lee Wallace. 1964. 
Inference and disputed authorship: The 
Federalist. Addison-Wesley.  

Arjun Mukherjee, Bing Liu, and Natalie Glance. 
2012. Spotting Fake Reviewer Groups in Con-
sumer Reviews. Proc. of WWW, Pages 191-200. 

Arvind Narayanan, Hristo Paskov, Neil Zhenqiang 
Gong, et al. 2012. On the feasibility of internet-
scale author identification. Proceedings of the 
2012 IEEE Symposium on Security and Privacy. 
Pages 300-314 

Jasmine Novak, Prabhakar Raghavan, Andrew 
Tomkins. 2004. Anti-aliasing on the web. Proc. 
of WWW, Pages 30-39 

Myle Ott, Yejin Choi, Claire Cardie, Jeffrey T. 
Hancock. 2011. Finding Deceptive Opinion 
Spam by Any Stretch of the Imagination. Proc. 
of ACL. 

Myle Ott, Claire Cardie, Jeffrey T. Hancock. 2012. 
Estimating the prevalence of deception in online 
review communities. Proc. of WWW. 

Fuchun Peng, Dale Schuurmans, Shaojun Wang, 
and Vlado Keselj. 2003. Language independent 
authorship attribution using character level 
language models. Proc. of EACL, Pages 267-
274. 

Conrad Sanderson and Simon Guenter. 2006. 
Short text authorship attribution via sequence 
kernels, markov chains and author unmasking: 
an investigation. Proc. of EMNLP, Pages 482-
491. 

Yanir Seroussi, Fabian Bohnert, Ingrid Zukerman. 
2012. Authorship Attribution with Author-

aware Topic Models. Proc. of ACL, 2:264-269. 

Thamar Solorio, Sangita Pillay, Sindhu Raghavan, 
Manuel Montes y G´omez. 2011. Modality 
Specific Meta Features for Authorship 
Attribution in Web Forum Posts. Proc. of 
IJCNLP, Pages 156-164.  

Efstathios Stamatatos. 2009. A Survey of Modern 
Authorship Attribution Methods. Journal of the 
American Society for Information Science and 
Technology, 60(3):538-556, Wiley. 

Efstathios Stamatatos, George Kokkinakis, and 

Nikos Fakotakis. 2000. Automatic text 

categorization in terms of genre and author. 

Comput. Linguist. 26:471-495. 

Özlem Uzuner and Boris Katz. 2005. A 
comparative study of language models for book 
and author recognition. Proc. of IJCNLP, Pages 
969-980.  

Vladimir N. Vapnik. 1998. Statistical Learning 
Theory. Wiley-Interscience, NY.  

O. de Vel, A. Anderson, M. Corney and G. 
Mohay. 2001. Mining Email Content for Author 
Identification Forensics. Sigmod Record, 30:55-
64. 

Kyung-Hyan Yoo and Ulrike Gretzel. 2009. 
Comparison of Deceptive and Truthful Travel 
Reviews. Information and Communication 
Technologies in Tourism, Pages 37-47. 

Georgy Udnv Yule. 1944. The statistical study of 
literary vocabulary. Cambridge University 
Press. 

Guan Wang, Sihong Xie, Bing Liu, Philip S. Yu. 
2011. Review Graph based Online Store 
Review Spammer Detection. Proc. of ICDM. 

Ying Zhao and Justin Zobel. 2005. Effective and 
scalable authorship attribution using function 
words. Proceeding of Information Retrival 
Technology, Pages 174-189.  

Rong Zheng, Jiexun Li, Hsinchun Chen, and Zan 

Huang. 2006. A framework for authorship iden-

tification of online messages: Writing style fea-

tures and classification techniques. Journal of 

the American Society of Information Science 

and Technology 57:378-393. 

1135


