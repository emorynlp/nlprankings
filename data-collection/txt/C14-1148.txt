



















































Analysis and Refinement of Temporal Relation Aggregation


Proceedings of COLING 2014, the 25th International Conference on Computational Linguistics: Technical Papers,
pages 1556–1566, Dublin, Ireland, August 23-29 2014.

Analysis and Refinement of Temporal Relation Aggregation

Taylor Cassidy
IBM Research

Army Research Laboratory
Adelphi, MD 20783, USA

taylor.cassidy.ctr@mail.mil

Heng Ji
Computer Science Department

Rensselaer Polytechnic Institute
Troy, NY 12180, USA

jih@rpi.edu

Abstract

To obtain a complete temporal picture of a relation it is necessary to aggregate fragments of tem-
poral information across relation instances in text. This process is non-trivial even for humans
because temporal information can be imprecise and inconsistent, and systems face the additional
challenge that each of their classifications is potentially false. Even a small amount of incorrect
proposed temporal information about a relation can severely affect the resulting aggregate tempo-
ral knowledge. We motivate and evaluate three methods to modify temporal relation information
prior to aggregation to address this challenge.

1 Introduction

Temporal information about relations is conveyed in text at varying levels of completeness and speci-
ficity. A sentence may indicate that a relation starts, ends, or that it is ongoing at a particular time.
Furthermore, a time expression may be expressed at a variety of granularity levels (e.g., hour, day, or
year). For instance, “Collins, ..., is a 61-year-old veteran who went 444-434 in six seasons as a man-
ager, 1994-1996 with Houston” provides bounds on both the start and end date of the a relation but
at a coarse granularity. Conversely, “Ivory Coast President Laurent Gbagbo on state television Friday
dissolved parliament” conveys temporal information about an arbitrary part of Gbagbo’s presidency at a
finer granularity: the relation simply holds true at the document creation time (DCT). Single instances in
which a relation of interest is related to a time expression often fail to convey complete, fine-grained tem-
poral information. Thus, it is necessary to aggregate information from multiple relation-time temporal
relationship mentions to gain a complete temporal picture of a relation.

We focus on the aggregation of temporal information about relations within the context of the Tem-
poral Slot-Filling (TSF) Task (Ji et al., 2011; Surdeanu, 2013). TSF focusses on a class of relations
called fluents (Russell and Norvig, 2010), which are properties of named entities whose values may
vary over time. Systems must succinctly describe all temporal information about each query relationR –
e.g., title(Gbagbo, President) – available in a source document collection by assigning it a single, final
temporal four-tuple (Amigo et al., 2011). Given a relation mention r ofR and a time expression γ, a four-
tuple T rγ =

〈
t(1), t(2), t(3), t(4)

〉
characterizes their temporal relationship; namely, t(1) and t(2) represent

the earliest and latest possible start date forR, while t(3) and t(4) represent the earliest and latest possible
end dates, as inferred from the relation mention’s context (sec. 3). For instance, a sentence indicating
that Gbagbo was President on 2010-02-12 yields

〈−∞, 2010-02-12, 2010-02-12,+∞〉, while the sen-
tence “Gbagbo has been in power since 2000” yields

〈
2000-01-01, 2000-12-31, 2000-01-31,+∞〉. The

intuitively best aggregation of these four-tuples expresses what we learn from both texts, that the relation
started in 2000 and remained ongoing at 2010-02-12, i.e.

〈
2000-01-01, 2010-02-12, 2010-02-12,+∞〉,

with no clear indication as to its end. Straightforward cases like these were used to justify the simple
aggregation methods used by all TSF systems to date (Surdeanu, 2013; Ji et al., 2011). However, in real-
ity even humans often must deal with vague and/or conflicting temporal information across documents,

This work is licenced under a Creative Commons Attribution 4.0 International License. Page numbers and proceedings footer
are added by the organizers. License details: http://creativecommons.org/licenses/by/4.0/

1556



and systems must furthermore deal with the fact that each of their temporal relationship classifications is
potentially false.

To address the various properties of text and temporal representation that influence aggregation and
affect final four-tuple quality, we first improve an existing gold standard dataset (sec. 4.1). We then
describe two key factors affecting systems’ aggregation performance: (1) erroneous classifications at-
tributed high confidence by systems, and (2) a lack of relation-bounding classifications (sec. 4.2). We
propose three methods to better prepare a relation’s multiple mention context derived four-tuples for ag-
gregation into a final four-tuple. The first applies simple rules to predicative nominal titles with explicit
time information (e.g., “former President”), the second filters and re-labels four-tuples based on entity
lifespan (sec. 5.3), and the third adds four-tuples based on mentions of relations other than, but tempo-
rally linked to, the query relation (sec. 5.4). We then discuss results and identify remaining challenges
for aggregating temporal information across relation mentions (sec. 6 and 7). A Glossary of selected
terms can be found in the appendix.

2 Related Work

The most similar work on temporal relation information aggregation are Wang et al. (2012), who use an
Integer Linear Programming framework to enforce the validity of induced temporal relation information
as well as enforce inter-relation constraints, and Dylla et al. (2013), who collect temporal information
about relations, mostly about start and end times, using a temporal probabilistic data base framework
to aggregate and enforce constraints based on relation argument existence. All TSF systems we are
aware of have used either max-constrain or Validity-Ensured Incremental max-constrain aggregation
algorithms (Surdeanu, 2013; Ji et al., 2011), which we cover in section 4. None we are aware of have
applied background knowledge to constrain intermediate four-tuples (sec. 3) before or after aggregation.
In this work we modified our previous work CUNYTSF (Artiles et al., 2011), which is the only publicly
available TSF system we are aware of. CUNYTSF employs two supervised models, one based on a string
kernel defined in terms of dependency paths between named entities involved in a relation and context
time expressions, and the other based on bags-of-words derived from small windows surrounding these
tokens and shallow dependency relations. CUNYTSF achieved the highest and second-highest scores of
five systems in two TSF shared tasks (Surdeanu, 2013; Ji et al., 2011).

3 Temporal Slot Filling (TSF)

The 2013 Temporal Slot-Filling (TSF) (Surdeanu, 2013) task was part of the Knowledge Base Popula-
tion (KBP) track of the Text Analysis Conference (TAC). Systems were given a list of 273 fluent relation
instances as queries, each with a supporting document. Query relations were evenly distributed across re-
lation types, which consisted of people’s titles, marriages, employments or memberships, and residences
(city, state, and country), and companies’ top members or employees. The task was to obtain a final four-
tuple TR for each query relationR =

〈
q, s

〉
using the source corpus for provenance. For each element in

TR a system must provide a document in which R is entailed, and offsets for the relation arguments (the
query-entity q and slot-filler s) and the normalized time expression from which the four-tuple element is
derived.

The KBP source collection consists of about 1 million newswire, 1 million web text, and 100,000
discussion forum documents. Gold standard annotation was obtained by annotators who, using a tool,
searched the source corpus for documents that provide temporal information about each query relation.
Given a mention r of R in a document d for which temporal information about R could be inferred,
annotators assigned an intermediate temporal relationship label (Table 1) (Ji et al., 2011) to

〈
r, γ

〉
, where

γ is viewed as an interval of dates [γs, γe] derived either based on (1) a normalized time expression in
d, or (2) the document creation time of d. We denote the temporal extension of R at the day granularity
Rex = [Rs, Re], where Rs and Re are the start and end dates of R. The intermediate label l mediates the
relationship between γ and Rex, characterizing a possible relationship between R and γ. 1 After systems
submitted results for the shared task, any corresponding document not included in the original annotation

1We add AFTER END* and BEFORE START* but omit motivation due to space constraints.

1557



that were determined to express R was exhaustively annotated for temporal information about R. A gold
standard final four-tupleGR is obtained for eachR by applying an aggregation procedure (sec. 4.1) to the
intermediate temporal relationship labels assigned to mention-time classification instances (Surdeanu,
2013).

In this work we adopt the evaluation metric used for the TSF shared task (Ji et al., 2011; Surdeanu,
2013).

Intermediate Relation four-tuple
BEGINNING

〈
γs, γe, γs,∞

〉
ENDING

〈−∞, γe, γs, γe〉
BEG AND END

〈
γs, γe, γs, γe

〉
WITHIN

〈−∞, γe, γs,∞〉
THROUGHOUT

〈−∞, γs, γe,∞〉
BEFORE START

〈
γe,∞, γe,∞

〉
AFTER END

〈−∞, γs,−∞, γs〉
BEFORE START*

〈
γs,∞, γs,∞

〉
AFTER END*

〈−∞, γe,−∞, γe〉
NONE

〈−∞,∞,−∞,∞〉
Table 1: Intermediate temporal relationship func-
tion for

〈
r, γ

〉

Invalidity Source Frequency
Conflicting Information 13
Multiple Instances 7
Wrong Intermediate Label 20
Vague Time Normalization 8
Other 8

Table 2: Reasons for Invalidity in Gold Standard
Final Four-Tuples

4 Aggregating Intermediate Relations

Temporal information about instances of R must be aggregated to yield a complete temporal picture of
the relation with respect to the background corpus. We denote with I(R) the set of intermediate four-
tuples associated with R. The purpose of the four-tuple representation is to be as accurate as possible
in representing the extent to which a given corpus provides information about the start and end time of
R, Rs and Re, while preserving the vagueness inherent in the text. Each four-tuple element of I(R)
represents temporal information about Rs and/or Re, most often with respect to the context associated
with a particular mention r of R. Temporal information at a corpus level is derived via a process of
aggregation over the elements of I(R). In this section we describe how both human annotators and
systems have approached aggregation.

4.1 Aggregating Manually Annotated Intermediate Relations

Gold standard four-tuples were obtained by applying the Max-Constrain (MC) algorithm (Equation 1) to
each I(R) obtained via manual annotation using the labels in Table 1 (Surdeanu, 2013; Ji et al., 2011).2

TR =
〈
max(t(1)),min(t(2)),max(t(3)),min(t(4))

〉
(1)

Here, max(t(k)) is the greatest t(k) from any intermediate four-tuple Tr ∈ I(R), while min(t(k)) is the
least.

Let a four-tuple T be valid iff. t(1) ≤ t(2) ∧ t(3) ≤ t(4) ∧ t(1) ≤ t(4), and correct if t(1) ≤ Rs ≤
t(2) ∧ t(3) ≤ Re ≤ t(4). If R has only one start and one end date, and Rs ≤ Re, and each intermediate
four-tuple T γr ∈ I(R) is valid and correct, then the final four-tuple obtained via MC is guaranteed to be
valid and correct. Fifty-six gold standard final four-tuples were invalid and therefore discarded prior to
evaluation (Surdeanu, 2013). We analyzed them by hand to determine the source of their invalidity (see
Table 2). 3 We corrected instances until IMC (Algorithm 1) yielded a valid four-tuple.

2See http://surdeanu.info/kbp2013 for more details.
3Note that there may be more instances of each type described in table 2
4Here, max(t(i) ≤ x(i)) := max(

{
t(i) ∈ t(i)

∣∣∣t(i) ≤ x(i)}), where t(i) := {t(i) ∈ T ∣∣∣T ∈ I(R)}

1558



Algorithm 1 Inclusive Max-Constrain (IMC)4

Require: I(R) = {T0, T1, . . . , TN−1}
Ensure: TR
X ← max-constrain(I(R)) = 〈x(1), x(2), x(3), x(4)〉
Y ← 〈max(t(1) ≤ x(2)),min(t(2) ≥ x(1)),max(t(3) ≤ x(4)),min(t(4) ≥ x(3))〉
TR ←

〈
max(t(1) ≤ y(2)),min(t(2) ≥ y(1)),max(t(3) ≤ y(4))〉,min(t(4) ≥ y(3))

return TR

4.2 System Derived Intermediate Relations

As suggested in section 4.1, MC is sensitive to inconsistent four-tuples. In response to this all prior
work that has not used MC to combine system-produced I(R) has used an algorithm similar to Validity-
Ensured Incremental (VEI) Max-Constrain (Algorithm 2) (Artiles et al., 2011). Here, I(R) is ordered
by classifier confidence and TR is initialized as the trivial four-tuple and updated incrementally. Starting
with the highest-confidence four-tuple TR,0 ∈ I(R), MC is applied to {TR, TR,i} to yield T ∗. In a given
iteration, T ∗ is only accepted as the updated TR if it is valid. Intuitively, higher confidence intermediate
four-tuples are more likely to be correct, thus the incremental algorithm tries to ensure that erroneous
low-confidence four-tuples are less likely to be aggregated. In practice, however, a single high-confidence
incorrect label can derail the entire process (sec. 5).

Algorithm 2 Validity-Ensured Incremental (VEI) Max-Constrain Aggregation to yield final four-tuple
Require: I(R) = {T0, T1, . . . , TN−1}
Ensure: TR =

〈
t(1), t(2), t(3), t(4)

〉
TR ←

〈−∞,∞,−∞,∞〉
i← 0
while i < N do
T ∗ ← 〈max(t(1), t(1)i ),min(t(2), t(2)i ),max(t(3), t(3)i ),max(t(4), t(4)i )〉 {Pairwise MC}
if t∗(1) ≤ t∗(2) ∧ t∗(3) ≤ t∗(4) ∧ t∗(1) ≤ t∗(4) then
TR ← T ∗ {Validity Check}

end if
end while
return TR

5 Challenges and Solutions

This section outlines our modifications to CUNYTSF, inspired by a preliminary error analysis. We
implement three methods geared toward better preparing I(R) for aggregation into a final four-tuple..

5.1 Preliminary Error Analysis

We ran the publicly available system CUNYTSF described in (Artiles et al., 2011) on the queries used
in TSF2013, using the KBP2013 source collection, and evaluated against the corrected gold standard
described in section 4.1. 5

Error analysis revealed the main source of errors to be WITHIN labels with high confidence. To be
exact, the final four-tuple for 116 queries (of 271) was influenced by a WITHIN label that yielded a t(3)

later than the g(4) date, while 20 were influenced by WITHIN dates that were too early. Under VEI,
once a labeled instance

〈
r, γ,WITHIN

〉
is aggregated into TR, if γ > Re then any correctly labeled

instance
〈
r, γ, ENDING

〉
will yield an invalid four-tuple and thus be rejected. (Similarly, correct BEGIN-

NING labels will be blocked by incorrect WITHIN labels that are too early). Even correct WITHIN labels
cannot set the corrupted aggregation back on track, since pairwise MC will always take the later t(3)

5System downloaded from http://nlp.cs.rpi.edu/software.html

1559



(algorithm 2). That said, WITHIN labels are often required to retrieve a complete temporal picture of
a relation conveyed in a corpus. WITHIN is the most common intermediate label in the source collec-
tion, constituting 44% of correct labels, and furthermore, over half of the query relations require at least
one WITHIN label to achieve the gold standard final four-tuple, with 10% relying solely on instances
labeled WITHIN. To make matters worse, almost all TSF systems to date (except Garrido et al. (2013))
use neither the BEFORE START* nor AFTER END* labels in their intermediate temporal relationships
classification models, even though high-confidence instances with those labels could prevent the sort of
erroneous WITHIN labels alluded to above.

This analysis motivated three methods to curtail the extent to which aggregation-derailing four-tuples
were included in I(R) described in sections 5.2, 5.3, and 5.4. We favor VEI over IMC for system-derived
I(R) because IMC strongly relies on the assumption that there is a high probability of correctness for
each intermediate relationship annotation.

5.2 Title Time of Predication

Nominal predicates are commonly used in English to refer to fluents. For example, attribution of a title
to a person can be performed using a transitive verb or copula as in “Serra was elected Governor”,
or “Serra is the Governor”, or as a Noun Phrase (NP) within a clause, as in “Governor Jose Serra”
or “Jose Serra, Governor, ...” (among other ways). We refer to cases in which the subject and object
of the relation are contained within a phrase headed by a Noun as Relational NP’s (RNP).6 For RNP
that are mentions of fluent relations, there is a time of predication (TOP), i.e. a time at which the
relation conveyed is asserted to hold, though this time is not overtly marked by tense or aspect (in
English) as in the case of VP’s. Tonhauser (2002)’s analysis assumes that the verbal time of predication
(VTOP) is the “most salient” time in an utterance, thus relational NP’s take their containing clause’s
verbal time of predication by default though contextual justification may override this tendency. We
propose that in news the DCT is just as salient a time since the focus is centered on current affairs, an
important entities are often “already introduced” into the discourse by virtue of being public figures. Ad-
hoc analysis of the instances considered by CUNYTSF indicate that a compelling reason is required to
override RNP’s from taking both DCT and VTOP. For instance, in, “O’Donnell ... suggested Wednesday
that the Obama administration - particularly Vice President Joe Biden, who represented Delaware in
the Senate for decades - was behind them”, “Vice President” holds true at DCT, and rejects the VTOP
of “represented”, presumably only based on logical inference: no person is both Vice President and
represents (a state) in the Senate at the same time. Similarly, we know that the DCT (2010-08-04) is
an invalid TOP in “In November 2000, Chinese President Jiang Zemin paid a state visit to Laos, the
first visit to Laos by a Chinese president”, only because of world knowledge, or, “The following is a
chronology of major events in China- Laotian relations since 1990:”, earlier in the document.

Though NP’s lack tense and aspect, overt temporal modifiers such as former, then-, and ex- make
explicit a post-relational state directly following an RNP’s relation (Tonhauser, 2002).7 The tendency
for RNP’s to take both the verbal predication time as well as the DCT extends to post-relational states.
There are many examples in the corpus similar to the following: “Former US President Bill Clinton and
US journalists Euna Lee and Laura Ling returned Wednesday from North Korea, one day after North
Korea’s leader Kim Jong-Il pardoned the two women”. Each RNP holds at the DCT, and “Wednesday”,
as well as the day before that (the VTOP of “pardoned”). However, as for VTOP’s further into the
past, whether the post-relational state holds is less clear. For example, in, “Secretary of State Hillary
Rodham Clinton says former Philippines President Corazon Aquino “helped bring democracy back” to
her country after years of authoritarian rule”, we cannot rule out the possibility that Aquino helped
bring democracy back as President; whether she did so as former President is left open, to be resolved
by historical knowledge. This is likely because, unless the relation is of the “Grover Cleveland” type,
once the relation becomes a “former” relation it will remain so thereafter.

6We adopt a Noun Phrase rather than a Determiner Phrase framework for simplicity.
7In this work we omit similar constructions that indicate a pre-relational state at the time of verbal predication, such as

“future-”, “soon-to-be”, and “-elect”. These words to not occur often in our data. That said, the extent to which their meanings
are analogous to the overt temporal modifiers that introduce post-relational states is not clear, and requires further investigation.

1560



The nature of the contexts that override default TOP for RNP’s is complicated, and not well under-
stood. In addition, determining VTOP automatically remains a difficult problem in and of itself (Uz-
Zaman et al., 2012). We have shown that newswire data contains relational NP’s whose default times
of predication - both DCT and verbal - are overridden by context. In addition, even post-relation states
of modified RNP’s may reject VTOP’s. Post-relational states introduced by RNP’s modified with “for-
mer”, “then”, and “ex-”, however, do appear to unambiguously take the DCT as a time of predication.
Furthermore, we observe that CUNYTSF often incorrectly classifies modified RNP’s introducing a post-
relational state as expressing

〈
r,DCT,WITHIN

〉
. To correct these errors we apply hand-written Title

Time of Predication Fix rules to change the label for all such classification instances to AFTER END*
when the associated time expression is (or is closely related to) the DCT, and attribute 100% confidence
to this new label. This correction both removes erroneous WITHIN labels and introduces labeled instances
that bound query relations.

5.3 Entity Existence
VEI suffers when confidence values are inaccurate. For the relation spouse(Marylin Monroe, Arthur
Miller), given the sentence, “Editor Courtney Hodell said the book would include poems , photographs ,
reflections on third husband Arthur Miller and other men in Monroe ’s life ”, a system is likely to mislabel〈
r, γ

〉
as WITHIN, where γ is the document creation time 2010-04-27. The pattern “husband s” is a

strong indicator of the WITHIN relationship for the spouse relation, so confidence for the resulting four-
tuple

〈−∞, 2010-04-27, 2010-04-27,∞〉 is likely to be high. Once aggregated, it would be impossible
to later aggregate

〈−∞, 1961-12-31, 1961-01-01, 1961-12-31〉 upon learning of the couple’s divorce in
1961, since the proposed T ∗ =

〈−∞, 1961-12-31, 2010-04-27, 1961-12-31〉 is invalid. A basic clue that
a WITHIN label should be changed to AFTER END* is that q or s no longer exists (either the person has
died or the business has dissolved).

To address this challenge we propose Existence-based Correction and Filtering. For each relation
R we obtain the existence four-tuple ER, by applying MC aggregation to the set of birth and death
times in a knowledge base (KB) for the query-entity and slot-filler.8 The KB is obtained via the Free-
base API and scraping Wikipedia Infoboxes. We use a four-tuple instead of an interval of dates be-
cause birth and/or death information may not be available at the date granularity. Given the relation
spouse(Jennifer Jones, Norton Simon) and the KB excerpt in Table 3, we obtain an existence con-
straint four-tuple

〈
1919-03-02, 1919-03-02, 1993-06-02, 1993-06-02

〉
.

Entity Birth Death
Jennifer Jones 1919-03-02 2009-12-17
Norton Simon 1907-02-05 1993-06-02

Table 3: Existence Information

We apply algorithm 3, where C contains classifier confidence for each labeled instance in I(R).
Above, I(R) was introduced as a list of intermediate four-tuples for a relation R. In our approach,
each of these four-tuples is derived deterministically (see Table 1). From here on (as in Algorithm 3) we
allow a slightly abuse of notation in which I(R) is viewed as a set of labeled classification instances,
each of which yields a four-tuple for R. We omit pseudo-code to handle the analogous cases where
instances are re-labeled BEFORE START* based on the relative position of γ and �1.

5.4 Relation Precedence
The context of a relation mention often contains temporal information not explicitly tied to a time ex-
pression. For example, in, “Myasnikovich will replace Sergei Sidorsky, who was prime minister since
2003”, there is no date explicitly tied to the transition of power. Many titles are held by one person after
another, in succession, without overlap. Intuitively, if we know the order in which several individuals
held the same title then temporal information about one such relation can be used to constrain the other.

8For organization query-entities their foundation and defunct dates are considered their “birth” and “death” dates.

1561



Algorithm 3 Existence Based Correction & Filtering Algorithm

Require: I(R) =
{〈
γ0, l0

〉
, . . . ,

〈
γk, lk

〉}
; C = {c0, . . . , ck}; ER =

〈
�(1), �(2), �(3), �(4)

〉
while i < N do

if γi.s ≥ �4 ∧ ¬(li = NONE) then
if li = ENDING ∧ γ.s− �4 ≤ 31 then
ci ← 1.0 {Most likely R holds at the time of death}

else
li ← AFTER END*; ci ← 1.0

end if
else if γi.s ≤ �4 ≤ γi.e ∧ ¬(li = NONE) then

if li = ENDING then
ci ← 1.0 {Most likely R holds at the time of death}

else
li ← AFTER END*; ci ← 1.0

end if
end if

end while
return I(R)

To address this challenge we propose Precedence-based Query Expansion and Re-labeling. The
title relation is well-represented in Wikipedia, and the infobox for many political title holders contains
fields for preceded by and succeeded by, which specify the person that held the same title before and after
the title holder in question. Given a title query R, we extracted the person who preceded and succeeded
the query entity from the query entity’s infobox (when available). Additional title relation supporter
queries – Rpre and Rsuc, respectively – were generated using these names, and the same title name as in
the official query.9

After all classification instances are labeled and existence based correction is applied, we transform
all labeled instances for supporter queries into labeled instances for official queries. Given a labeled
instance

〈
rx, γ, l

〉
, where x = pre or suc, we apply the mapping in Table 4 to yield the transformed

labeled classification instance
〈
r, γ, l′

〉
. Labeled supporter instances transformed into labeled official

query instances are added to I(R), the set of labeled instances for R. The set I(R) is then passed to
Aggregation (see Algorithm 2).

Supporter Label l Official label l′ (x = pre) Official label l′ (when x = suc)
NONE NONE NONE

BEFORE START* BEFORE START* NONE
AFTER END* NONE AFTER END*

All Others BEFORE START* AFTER END*

Table 4: Mapping to convert
〈
rx, γ, l

〉
to

〈
r, γ, l′

〉
, where x indicates whether the supporter query pre-

cedes or succeeds the official query

Just about any instance
〈
rpre, γ, l

〉
yields

〈
r, γ, BEFORE START*

〉
because Rpre is known to both start

and end before R starts. (And conversely
〈
rsuc, γ

〉
tends to yield AFTER END* for

〈
r, γ

〉
.) This is

because the last (first) day of Rpre and all days before (after) it are guaranteed to be before (after) the
start (end) of R. However, note that a AFTER END* label for

〈
rpre, γ

〉
yields NONE for R since dates

after the end of Rpre may be before, during, or after R. For example, the headline, “Former President

9In general, knowing that two relations stand in a particular interval relation to one another allows us to posit constraints
on one relation upon discovering temporal information about the other. We apply this intuition to the title relation in this work
since the information is readily available in a structured form (i.e., the preceded by and succeeded by fields in Wikipedia info
boxes).

1562



Lee Teng-hui on visit in Japan Tokyo”, while clearly indicating AFTER END* for Rpre tells us very little
about the relationship between the document creation time and R.

6 Results and Analysis

We scored the output for five conditions using the modified gold standard (section 4.1). TF means that
title time of predication fix was applied (section 5.2), EC means existence corrections were applied, and
Pr means that precedence-based query expansion was applied (section 5.4).

System P R F
CUNYTSF .337 .294 .314

CUNYTSF + TF .341 .298 .318
CUNYTSF + EC .349 .305 .326

CUNYTSF + TF + EC .353 .309 .329
CUNYTSF + TF + EC + Pr .360 .315 .336

Table 5: Results calculated using official TSF2013 scorer against corrected gold standard (sec. 4.1), with
anydoc and ignore-offsets parameters set to true, augmented to calculate recall and precision

6.1 Title Time of Predication Fix

The gold standard for title had 142 non-infinity tuple element outputs of the form
〈
R, i, t(i)

〉
. The

baseline output had 80 values while baseline + TF had 91. Applying TF, 10 baseline outputs were
replaced while 11 were added. In most cases erroneous WITHIN labels are corrected by inserting high-
confidence AFTER END* into I(R). In some cases this allows a correct t(3) to replace a later, incorrect
t(3) that came from an erroneous WITHIN label. It is important to note that while some changes barely af-
fect F-measure, they are important because they allow for correct information that would have otherwise
been blocked to be aggregated. For example, a bad baseline WITHIN for “General Prosecutor ’s Office
of Kyrgyzstan on Tuesday charged the country’s former Prime Minister Igor Chudinov with abuse of
power” had blocked a correct WITHIN for “Kyrgyz Prime Minister Igor Chudinov left Beijing Thursday
evening” - removing this block allowed t(3) to change from 2010-05-04 to 2009-10-14, which is the gold
standard value.

6.2 Existence-based Correction and Filtering

Most changes made from existence constraints are beneficial both in terms of an increase in F-measure
and in blocking the aggregation of incorrect information. For instance, it is difficult to prevent labeling
the following sentence with WITHIN for DCT: “The London home of composer George Frideric Handel
is holding an exhibition about its other famous resident – Jimi Hendrix”, but the document context per-
mits AFTER END*, given “Hendrix died in London on Sept. 18 , 1970”. Given the existence constraint
we label the instance AFTER END*.

On the other hand, in some cases we erroneously change WITHIN to BEFORE START* using existence
constraints, but this type of change does little damage. For example, the fact that CNN was founded on
1980-06-01 changes the label on 1980 from WITHIN to BEFORE START* for EMPLOYEE(Novak, CNN),
given “Novak , editor of the Evans-Novak Political Report , is perhaps best known as a co-host of several
of CNN ’s political talk shows , where he often jousted with liberal guests from 1980 to 2005”. We set
t(1) = 1980-01-01 which does not block later inclusion of a correct

〈
R, 1980, BEGINNING

〉
, which

would set t(1) = 1980-01-01 if it were not already set, and does set t(2) = 1980-12-31. Changing this
relation’s label from WITHIN to START is not a catastrophic error because it allows for a finer grained,
correct start date to be aggregated using VEI (see Algorithm 2) to yield a superior final four-tuple (though
CUNYTSF finds no suitable candidates to facilitate this).

1563



6.3 Precedence-based Query Expansion & Re-labeling

Output for affected official queries were improved simply because supporter queries were accurately
labeled. For example, “Kim Choongsoo, Korea’s Central Bank Governor, said here on Thursday his na-
tion’s economic situation was getting better” provides a t(4) value for title(Lee Seong-tae, Governor)
due given the successor relation.

Some gains from label transformation are only possible given the title time of predication fix. For ex-
ample, multiple instances of “former president Chen Shui-bian” and “Former President Lee Teng-hui”
were converted from WITHIN to AFTER END* for their respective relations. Because Chen succeeded
Lee, the latter instances were transformed to NONE instances for title(Chen, President) using Ta-
ble 4. 10 Changing these labels to NONE made room for a valid t(3) = 2000-01-01 based converting the
WITHIN for title(Lee, President) to BEFORE START* for title(Chen, President) given, “... since
former President Lee Teng-hui promulgated it 19 years ago, Wang said, and the [DPP] did not try to
make any changes to the framework during its eight-year rule between 2000 and 2008 either”.

Label transformation is robust to misclassification. For example, any of BEFORE START*, BEGIN-
NING, WITHIN, or ENDING for a predecessor relation Rpre will map to before start* for R. But other
types of errors propagate and can lead to disastrous results. For example, due to a normalization quirk
“Utatu President George Strauss” is recognized as “Johannes Rau”, thus the relation title(Rau, Pres-
ident) was assigned WITHIN at DCT, which is converted to a BEFORE START* for Horst Kohler, Rau’s
successor.

A deeper problem that can lead to error propagation is that fact one person can have the same title in
different contexts. When a title is attributed to a person there is often a geo-political or organization en-
tity involved. Mentions that fail to include this third entity are ambiguous; often, this information needs
to be inferred from other context sentences. Such errors may be propagated from supporter to official
queries. For example, “Francophonie president Abdou Diouf of Senegal ... ” appears to support the
title(Abdou Diouf, President). Diouf preceded Abdoulaye Wade as President of Senegal, but the con-
text in question (inaccurately) refers to Diouf’s leadership position of Secretary-General (not President)
of Organisation internationale de la Francophonie, thus an erroneous BEFORE START* is aggregated,
blocking a correctly labeled (less confident)

〈
r, 2000, START

〉
.

7 Conclusion

We have analyzed within the particular context of TSF the process of aggregating partially-specified
temporal information about relations across documents. Our analysis and and results indicate that text
mentions of relations often ground only a portion of the referent relation in time and that correct in-
terpretation relies on background knowledge about relation participants. In future work we plan a more
rigorous data-driven study of nominal time of predication and to attack more ambiguous context-sensitive
cases. In addition we aim to induce relation order from text automatically to multiple relation types as
well as events.

Acknowledgments

This work was supported by the U.S. Army Research Laboratory under Cooperative Agreement No.
W911NF-09-2-0053 (NS-CTA), and in addition the U.K. Ministry of Defense under Agreement No.
W911NF-06-3-0001 (ITA), U.S. NSF CAREER Award under Grant IIS-0953149, U.S. DARPA Award
No. FA8750-13-2-0041 in the Deep Exploration and Filtering of Text (DEFT) Program, IBM Faculty
Award, Google Research Award and RPI faculty start-up grant. The views and conclusions contained in
this document are those of the authors and should not be interpreted as representing the official policies,
either expressed or implied, of the U.S. Government. The U.S. Government is authorized to reproduce
and distribute reprints for Government purposes notwithstanding any copyright notation here on.

10Had the title fix not been applied these WITHIN labels would have been converted to BEFORE START*.

1564



References
Enrique Amigo, Artiles Javier, Qi Li, and Heng Ji. 2011. An evaluation framework for aggregated temporal

information extraction. In Pric SIGIR2011 Workshop on Entity-Oriented Search.

Javier Artiles, Qi Li, Taylor Cassidy, and Heng Ji. 2011. Temporal slot filling system description. In Proc. Text
Analytics Conference (TAC2011).

Maximilian Dylla, Iris Miliaraki, and Martin Theobald. 2013. A temporal-probabilistic database model for infor-
mation extraction. Proceedings of the VLDB Endowment, 6(14):1810–1821.

Guillermo Garrido, Anselmo Penas, and Bernardo Cabaleiro. 2013. Uned slot filling and temporal slot filling
systems at tac kbp 2013. system description. In Proc. Text Analytics Conference (TAC2013).

Heng Ji, Ralph Grishman, and Hoa Trang Dang. 2011. An overview of the tac2011 knowledge base population
track. In Proc. Text Analytics Conference (TAC2011).

Stuart J. Russell and Peter Norvig. 2010. Artificial Intelligence - A Modern Approach (3. internat. ed.). Pearson
Education.

Mihai Surdeanu. 2013. An overview of the tac2013 knowledge base population track. In Proc. Text Analytics
Conference (TAC2013).

Judith Tonhauser. 2002. A dynamic semantic account of the temporal interpretation of noun phrases. In Proceed-
ings of SALT, volume 12, pages 286–305.

Naushad UzZaman, Hector Llorens, James F. Allen, Leon Derczynski, Marc Verhagen, and James Pustejovsky.
2012. Tempeval-3: Evaluating events, time expressions, and temporal relations. CoRR, abs/1206.5333.

Yafang Wang, Maximilian Dylla, Marc Spaniol, and Gerhard Weikum. 2012. Coupling label propagation and
constraints for temporal fact extraction. In Proceedings of the 50th Annual Meeting of the Association for
Computational Linguistics: Short Papers-Volume 2, pages 233–237. Association for Computational Linguistics.

Appendix A. Glossary of Selected Terms

Fluent Relation: A property of a person or organization whose value may change over time. For
example, a person’s employer.
Temporal Extension: For a relation R, the temporal extension is the interval [Rs, Re], which represents
the period of time between and including the start date Rs and end date Re of the relation.
Relation Mention: An excerpt of text that expresses a relation.
Time Expression: An excerpt of text that refers to a portion of time, such as “Tuesday” or “next year”.
Normalized Time Expression: The portion of time indicated by a time expression expressed in a
standard form.
Granularity: The level at which a portion of time is expressed, in terms of calendar and clock units.
For example, years are of a coarser granularity than days.
Temporal Four-tuple: For a relation R, a temporal four-tuple TR =

〈
t(1), t(2), t(3), t(4)

〉
represents an

assertion that, based on some evidence, the start date for R is between t(1) and t(2), and its end date is
between t(3) and t(4).
Final Temporal Four-tuple: The four-tuple assigned to R (by an annotator or system) after aggregating
all temporal information about R.
Valid Temporal Four-tuple: A four-tuple T =

〈
t(1), t(2), t(3), t(4)

〉
is valid if and only if iff.

t(1) ≤ t(2) ∧ t(3) ≤ t(4) ∧ t(1) ≤ t(4).
Correct Temporal Four-tuple: A temporal four-tuple TR =

〈
t(1), t(2), t(3), t(4)

〉
if and only if

t(1) ≤ Rs ≤ t(2) ∧ t(3) ≤ Re ≤ t(4)
Intermediate Temporal Relationship: Given a relation mention r of relation R and a normalized time
expression γ (viewed as a temporal interval), the intermediate temporal relationship between the two
characterizes the relationships between the end points of γ and the endpoints of the temporal extension
of R, namely γs, γe, Rs, and Re. In this work, each intermediate temporal relationship used serves as
a mapping from temporal interval to four-tuple (see Table 1 for the relationships used in this work and
their mappings).

1565



Intermediate Temporal Four-tuple Set: For a relation R, a system or annotator may derive an
intermediate temporal four-tuple for each relation mention r and a corresponding time expression γ
by based on an intermediate temporal relationship expressed between the two. The elements of each
intermediate four-tuple are derived using the mapping in Table 1. We denote the set of intermediate
temporal four-tuples for R as I(R).
Query Relation: A relation that serves as input to a TSF system tasked with returning a final temporal
four-tuple for that relation.
Relational Noun Phrase: A noun phrase that expresses a relation. For example, “President Obama”
expresses a relation that “Obama”’s title is “President”.
Time of Predication: For a given predicate, the time of predication is a time interval for which the
predicate is asserted to apply to a specified set of arguments.
Post-relational State: A state immediately following the end of a relation characterized by the relation
now longer holding. For example, prepending a title with “former”, as in “former President X”,
introduces a state characterized by X no longer holding the title President.
Temporally Linked Relations: Two relations are temporally linked if their temporal extensions are not
independent. For example, if it is known that one’s end precedes the other’s start.
Provenance: The relevant text that supports the output.

1566


