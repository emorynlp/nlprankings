



















































A Meaning-Based Statistical English Math Word Problem Solver


Proceedings of NAACL-HLT 2018, pages 652â€“662
New Orleans, Louisiana, June 1 - 6, 2018. cÂ©2018 Association for Computational Linguistics

 
 
 
 

   

 A Meaning-based Statistical English Math Word Problem Solver 

 
 

Chao-Chun Liang, Yu-Shiang Wong, Yi-Chung Lin and Keh-Yih Su 
Institute of Information Science, Academia Sinica, Taiwan 

{ccliang, yushiangwtw, lyc, kysu}@iis.sinica.edu.tw 
 
 
 

Abstract 

We introduce MeSys, a meaning-based ap-
proach, for solving English math word 
problems (MWPs) via understanding and 
reasoning in this paper. It first analyzes the 
text, transforms both body and question 
parts into their corresponding logic forms, 
and then performs inference on them. The 
associated context of each quantity is rep-
resented with proposed role-tags (e.g., 
nsubj, verb, etc.), which provides the flex-
ibility for annotating an extracted math 
quantity with its associated context infor-
mation (i.e., the physical meaning of this 
quantity). Statistical models are proposed 
to select the operator and operands. A 
noisy dataset is designed to assess if a 
solver solves MWPs mainly via under-
standing or mechanical pattern matching. 
Experimental results show that our ap-
proach outperforms existing systems on 
both benchmark datasets and the noisy da-
taset, which demonstrates that the pro-
posed approach understands the meaning 
of each quantity in the text more. 

1 Introduction 

The math word problem (MWP) (see Figure 1) is 
frequently chosen to study natural language un-
derstanding and simulate human problem solving 
(Bakman, 2007; Hosseini et al., 2014; Liang et 
al., 2016) for the following reasons: (1) the an-
swer to the MWP cannot be simply extracted by 
performing keyword/pattern matching. It thus 
shows the merit of understanding and inference. 

(2) An MWP usually possesses less complicated 
syntax and requires less amount of domain 
knowledge, so the researchers can focus on the 
task of understanding and reasoning. (3) The 
body part of MWP that provides the given infor-
mation for solving the problem consists of only a 
few sentences. The understanding and reasoning 
procedures thus could be more efficiently 
checked. (4) The MWP solver has its own appli-
cations such as Computer Math Tutor (for stu-
dents in primary school) and Helper for Math in 
Daily Life (for adults who are not good in solving 
mathematics related real problems). 

According to the approaches used to identify 
entities, quantities, and to select operations and 
operands, previous MWP solvers can be classified 
into: (1) Rule-based approaches (Mukherjee and 
Garain, 20081; Hosseini et al., 2014), which make 
all related decisions based on a set of rules; (2) 
Purely statistics-based approaches (Kushman et 
al., 2014; Roy et al., 2015; Zhou et al., 2015;  
Upadhyay et al., 2016), in which all related deci-
sions are done via a statistical classifier; (3) DNN-
based approaches (Ling et al., 2017; Wang et al., 
2017), which map the given text into the corre-
sponding math operation/equation via a DNN; and 
(4) Mixed approaches, which identify entities and 
quantities with rules, yet, decide operands and op-
erations via statistical/DNN classifiers. This cate-
gory can be further divided into two subtypes: (a) 
Without understanding (Roy and Roth, 2015; 
Koncel-Kedziorski et al., 2015; Huang et al., 
2017; Shrivastava et al., 2017), which does not 
check the entity-attribute consistency between 
each quantity and the target of the given question; 
and (b) With understanding (Lin et al., 2015; Mi-
tra and Baral, 2016; Roy and Roth, 2017), which 
also checks the entity-attribute consistency while 
solving the problem. 
                                                      
1 It is a survey paper which reviews most of the rule-based 
approaches before 2008. 

Math Word Problem 
Mike takes 88 minutes to walk to school. If he rides 
a bicycle to school, it would save him 64 minutes. 
How much time did Mike save? 

Solution 
88 â€“ 64 = 22 

Figure 1: An example of math word problem. 

 
 
 
 
 
 
 
 
 

 

652



 
 
 
 

   

However, a widely covered rule-set is difficult 
to construct for the rule-based approach. Also, it is 
awkward in resolving ambiguity problem. In con-
trast, the performance of purely statistics-based 
approaches deteriorates significantly when the 
MWP includes either irrelevant information or in-
formation gaps (Hosseini et al., 2014), as it is 
solved without first understanding the meaning. 

For the category (4a), since the physical mean-
ing is only implicitly utilized and the result is not 
generated via inference, it would be difficult to 
explain how the answer is obtained in a human 
comprehensible way. Therefore, the categories 
(2), (3) and (4a) belong to the less favored direct 
translation approach2  (Pape, 2004). 

In contrast, the approaches of (4b) can avoid 
the problems mentioned above. However, among 
them, Mitra and Baral (2016) merely handled Ad-
dition and Subtraction. Only the meaning-based 
framework proposed by Lin et al. (2015) can han-
dle general MWPs via understanding and reason-
ing. Therefore, it is possible to explain how the 
answer is obtained in a human comprehensible 
way (Huang et al., 2015). However, although their 
design looks promising, only a few Chinese 
MWPs had been tested and performance was not 
evaluated. Accordingly, it is hard to make a fair 
comparison between their approach and other 
state-of-the-art methods. In addition, in their pro-
totype system, the desired operands of arithmetic 
operations are identified with predefined lexico-
syntactic patterns and ad-hoc rules. Reusing the 
patterns/rules designed for Chinese in another 
language is thus difficult even if it is possible. 

In this paper, we adopt the framework proposed 
by Lin et al. (2015) to solve English MWPs (for 
its potential in solving difficult/complex MWPs 
and providing more human comprehensible ex-
planations). Additionally, we make the following 
improvements: (1) A new statistical model is pro-
posed to select operands for arithmetic operations, 
and its model parameters can be automatically 
learnt via weakly supervised learning (Artzi and 
Zettlemoyer, 2013). (2) A new informative and 
robust feature-set is proposed to select the desired 
arithmetic operation. (3) We show the proposed 
approach significantly outperforms other existing 
systems on the common benchmark datasets re-
ported in the literature. (4) A noisy dataset with 
                                                      
2 According to (Pape, 2004), the meaning-based approach of 
solving MWPs achieves the best performance among vari-
ous behaviors adopted by middle school children. 

more irrelevant quantities in MWPs is created and 
released. It could be used to check if an approach 
really understands what a given MWP looks for. 
(5) An experiment is conducted to compare vari-
ous approaches on this new dataset. The superior 
performance of our system demonstrates that the 
proposed meaning-based approach has good po-
tential in handling difficult/complex MWPs. 

2 System Description 

The adopted meaning-based framework (Lin et 
al., 2015) is a pipeline with following four stages 
(see Figure 2): (1) Language Analysis, (2) Solu-
tion Type Identification, (3) Logic Form Trans-
formation and (4) Logic Inference. We use the 
Stanford CoreNLP suite (Manning et al., 2014) as 
the language analysis module. The other three 
modules are briefly described below. Last, we 
adopt the weakly supervised learning (Artzi and 
Zettlemoyer, 2013; Kushman et al., 2014) to au-
tomatically learn the model parameters without 
manually annotating each MWP with the adopted 
solution type and selected operands benchmark. 

2.1 Solution Type Identification (STI) 
After language analysis, each MWP is assigned 
with a specific solution type (such as Addition, 
Multiplication, etc.) which indicates the stereo-
type math operation pattern that should be adopt-
ed to solve this problem. We classify the English 
MWPs released by Hosseini et al. (2014) and Roy 
and Roth (2015) into 6 different types: Addition, 
Subtraction, Multiplication, Division, Sum and 
TVQ-F3. An SVM (Chang and Lin, 2011) is used 
to identify the solution type with 26 features. Most 
of them are derived from some important proper-
ties associated with each quantity. 

                                                      
3 TVQ-F means to get the final state of a Time-Variant-
Quantity that involves both Addition and Subtraction. 

 
Figure 2: The diagram of MeSys framework 

653



 
 
 
 

   

In addition to the properties Entity4 and Verb 
(Hosseini et al., 2014) associated with the quanti-
ty, we also introduce a new property Time which 
encodes the tense and aspect of a verb into an in-
teger to specify a point in the timeline.  We assign 
2, 4, and 6 to the tenses Past, Present and Future, 
respectively, and then adjust it with the aspect-
values -1, 0 and 1 for Perfect, Simple, and Pro-
gressive, respectively. 

Another property Anchor is associated with the 
unknown quantity asked in the question sentence. 
If the subject of the question sentence is a noun 
phrase (e.g., â€œhow many apples does John 
have?â€), Anchor is the subject (i.e., John). If the 
subject is an expletive nominal (e.g. â€œhow many 
apples are there in the box?â€), then Anchor is the 
associated nominal modifier nmod (i.e., â€œboxâ€).  
Otherwise, Anchor is set to â€œUnknownâ€. 

Inspired by (Hosseini et al., 2014), we trans-
form Verb to Verb-Class (VC) which is positive, 
negative or stative. A verb is positive/negative if it 
increases/decreases the associated quantity of the 
subject. For example, in the sentence â€œTom bor-
rowed 3 dollars from Mikeâ€, the verb is positive 
because the money of subject â€œTomâ€ increases. 

However, a positive verb does not always imply 
the Addition operation. If the question is â€œHow 
much money does Mike have now?â€ for the above 
body sentence, the operation should be Subtrac-
tion. Two new properties Anchor-Role (AR) and 
Action (A) are thus proposed: ARi indicates the 
role that Anchor associated with qi, and is set to 
nsubj/obj/nmod/Ï†. Ai is determined by following 
rules: (1) Ai=positive if (VCi, ARi) is either (posi-
tive, nsubj) or (negative, obj/nmod). (2) 
Ai=negative if (VCi, ARi) is either (negative, 

                                                      
4 In our works, the term â€œEntityâ€ also includes the unit of 
the quantity (e.g., â€œcup of coffeeâ€). 

nsubj) or (positive, obj/nmod). (3) Otherwise,  
Ai=VCi. 

To rule out the noisy quantities introduced by 
irrelevant information, we further associate each 
known quantity with the property Relevance (R) 
according to the unknown quantity asked in the 
question sentence. Let qi denote the i-th known 
quantity, Ei denote the entity of qi, Xi denote the 
property X of qi, qU denote the unknown quantity 
asked, and XU denote the property X of qU. Ri is 
specified with following rules: (1) Ri=2 (Directly-
Related) if either {Anchor is Unknown & Ei en-
tails EU} or {Anchor is not Unknown & ARiâ‰ Ï† & 
Ei entails EU} (2) Ri=1 (Indirectly-Related) if 
there is a qj which maps5 to  qi and Rj=2 (i.e., qj is 
Directly-Related). (3) Ri=0 (Unrelated) otherwise. 

The solution type is identified by an SVM 
based on 26 binary features. Let the symbols p, n, 
s, A, E, R, T, V, SB, SQ and wQ stand for positive, 
negative, stative, Action, Entity, Relevance, Time, 
Verb, â€œa body sentenceâ€, â€œthe question sentenceâ€ 
and â€œa word in question sentenceâ€ respectively. 
Also, let I(x) be the indicator function to check if x 
is true. The 26 features are briefly described as 
follows: 

(1) VCU=p;  (2) âˆƒRi=2 s.t. Ai=p;  (3) âˆƒRi=2 s.t. Ai=n;   
(4) âˆƒRi=2 s.t. Ai=s;  (5) âˆ‘ğ‘–ğ‘– I( Ri =2) > 2;  
(6) âˆ‘ğ‘–ğ‘– I( Ri=2 & Ai âˆˆ{p, n} ) = 2; 
(7) âˆƒRi=2 s.t. Ai=p & TU<Ti; 
(8) âˆƒRi=2 s.t. Ai=n & TU<Ti;   
(9) âˆƒRi=2 s.t. Ai=s & Ti=max Tj; 
(10) âˆƒRi=2 s.t. Ai=s & Ti<TU; 
(11) TU â‰¥ max Ti;   (12) TU â‰¤ min Ti;   
(13) âˆ€Ri=2, Vi are the same;  (14) âˆ€Ri=2 s.t. Ti=TU;   
(15) âˆ€Ri=2, Ti are the same;  
(16) âˆƒRi=2, âˆƒRj=1 s.t. qi maps to qj & qi > qj; 

                                                      
5 That is, ğ‘ğ‘ğ‘–ğ‘– is linked to a directly-related quantity ğ‘ğ‘ğ‘—ğ‘— under 
an expression such as â€œ2 pencils weigh 30 gramsâ€. 

 
Figure 3: An example of logic form transformation 

 

654



 
 
 
 

   

(17) âˆƒRi=2, âˆƒRj=1 s.t. qi maps to qj & qi is associated 
with a word â€œeach/every/per/a/anâ€;  

(18) âˆƒRi=2, âˆƒRj=1 s.t. qi maps to qj & qj is associated 
with a word â€œeach/every/per/a/anâ€;  

(19) âˆƒqi, qj, qk s.t. Ri = Rj = Rk =2 & Vi = Vj = Vk;  
(20) âˆƒwQ âˆˆ{total, in all, altogether, sum};  
(21) âˆƒwQ âˆˆ{more, than} or âˆƒwQ s.t. wQ-POS=RBR;   
(22) âˆƒwQ =â€œleftâ€;  (23). âˆƒqi appears in SQ; 
(24) â€œthe rest V EUâ€ appears in SB (V for any verb); 
(25) â€œeach NNâ€ appears in SQ (NN for any noun); 
(26) AnchorU is Unknown/nmod & VCU = s. 

2.2 Logic Form Transformation (LFT) 
The results of language analysis are transformed 
into a logic form, which is expressed with the 
first-order logic (FOL) formalism (Russell and 
Norvig, 2009). Figure 3 shows how to transform 
the sentence (a) â€œPack 100 candies into 5 boxes.â€ 
into the corresponding logic form (d). First, the 
dependency tree (b) is transformed into the se-
mantic representation tree (c) adopted by Lin et 
al., (2015). Afterwards, according to the procedure 
proposed in (Lin et al., 2015), the domain-
dependent logic expressions are generated in (d). 

The domain-dependent logic expressions are 
related to crucial generic math facts, such as quan-
tities and relations between quantities. The FOL 
function quan(quanid, unit6,entity)=number is for 
describing the quantity fact. The first argument 
denotes its unique identifier. The other arguments 
and the function value describe its meaning. An-
other FOL predicate qmap(mapid, quanid1, quanid2) 
(denotes the mapping from quanid1 to quanid2) is 
for describing a relation between two quantity 
facts, where the first argument is a unique identi-
fier to represent this relation. 

The role-tags (e.g., verb, dobj, etc.) associated 
with  quanid  and  mapid  denote  entity  attributes 
(i.e., the physical meaning of the quantity), are 
created to help the logic inference module find the 
                                                      
6 This second argument denotes the associated unit used to 
count the entity. It is set to â€œ#â€ if the unit of the entity is not 
specified. 

solution. For example, quan(q2,#,box) = 5 & 
verb(q2,pack) &â€¦ means that q2 is the quantity of 
boxes being packed. With those role-tags, the sys-
tem can select the operands more reliably, and the 
inference engine can also derive new quantities to 
solve complex MWPs which require multi-step 
arithmetic operations (see section 2.3). 

The question in the MWP is also transformed 
into an FOL-like utility function according to the 
solution type to ask the logic inference module to 
find out the answer. For example, the utility func-
tion instance Division(quan(q1, #, candy), 
quan(q2, #, box)) asks the inference module to di-
vide â€œ100 candiesâ€ by â€œ5 boxesâ€. Since associated 
operands must be specified before calling those 
utility functions, a statistical model (see section 
2.4) is used to identify the appropriate quantities. 

2.3 Logic Inference 
The logic inference module adopts the inference 
engine from (Lin et al., 2015). Figure 4 shows how 
it uses inference rules to derive new facts from the 
initial facts directly provided from the description. 
The MWP (a) provides some facts (b) generated 
from the LFT module. An inference rule (c) 7 , 
which implements the common sense that people 
must pay money to buy something, is unified with 
the given facts (b) and derives new facts (d). The 
facts associated with q6 can be interpreted as 
â€œMary paid 0.5 dollar for two puddingsâ€. 

The inference engine (IE) also provides 5 utili-
ty functions, including Addition, Subtraction, 
Multiplication and Division, and Sum. The first 
four utilities all return a value by performing the 
named math operation on its two input arguments. 
On the other hand, Sum(function,condition) re-
turns the sum of the values of FOL function in-
stances which can be unified with the first argu-
ment (i.e., function) and satisfy the second argu-
ment (i.e., condition). For example, according to 
                                                      
7 In the inference rule, $q is a meta symbol to ask the infer-
ence engine to generate a unique identifier for the newly de-
rived quantity fact. 

(a) A sandwich is priced at $0.75. A pudding is priced at $0.25. Tim bought 2 sandwiches and 4 puddings. Mary bought 2 puddings. 
How much money should Tim pay? 

(b) â€¦price(sandwich,0.75)&price(pudding,0.25)â€¦   quan(q1,#,sandwich)=2&verb(q1,buy)&nsubj(q1,Tim)â€¦ 
quan(q2,#,pudding)=4&verb(q2,buy)&nsubj(q2,Tim)â€¦   quan(q3,#,pudding)=2&verb(q3,buy)&nsubj(q3,Mary)â€¦ 
ASK Sum(quan(?q,dollar,#),verb(?q,pay)&nsubj(?q,Tim)) 

(c) quan(?q,?u,?o)&verb(?q,buy)&nsubj(?q,?a)&price(?o,?p) ïƒ  quan($q,dollar,#)=quan(?q,?u,?o)Ã—?p & verb($q,pay) & nsubj($q,?a) 
(d) quan(q4,dollar,#)=1.5&verb(q4,pay)&nsubj(q4,Tim)â€¦   quan(q5,dollar,#)=1&verb(q5,pay)&nsubj(q5,Tim)â€¦ 

quan(q6,dollar,#)=0.5&verb(q6,pay)&nsubj(q6,Mary) 
Figure 2: A logic inference example 

(a) A sandwich is priced at $0.75. A pudding is priced at $0.25. Tim bought 2 sandwiches and 4 puddings. Mary bought 2 puddings. 
How much money should Tim pay? 

(b) â€¦price(sandwich,0.75)&price(pudding,0.25)â€¦   quan(q1,#,sandwich)=2&verb(q1,buy)&nsubj(q1,Tim)â€¦ 
quan(q2,#,pudding)=4&verb(q2,buy)&nsubj(q2,Tim)â€¦   quan(q3,#,pudding)=2&verb(q3,buy)&nsubj(q3,Mary)â€¦ 
ASK Sum(quan(?q,dollar,#),verb(?q,pay)&nsubj(?q,Tim)) 

(c) quan(?q,?u,?o)&verb(?q,buy)&nsubj(?q,?a)&price(?o,?p) ïƒ  quan($q,dollar,#)=quan(?q,?u,?o)Ã—?p & verb($q,pay) & nsubj($q,?a) 
(d) quan(q4,dollar,#)=1.5&verb(q4,pay)&nsubj(q4,Tim)â€¦   quan(q5,dollar,#)=1&verb(q5,pay)&nsubj(q5,Tim)â€¦ 

quan(q6,dollar,#)=0.5&verb(q6,pay)&nsubj(q6,Mary) 
Figure 4: A logic inference example 

655



 
 
 
 

   

the last line in Figure 4(b), three newly derived 
quantity facts q4, q5 and q6 (in 4(d)) can be uni-
fied with the first argument quan(?q,dollar,#) in 
4(c), but only q4 and q5 satisfy the second ar-
gument verb(?q,pay)&nsubj(?q,Tim). As a result, 
the answer 2.5 is returned by taking sum on the 
values of the quantity facts quan(q4,dollar,#) and 
quan(q5,dollar,#).  

2.4 Probabilistic Operand Selection 
The most error-prone part in the LFT module is 
instantiating the utility function of math operation 
especially if many irrelevant quantity facts appear 
in the given MWP. Figure 5 shows the LFT mod-
ule needs to select two quantity facts (among 4) 
for Addition. Please note that the question quantity 
qQ, transformed from â€œhow many flowersâ€, is not a 
candidate for operand selection. 

Lin et al., (2015) used predefined lexico-
syntactic patterns and ad-hoc rules to instantiate 
utility functions. However, their rule-based ap-
proach fails when the MWP involves more quanti-
ties. Therefore, we propose a statistical model to 
select operands for the utility functions Addition, 
Subtraction, Multiplication and Division. The op-
erand selection procedure can be regarded as find-
ing the most likely configuration (ğ‘œğ‘œ1ğ‘›ğ‘›, ğ‘Ÿğ‘Ÿ), where 
ğ‘œğ‘œ1ğ‘›ğ‘› = ğ‘œğ‘œ1,â‹¯ , ğ‘œğ‘œğ‘›ğ‘›  is a sequence of random indica-
tors which denote if the corresponding quantity 
will be selected as an operand, and ğ‘Ÿğ‘Ÿ is a tri-state 
variable to represent the relation between the val-
ues of two operands (i.e., ğ‘Ÿğ‘Ÿ = âˆ’1, 0 or 1 ; which 
denote that the first operand is less than, equal to, 
or greater than the second operand, respectively). 
Given a solution type ğ‘ ğ‘ , the MWP logic expres-
sions ğ•ƒğ•ƒ and the ğ‘›ğ‘› quantities ğ‘ğ‘1ğ‘›ğ‘› = ğ‘ğ‘1,â‹¯ , ğ‘ğ‘ğ‘›ğ‘›  in ğ•ƒğ•ƒ. 
The procedure is formulated as: 

ğ‘ƒğ‘ƒ(ğ‘Ÿğ‘Ÿ, ğ‘œğ‘œ1ğ‘›ğ‘›|ğ‘ğ‘1ğ‘›ğ‘›,ğ•ƒğ•ƒ, ğ‘ ğ‘ ) â‰ˆ ğ‘ƒğ‘ƒ(ğ‘Ÿğ‘Ÿ|ğ‘ ğ‘ ) Ã— ğ‘ƒğ‘ƒ(ğ‘œğ‘œ1ğ‘›ğ‘›|ğ‘ğ‘1ğ‘›ğ‘›,ğ•ƒğ•ƒ, ğ‘ ğ‘ ), (1) 

ğ‘ƒğ‘ƒ(ğ‘Ÿğ‘Ÿ|ğ‘ ğ‘ ) simply refers to Relative Frequency (as it 
has only a few parameters and we have enough 
training samples).  ğ‘ƒğ‘ƒ(ğ‘œğ‘œ1ğ‘›ğ‘›|ğ‘ğ‘1ğ‘›ğ‘›,ğ•ƒğ•ƒ, ğ‘ ğ‘ )  is further de-
rived as: 

ğ‘ƒğ‘ƒ(ğ‘œğ‘œ1ğ‘›ğ‘›|ğ‘ğ‘1ğ‘›ğ‘›,ğ•ƒğ•ƒ, ğ‘ ğ‘ )
â‰ˆ âˆ ğ‘ƒğ‘ƒ(ğ‘œğ‘œğ‘–ğ‘–|ğ‘ğ‘ğ‘–ğ‘– ,ğ•ƒğ•ƒ, ğ‘ ğ‘ )ğ‘›ğ‘›ğ‘–ğ‘–=1 â‰ˆ âˆ ğ‘ƒğ‘ƒï¿½ğ‘œğ‘œğ‘–ğ‘–ï¿½Î¦(ğ‘ğ‘ğ‘–ğ‘– ,ğ•ƒğ•ƒ, ğ‘ ğ‘ )ï¿½,ğ‘›ğ‘›ğ‘–ğ‘–=1

  (2) 

where Î¦(âˆ™) is a feature extraction function to map 
ğ‘ğ‘ğ‘–ğ‘– and its context into a feature vector. Here, the 
probabilistic factor ğ‘ƒğ‘ƒï¿½ğ‘œğ‘œğ‘–ğ‘–ï¿½Î¦(ğ‘ğ‘ğ‘–ğ‘–,ğ•ƒğ•ƒ, ğ‘ ğ‘ )ï¿½  is obtained 
via an SVM classifier (Chang and Lin, 2011). 
Î¦(âˆ™) extracts total 25 features (specified as fol-

lows, and 24 of them are binary) for ğ‘ğ‘ğ‘–ğ‘–. The fol-
lowing 11 of them are independent on the ques-
tion in the MWP: 

1. Four features to indicate if ğ‘ ğ‘  is Addition, Sub-
traction, Multiplication or Division. 

2. A feature to indicate if ğ‘ğ‘ğ‘–ğ‘–  is within a 
qmap(â€¦). 

3. A feature to indicate if ğ‘ğ‘ğ‘–ğ‘– = 1. 
4. Five features to indicate if ğ‘›ğ‘› < 2, ğ‘›ğ‘› = 2, ğ‘›ğ‘› =

3, ğ‘›ğ‘› = 4 or ğ‘›ğ‘› > 4; where ğ‘›ğ‘› is the number of 
quantities in Eq (1). 

Î¦(âˆ™) also extracts features by matching the logic 
expressions of ğ‘ğ‘ğ‘–ğ‘– with those of question quantity 
qQ to check the role-tag consistencies between ğ‘ğ‘ğ‘–ğ‘– 
and qQ. Another fourteen features are extracted 
with three indicator functions ğ¼ğ¼ğ‘šğ‘š(â‹…), ğ¼ğ¼ğ‘’ğ‘’(â‹…),
ğ¼ğ¼âˆƒ(â‹…) and one tri-state function ğ‘‡ğ‘‡ğ‘šğ‘š(â‹…) as follows: 

[ ğ¼ğ¼ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘– , qQ, entity), ğ¼ğ¼ğ‘’ğ‘’(ğ‘ğ‘ğ‘–ğ‘– , qQ, entity),
 ğ¼ğ¼ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘– , qQ, verb), ğ¼ğ¼ğ‘’ğ‘’(ğ‘ğ‘ğ‘–ğ‘– , qQ, verb),
 ğ¼ğ¼âˆƒ(qQ, nsubj),ğ‘‡ğ‘‡ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘– , qQ, nsubj),
 ğ¼ğ¼âˆƒ(qQ, modifier), ğ¼ğ¼ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘– , qQ, modifier),   
 ğ¼ğ¼âˆƒ(qQ, place), ğ¼ğ¼ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘– , qQ, place),
 ğ¼ğ¼âˆƒ(qQ, temporal), ğ¼ğ¼ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘– , qQ, temporal),
 ğ¼ğ¼âˆƒ(qQ, xcomp), ğ¼ğ¼ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘– , qQ, xcomp) ]

 

where the indicator functions ğ¼ğ¼ğ‘šğ‘š(ğ‘¥ğ‘¥,ğ‘¦ğ‘¦, ğ‘§ğ‘§) checks if 
the ğ‘§ğ‘§ of ğ‘¥ğ‘¥ matches the ğ‘§ğ‘§ of ğ‘¦ğ‘¦, ğ¼ğ¼ğ‘’ğ‘’(ğ‘¥ğ‘¥,ğ‘¦ğ‘¦, ğ‘§ğ‘§) checks if 
the ğ‘§ğ‘§ of ğ‘¥ğ‘¥ entails the ğ‘§ğ‘§ of ğ‘¦ğ‘¦ and ğ¼ğ¼âˆƒ(ğ‘¦ğ‘¦, ğ‘§ğ‘§) checks if 
the ğ‘§ğ‘§ of ğ‘¦ğ‘¦ exists. ğ‘‡ğ‘‡ğ‘šğ‘š(ğ‘ğ‘ğ‘–ğ‘–, qQ, nsubj) returns â€œexact-
matchâ€ (if nsubj of ğ‘ğ‘ğ‘–ğ‘–  matches nsubj of qQ ), 
â€œquasi-matchâ€ (if nsubj of qQ does not exist or is a 
plural pronoun), and â€œunmatchâ€. 
ğ¼ğ¼ğ‘’ğ‘’(â‹…)  uses the WordNet hypernym and 

hyponym relationship to judge whether one 
entity/verb entails another one or not via checking 
if they are in an inherited hypernym-path in 
WordNet. The entity, verb and nsubj of a quantity 
are determined according to the logic expressions. 
The modifier, place, temporal and xcomp of a 
quantity are extracted from the dependency tree 
with some lexico-syntactic patterns. For example, 
the modifier and place of the quantity in the 
sentence â€œThere are 30 red flowers in the garden.â€ 
are â€œredâ€ and â€œgardenâ€ respectively. The temporal 

(a)  Tim bought 2 roses and 3 lilies. Mary bought 4 roses 
and 5 lilies. How many flowers did Tim buy? 

(b) quan(q1,#,rose)=2&verb(q1,buy)&nsubj(q1,Tim)â€¦ 
quan(q2,#,lily)=3&verb(q2,buy)&nsubj(q2,Tim)â€¦ 
quan(q3,#,rose)=4&verb(q3,buy)&nsubj(q3,Mary)â€¦ 
quan(q4,#,lily)=5&verb(q4,buy)&nsubj(q4,Mary)â€¦ 
quan(qQ,#,flower)&verb(qQ,buy)&nsubj(qQ,Tim)â€¦ 

Figure 5: An example for operand selection 
 

656



 
 
 
 

   

and xcomp of a quantity are extracted according to 
the dependency relations â€œtmodâ€ (i.e., temporal 
modifier) and â€œxcompâ€ (i.e., open clausal 
complement), respectively. 

3 Datasets for Performance Evaluation  

The AI2 dataset provided by Hosseini et al. (2014) 
and the IL dataset released by Roy and Roth 
(2015) are adopted to compare our approach with 
other state-of-the-art methods. The AI2 dataset 
has 395 MWPs on addition and subtraction, with 
121 MWPs containing irrelevant information 
(Hosseini et al., 2014). It is the most popular one 
for comparing different approaches. On the other 
hand, the IL dataset consists of 562 elementary 
MWPs which can be solved by one of the four 
arithmetic operations (i.e., +, âˆ’, Ã—, and Ã·) without 
any irrelevant quantity. It is the first publicly 
available dataset for comparing performances that 
covers all four arithmetic operations. 

However, the difficulty of solving an MWP de-
pends not only on the number of arithmetic opera-
tions required, but also on how many irrelevant 
quantities inside, and even on how the quantities 
are described. One way to test if a proposed ap-
proach solves the MWPs with understanding is to 
check whether it is robust to those irrelevant quan-
tities. Therefore, it is desirable to have a big 
enough dataset that contains irrelevant quantities 
which are created under different situations (e.g., 
confusing with an irrelevant agent, entity, or mod-
ifier, etc.) and allow us to probe the system weak-
ness from different angles. We thus create a new 
dataset with more irrelevant quantities8. But be-
fore we do that, we need to know how difficult the 
task of solving the given MWPs is. Therefore, we 
first propose a way to measure how easy that a 
system solves the problem by simply guessing. 

3.1 Perplexity-flavor Measure 
We propose to adopt the Perplexity to measure the 
task difficulty, which evaluates how likely a solver 
will get the correct answer by guessing. Every 
MWP in the datasets can be associated with a so-
lution expression template, such as â€œâŠ¡ + âŠ¡â€ or 
â€œâŠ¡âˆ’âŠ¡â€, where the symbol  âŠ¡ represents a slot 
to hold a quantity. The solution can be obtained by 
placing correct quantities at appropriate slots. A 
                                                      
8 The IL dataset does not include any irrelevant information; 
on the other hand, the AI2 dataset only contains 121 MWPS 
with irrelevant information (but not systematically created). 

random baseline is to solve an MWP by guessing. 
It first selects a solution expression template ac-
cording to the prior distribution of the templates 
and then places quantities into the selected tem-
plate according to the uniform distribution. 

The expected accuracy of the random baseline 
on solving an MWP is a trivial combination and 
permutation exercise9. For example, the expected 
accuracy of solving an MWP associated with â€œâŠ¡
+ âŠ¡â€ template is ğ‘ğ‘âŠ¡+âŠ¡ Ã— ğ¶ğ¶ğ‘›ğ‘› 2

âˆ’1
, where the fac-

tor ğ‘ğ‘âŠ¡+âŠ¡  denotes the prior probability of the 
template â€œâŠ¡ + âŠ¡â€ and ğ‘›ğ‘› is the total number of 
quantities (including irrelevant ones) in the MWP. 
On the other hand, expected accuracy of solving 
an MWP associated with â€œâŠ¡âˆ’âŠ¡â€10 template is 
ğ‘ğ‘âŠ¡âˆ’âŠ¡ Ã— ğ‘ƒğ‘ƒğ‘›ğ‘› 2

âˆ’1
. Let ğ´ğ´ğ‘–ğ‘– denote the expected accu-

racy of solving the ğ‘–ğ‘–-th MWP in a dataset. The ac-
curacy of the random baseline on the dataset of 
size ğ‘ğ‘ is then computed as ğ´ğ´ = (1/ğ‘ğ‘) Ã— âˆ‘ ğ´ğ´ğ‘–ğ‘–ğ‘ğ‘ğ‘–ğ‘–=1 . 

The word â€œAccuracyâ€ comprises the opposite 
sense of the word â€œPerplexityâ€11 (i.e., in the sense 
of how hard a prediction problem is). The lower 
the Accuracy is, the higher the Perplexity is. 
Therefore, we transform the Accuracy measure in-
to a Perplexity-Flavor measure (PP) via the for-
mula: 

PP = 2âˆ’ log2 ğ´ğ´ 
For instance, the Perplexity-Flavor measures of 
AI2 and IL datasets are 4.46 and 8.32 respectively. 

3.2 Noisy Dataset 
Human Math/Science tests have been considered 
more suitable for judging AI progress than Turing 
test (Clark and Etzioni, 2016). In our task, solving 
MWPs is mainly regarded as a test for intelligence 
(not just for creating a Math Solver package). By 
injecting various irrelevant quantities into original 
MWPs, a noisy dataset is thus created to assess if 
a solver solves the MWPs mainly via understand-
ing or via mechanical/statistical pattern matching. 
If a system solves an MWP mainly via pattern 
matching, it would have difficulty in solving a 
similar MWP augmented from the original one 
with some irrelevant quantities. Therefore, we 
first create a noisy dataset by selecting some 
                                                      
9 Let ğ¶ğ¶ğ‘›ğ‘› ğ‘˜ğ‘˜ denote ğ‘˜ğ‘˜-combinations of ğ‘›ğ‘› and ğ‘ƒğ‘ƒğ‘›ğ‘› ğ‘˜ğ‘˜ denote ğ‘˜ğ‘˜-
permutations of ğ‘›ğ‘›. 
10 We assume the operands have different values and, there-
fore, they are not permutable for the subtraction operator. 
11 The Perplexity of a uniform distribution over k discrete 
events (such as casting a fair k-sided dice) is k. 

657



 
 
 
 

   

MWPs that can be correctly solved, and then 
augmenting each of them with an additional noisy 
sentence which involves an irrelevant quantity. 
This dataset is created to examine if the solver 
knows that this newly added quantity is irrelevant. 

Figure 6 shows how we inject noise into an 
MWP (a).  (a.1) is  created  by  associating  an  ir-
relevant quantity to a new subject (i.e., Mary). 
Here the ellipse symbol â€œâ€¦â€ denotes unchanged 
text. (a.2) is obtained by associating an irrelevant 
quantity to a new entity (i.e., books). In addition, 
we also change modifiers (such as yellow, red, â€¦) 
to add new noisy sentence (not shown here). Since 
the noisy dataset is not designed to assess the lexi-
con coverage rate of a solver, we reuse the words 
in the original dataset as much as possible while 
adding new subjects, entities and modifiers. 

136 MWPs that both Illinois Math Solver 12 
(Roy and Roth, 2016) and our system can correct-
ly solve are selected from the AI2 and IL datasets. 
This subset is denoted as OSS (Original Sub-Set). 
Afterwards, based on the 136 MWPs of OSS, we 
create a noisy dataset of 396 MWPs by adding ir-
relevant quantities. This noisy dataset is named as 
NDS13. Table 1 lists the size of MWPs, Perplexi-
ties (PP), and the average numbers of quantities in 
each MWP of these two datasets. 

4 Experimental Results and Discussion 

We compare our approach with (Roy and Roth, 
2015) and (Roy and Roth, 2017) because they 
achieved the state-of-the-art performance on the 
IL dataset. In the approach of (Roy and Roth, 
2015), each quantity in the MWP was associated 
with a quantity schema whose attributes are ex-
tracted from the context of the quantity. Based on 
the attributes, several statistical classifiers were 
used to select operands and determine the opera-
tor. They also reported the performances on the 
AI2 dataset to compare their approach with those 
                                                      
12 We submit MWPs to Illinois Math Solver 
(https://cogcomp.cs.illinois.edu/page/demo_view/Math) in 
May and June, 2017. 
13 The noisy dataset can be downloaded from 
https://github.com /chaochun/nlu-mwp-noise-dataset. It in-
cludes 102 Addition, 147 Subtraction, 101 Multiplication 
and 46 Division MWPs. 

of others (e.g., Kushman et al. (2014), which is a 
purely statistical approach that aligns the text with 
various pre-extracted equation templates). Roy 
and Roth (2017) further introduced the concept of 
Unit Dependency Graphs to reinforce the con-
sistency of physical units among selected oper-
ands associated with the same operator. 

To compare the performance of the statistical 
method with the DNN approach, we only imple-
ment a Bi-directional RNN-based Solution Type 
Identifier (as our original statistical Operand Se-
lector is relatively much better). It consists of a 
word embedding layer (for both body and ques-
tion parts), and a bidirectional GRU layer as an 
encoder. We apply the attention mechanism to 
scan all hidden state sequence of body by the last 
hidden state of question to pay more attention to 
those more important (i.e., more similar between 
the body and the question) words. Lastly, it out-
puts the solution type by a softmax function. We 
train it for 100 epochs, with mini-batch-size = 128 
and learning-rate = 0.001; the number of nodes in 
the hidden layer is 200, and the drop-out rate is 
0.714.   

We follow the same n-fold cross-validation 
evaluation setting adopted in (Roy and Roth, 
2015) exactly. Therefore, various performances 
could be directly compared. Table 2 lists the accu-
racies of different systems in solving the MWPs 
                                                      
14 Since the dataset is not large enough for splitting a devel-
opment set, we choose those hyper parameters based on the 
test set in coarse grain. Therefore, the DNN performance we 
show here might be a bit optimistic. 

 AI2 IL 
STI (Statistical) 83.0 83.1 

STI (DNN) 74.5 68.8 
LFT 92.1 94.8 

Table 3: Performances of different STIs and LFT 

(a) Tim has 10 yellow flowers and 12 red flowers. How 
many flowers does Tim have? 

(a.1) Tim has â€¦ Mary has 3 yellow flowers. How many â€¦ 
(a.2) Tim has â€¦ Tim also has 3 books. How many â€¦ 

Figure 6: Examples of noisy sentences 

 OSS NDS 
# MWPs 136 396 

Perplexity (PP) 7.42 18.83 
#Quantities 2.64 3.62 

Table 1: Perplexity measures of OSS and NDS  

 AI2 IL 
Our system (Statistical) 81.5 81.0 
Our system (DNN) 69.8 70.6 
(Roy and Roth, 2017) 76.2 74.4 
(Roy and Roth, 2015) 78.0 73.9 
(Kushman et al., 2014) 64.0 73.7 

Table 2: Performances of various approaches 

658



 
 
 
 

   

of various datasets. The performance of (Roy and 
Roth, 2017) system is directly delivered by their 
code15. The last two rows are extracted from (Roy 
and Roth, 2015). The results show that our per-
formances of the statistical approach significantly 
outperform that of our DNN approach and other 
systems on every dataset. 

The performances of STI and LFT modules are 
listed in Table 3. As described in section 2, the 
benchmark for both solution type and the operand 
selection benchmark are automatically determined 
by weakly supervised learning. The first and sec-
ond rows of Table 3 show the solution type accu-
racies of our statistical and DNN approaches, re-
spectively. The third row shows the operand selec-
tion accuracy obtained by given the solution type 
benchmark. Basically, LFT accuracies are from 
92% to 95%, and the system accuracies are domi-
nated by STI. We analyzed errors resulted from 
our statistical STI on AI2 and IL datasets, respec-
tively. For AI2, major errors come from: (1) fail-
ure of ruling out some irrelevant quantities (40%), 
and (2) making confusion between TVQ-F and 
Sum these two solution types (20%) for those cas-
es that only involve addition operation (however, 
both types would return the same answer). For IL, 
major errors come from: (1) requiring additional 
information (35%), and (2) not knowing Part-
Whole relation (17%). Table 4 shows a few ex-
amples for different STI error types. 

The left-half of Table 5 shows the performances 
on the OSS and NDS datasets. Recall that OSS is 
created by selecting some MWPs which both Illi-
nois Math Solver (Roy and Roth, 2016) and our 
system16 can correctly solve. Therefore, both sys-
tems have 100% accuracy in solving the OSS da-
taset. However, these two systems behave very 
differently while solving the noisy dataset. The 
much higher accuracy of our system on the noisy 
dataset shows that our meaning-based approach 
understands the meaning of each quantity more. 
Therefore, it is less confused17 with the irrelevant 
quantities.  

One MWP in the noisy dataset that confuses Il-
linois Math Solver (IMS) is â€œTom has 9 yellow 
balloons. Sara has 8 yellow balloons. Bob has 5 
yellow flowers. How many yellow balloons do 
                                                      
15 https://github.com/CogComp/arithmetic. 
16 In evaluating the performances on OSS and NDS datasets, 
our system is trained on the folds 2-5 of the IL dataset. 
17 Since the gap between two different types of approaches 
is quite big, those 396 examples on OSS and 196 examples 
on NDS are sufficient to confirm the conclusion. 

they have in total?â€, where the underlined sen-
tence is the added noisy sentence. The solver sums 
all quantities and gives the wrong answer 22, 
which reveals that IMS cannot understand that the 
quantity â€œ5 yellow flowersâ€ is irrelevant to the 
question â€œHow many yellow balloons?â€. On the 
contrary, our system avoids this mistake. 

Although the meaning of each quantity is ex-
plicitly checked in our LFT module, our system 
still cannot correctly solve all MWPs in NDS. The 
error analysis reveals that the top-4 error sources 
are STI, LFT, CoreNLP and incorrect problem 
construction (for 27%, 27%, 18%, 18%), which 
indicates that our STI and LFT still cannot com-
pletely prevent the damage caused from the noisy 
sentences (which implies that more consistency 
check for quantity meaning should be done). The 
remaining errors are due to incorrect quantity ex-
traction, lacking common-sense or not knowing 
entailment relationship between two entities. 

A similar experiment is performed to check if 
the DNN approach will be affected by the noisy 
information more. We first select 124 MWPs (de-
noted as OSSâ€²) from OSS that can be correctly 
solved by both our statistical and DNN approach-
es and then filter out 350 derived MWPs (denotes 
as NDSâ€²) from NDS. The right-half of Table 5 
shows that the performance of the DNN approach 
drops more than the statistical approach does in 
the noisy dataset, which indicates that our statisti-
cal approach is less sensitive to the irrelevant 
quantities and more close to humanâ€™s approach. 

 
Statis-
tical 

R&R,  
2016 

 Statis-
tical DNN 

OSS 100 100 OSSâ€² 100 100 
NDS 82.1 28.5 NDSâ€² 81.4 75.4 

Table 5: Performances on the OSS and NDS 

Error Type Example 
Confusing 
TVQ-F and 
Sum solu-
tion type 

Sally found 9 seashells, Tom found 
7 seashells, and Jessica found 5 sea-
shells on the beach. How many sea-
shells did they find together? 

Requiring 
additional 

information 

A garden has 52 rows and 15 col-
umns of bean plans. How many 
plants are there in all? 

Not know-
ing Part-

Whole re-
lationship 

Eric wants to split a collection of 
peanuts into groups of 8. Eric has 64 
peanuts. How many groups will be  
created? 

Table 4: Examples for different STI error types 

659



 
 
 
 

   

5 Related Work 

To the best of our knowledge, MWP solvers pro-
posed before 2014 all adopted the rule-based ap-
proach. Mukherjee and Garain (2008) had given a 
good survey for all related approaches before 
2008. Afterwards, Ma et al. (2010) proposed a 
MSWPAS system to simulate human arithmetic 
multi-step addition and subtraction behavior with-
out evaluation. Besides, Liguda and Pfeiffer 
(2012) proposed a model based on augmented 
semantic networks, and claimed that it could solve 
multi-step MWPs and complex equation systems 
and was more robust to irrelevant information (al-
so no evaluation). 

Recently, Hosseini et al. (2014) proposed a 
Container-Entity based approach, which solved 
the MWP with a sequence of state transition. And 
Kushman et al. (2014) proposed the first statistical 
approach, which heuristically extracts some alge-
braic templates from labeled equations, and then 
aligns them with the given sentence. Since no se-
mantic analysis is conducted, the performance is 
quite limited. 

In more recent researches (Roy and Roth, 2015; 
Koncel-Kedziorski et al., 2015; Roy and Roth, 
2017), quantities in an MWP were associated with 
attributes extracted from their contexts. Based on 
the attributes, several statistical classifiers were 
used to select operands and determine operators to 
solve multi-step MWPs. Since the physical mean-
ing of each quantity is not explicitly considered in 
getting the answer, the reasoning process cannot 
be explained in a human comprehensible way. Be-
sides, Shi et al. (2015) attacked the number word 
problem, which only deal with numbers, with a 
semantic parser. Mitra and Baral (2016) mapped 
MWPs into three types of problems, including 
Part-Whole, Change and Comparison. Each prob-
lem was associated with a generic formula. They 
used a log-linear model to determine how to in-
stantiate the formula with quantities and solve the 
only one Unknown variable. They achieved the 
best performance on the AI2 dataset. However, 
their approach cannot handle Multiplication or 
Division related MWPs. Recently, DNN-based 
approaches (Ling et al, 2017; Wang et al, 2017) 
have emerged. However, they only attacked alge-
braic word problems, and required a very large 
training-set. 

Our proposed approach mainly differs from 
those previous approaches in combining the statis-
tical framework with logic inference, and also in 

adopting the meaning-based statistical approach 
for selecting the desired operands. 

6 Conclusion 

A meaning-based logic form represented with 
role-tags (e.g., nsubj, verb, etc.) is first proposed 
to associate the extracted math quantity with its 
physical meaning, which then can be used to iden-
tify the desired operands and filter out irrelevant 
quantities. Afterwards, a statistical framework is 
proposed to perform understanding and reasoning 
based on those logic expressions. We further 
compare the performance with a typical DNN ap-
proach, the results show the proposed approach is 
still better. We will try to integrate domain con-
cepts into the DNN approach to improve the 
learning efficiency in the future. 

The main contributions of our work are: (1) 
Adopting a meaning-based approach to solve 
English math word problems and showing its su-
periority over other state-of-the-art systems on 
common datasets. (2) Proposing a statistical mod-
el to select operands by explicitly checking the 
meanings of quantities against the meaning of the 
question sentence. (3) Designing a noisy dataset to 
test if a system solves the problems by under-
standing. (4) Proposing a perplexity-flavor meas-
ure to assess the complexity of a dataset. 

References 
Yoav Artzi and Luke Zettlemoyer. 2013. Weakly su-

pervised learning of semantic parsers for mapping 
instructions to actions. Transactions of the Associa-
tion for Computational Linguistics, 1(1):49â€“62. 

Yefim Bakman. 2007. Robust understanding of word 
problems with extraneous information. 
http://lanl.arxiv.org/abs/math.GM/0701393. 

Chih-Chung Chang and Chih-Jen Lin. 2011.  LIB- 
SVM: a library for support vector machines. ACM 
Transactions on Intelligent Systems and Technolo-
gy, 2(3):27:1â€“27:27. Software available at  
http://www.csie.ntu.edu.tw/cjlin/libsvm. 

Peter Clark and Oren Etzioni. 2016. My computer is 
an honor student - but how Intelligent is it? Stand-
ardized Tests as a Measure of AI. AI Magazine, 
pages 5â€“12. 

Mohammad Javad Hosseini, Hannaneh Hajishirzi, 
Oren Etzioni, and Nate Kushman. 2014. Learning 
to solve arithmetic word problems with verb cate-
gorization. In Proceedings of the 2014 Conference 
on Empirical Methods in Natural Language Pro-
cessing, EMNLP 2014, October 25-29, 2014, Do-

660



 
 
 
 

   

ha, Qatar, A meeting of SIGDAT, a Special Interest 
Group of the ACL, pages 523â€“533. 

Chien-Tsung Huang, Yi-Chung Lin, and Keh-Yih Su. 
2015. Explanation generation for a math word 
problem solver. International Journal of Computa-
tional Linguistics and Chinese Language pro-
cessing (IJCLCLP), 20(2):27â€“44. 

Danqing Huang, Shuming Shi, Chin-Yew Lin and Jian 
Yin. 2017. Learning fine-grained expressions to 
solve math word problems. In Proceedings of the 
2017 Conference on Empirical Methods in Natural 
Language Processing, pages 816â€“825. 

Rik Koncel-Kedziorski, Hannaneh Hajishirzi, Ashish 
Sabharwal, Oren Etzioni, and Siena Dumas Ang. 
2015. Parsing algebraic word problems into equa-
tions. Transactions of the Association for Compu-
tational Linguistics, 3:585â€“597. 

Nate Kushman, Yoav Artzi, Luke Zettlemoyer, and 
Regina Barzilay. 2014. Learning to automatically 
solve algebra word problems. In Proceedings of the 
52nd Annual Meeting of the Association for Com-
putational Linguistics, pages 271â€“281. 

Chao-Chun Liang, Shih-Hong Tsai, Ting-Yun Chang, 
Yi-Chung Lin and Keh-Yih Su. 2016. A meaning-
based English math word problem solver with un-
derstanding, Reasoning and Explanation. In Pro-
ceedings of COLING 2016. 

Christian Liguda and Thies Pfeiffer. 2012. Modeling 
math word problems with augmented semantic 
networks. In Gosse Bouma, Ashwin Ittoo, Elisa-
beth Metais, and Hans Wortmann, editors, Natural 
Language Processing and Information Sys-
tems/17th International Conference on Applica-
tions of Natural Language to Information Systems, 
volume 7337. Springer. 

Yi-Chung Lin, Chao-Chun Liang, Kuang-Yi Hsu, 
Chien- Tsung Huang, Shen-Yun Miao, Wei-Yun 
Ma, Lun-Wei Ku, Churn-Jung Liau, and Keh-Yih 
Su. 2015. Designing a tag-based statistical math 
word problem solver with reasoning and explana-
tion. International Journal of Computational Lin-
guistics and Chinese Language processing 
(IJCLCLP), 20(2):1â€“26. 

Wang Ling, Dani Yogatama, Chris Dyer and Phil 
Blunsom. 2017. Program induction by rationale 
generation: Learning to solve and explain algebraic 
word problems. In Proceedings of the 55th Annual 
Meeting of the Association for Computational Lin-
guistics, pages 158â€“167. 

Yuhui Ma, Ying Zhou, Guangzuo Cui, Yun Ren, and 
Ronghuai Huang. 2010. Frame-based calculus of 
soling arithmetic multi-step addition and subtrac-
tion word problems. Education Technology and 
Computer Science, International Workshop on, 
2:476â€“479. 

Christopher D Manning, Mihai Surdeanu, John Bauer, 
Jenny Finkel, Steven J Bethard, and David 
McClosky. 2014. The Stanford CoreNLP natural 
language processing toolkit. In ACL Demonstra-
tions. 

Arindam Mitra and Chitta Baral. 2016. Learning to 
use formulas to solve simple arithmetic problems. 
In Proceedings of the 54th Annual Meeting of the 
Association for Computational Linguistics, pages 
2144â€“2153. 

Anirban Mukherjee and Utpal Garain.  2008.  A re-
view of methods for automatic understanding of 
natural language mathematical problems. Artif. In-
tell. Rev., 29(2):93â€“122. 

Stephen J. Pape. 2004. Middle school childrenâ€™s prob-
lem-solving behavior: A cognitive analysis from a 
reading comprehension perspective. Journal for 
Research in Mathematics Education, 35(3):187â€“
219. 

Subhro Roy and Dan Roth. 2015. Solving general 
arithmetic word problems. In Proceedings of the 
2015 Conference on Empirical Methods in Natural 
Language Processing, pages 1743â€“1752. 

Subhro Roy and Dan Roth. 2016. Illinois Math Solv-
er: Math reasoning on the web. In Proceedings of 
the 2016 Conference of the North American Chap-
ter of the Association for Computational Linguis-
tics: Demonstrations, pages 52â€“66. 

Subhro Roy and Dan Roth. 2017. Unit dependency 
graph and its application to arithmetic word prob-
lem solving. In Proceedings of the Thirty-First 
AAAI Conference on Artificial Intelligence (AAAI-
17). 

Subhro Roy, Tim Vieira, and Dan Roth. 2015. Rea-
soning about quantities in natural language. Trans-
actions of the Association for Computational Lin-
guistics, 3:1â€“13. 

Stuart Russell and Peter Norvig. 2009. Artificial Intel-
ligence: A modern approach. Prentice Hall Press, 
Upper Saddle River, NJ, USA, 3rd edition. 

Shuming Shi, Yuehui Wang, Chin-Yew Lin, Xiaojiang 
Liu, and Yong Rui. 2015. Automatically solving 
number word problems by semantic parsing and 
reasoning. In Proceedings of the 2015 Conference 
on Empirical Methods in Natural Language Pro-
cessing, pages 1132â€“1142. 

Manish Shrivastava and Dipti Misra Sharma. 2017. 
Deep neural network based system for solving 
arithmetic word problems. In Proceedings of the 
2017 International Joint Conference on Natural 
Language Processing, pages 65â€“68. 

Shyam Upadhyay, Ming-Wei Chang, Kai-Wei Chang, 
and Wen-tau Yih. 2016. Learning from explicit and 
implicit supervision jointly for algebra word prob-

661



 
 
 
 

   

  

 lems. In Proceedings of the 2016 Conference on 
Empirical Methods in Natural Language Pro-
cessing, pages 297â€“306. 

Yan Wang, Xiaojiang Liu and Shuming Shi. 2017. 
Deep neural solver for math word problems. In 
Proceedings of the 2017 Conference on Empirical 
Methods in Natural Language Processing, pages 
856â€“865. 

Lipu Zhou, Shuaixiang Dai, and Liwei Chen. 2015. 
Learn to solve algebra word problems using quad-
ratic programming. In Proceedings of the 2015 
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 817â€“822. 

 

662


