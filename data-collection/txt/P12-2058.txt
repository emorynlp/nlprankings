










































Heuristic Cube Pruning in Linear Time


Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 296–300,
Jeju, Republic of Korea, 8-14 July 2012. c©2012 Association for Computational Linguistics

Heuristic Cube Pruning in Linear Time

Andrea Gesmundo
Department of

Computer Science
University of Geneva

andrea.gesmundo@unige.ch

Giorgio Satta
Department of

Information Engineering
University of Padua

satta@dei.unipd.it

James Henderson
Department of

Computer Science
University of Geneva

james.henderson@unige.ch

Abstract

We propose a novel heuristic algorithm for
Cube Pruning running in linear time in the
beam size. Empirically, we show a gain in
running time of a standard machine translation
system, at a small loss in accuracy.

1 Introduction

Since its first appearance in (Huang and Chiang,
2005), the Cube Pruning (CP) algorithm has quickly
gained popularity in statistical natural language pro-
cessing. Informally, this algorithm applies to sce-
narios in which we have the k-best solutions for two
input sub-problems, and we need to compute the k-
best solutions for the new problem representing the
combination of the two sub-problems.

CP has applications in tree and phrase based ma-
chine translation (Chiang, 2007; Huang and Chi-
ang, 2007; Pust and Knight, 2009), parsing (Huang
and Chiang, 2005), sentence alignment (Riesa and
Marcu, 2010), and in general in all systems combin-
ing inexact beam decoding with dynamic program-
ming under certain monotonic conditions on the def-
inition of the scores in the search space.

Standard implementations of CP run in time
O(k log(k)), with k being the size of the in-
put/output beams (Huang and Chiang, 2005). Ges-
mundo and Henderson (2010) propose Faster CP
(FCP) which optimizes the algorithm but keeps the
O(k log(k)) time complexity. Here, we propose a
novel heuristic algorithm for CP running in time
O(k) and evaluate its impact on the efficiency and
performance of a real-world machine translation
system.

2 Preliminaries

Let L = 〈x0, . . . , xk−1〉 be a list over R, that is,
an ordered sequence of real numbers, possibly with
repetitions. We write |L| = k to denote the length of
L. We say that L is descending if xi ≥ xj for every
i, j with 0 ≤ i < j < k. Let L1 = 〈x0, . . . , xk−1〉
and L2 = 〈y0, . . . , yk′−1〉 be two descending lists
over R. We write L1 ⊕ L2 to denote the descending
list with elements xi +yj for every i, j with 0 ≤ i <
k and 0 ≤ j < k′.

In cube pruning (CP) we are given as input two
descending lists L1, L2 over R with |L1| = |L2| =
k, and we are asked to compute the descending list
consisting of the first k elements of L1 ⊕L2.

A problem related to CP is the k-way merge
problem (Horowitz and Sahni, 1983). Given de-
scending lists Li for every i with 0 ≤ i < k, we
write mergek−1i=0 Li to denote the “merge” of all the
lists Li, that is, the descending list with all elements
from the lists Li, including repetitions.

For ∆ ∈ R we define shift(L,∆) = L ⊕ 〈∆〉. In
words, shift(L,∆) is the descending list whose ele-
ments are obtained by “shifting” the elements of L
by ∆, preserving the order. Let L1,L2 be descend-
ing lists of length k, with L2 = 〈y0, . . . , yk−1〉.
Then we can express the output of CP on L1,L2 as
the list

mergek−1i=0 shift(L1, yi) (1)

truncated after the first k elements. This shows that
the CP problem is a particular instance of the k-way
merge problem, in which all input lists are related by
k independent shifts.

296



Computation of the solution of the k-way merge
problem takes time O(q log(k)), where q is the
size of the output list. In case each input list has
length k this becomes O(k2 log(k)), and by restrict-
ing the computation to the first k elements, as re-
quired by the CP problem, we can further reduce to
O(k log(k)). This is the already known upper bound
on the CP problem (Huang and Chiang, 2005; Ges-
mundo and Henderson, 2010). Unfortunately, there
seems to be no way to achieve an asymptotically
faster algorithm by exploiting the restriction that the
input lists are all related by some shifts. Nonethe-
less, in the next sections we use the above ideas to
develop a heuristic algorithm running in time linear
in k.

3 Cube Pruning With Constant Slope

Consider lists L1,L2 defined as in section 2. We say
that L2 has constant slope if yi−1− yi = ∆ > 0 for
every i with 0 < i < k. Throughout this section we
assume that L2 has constant slope, and we develop
an (exact) linear time algorithm for solving the CP
problem under this assumption.

For each i ≥ 0, let Ii be the left-open interval
(x0 − (i + 1) · ∆, x0 − i · ∆] of R. Let also s =
⌊(x0 − xk−1)/∆⌋ + 1. We split L1 into (possibly
empty) sublists σi, 0 ≤ i < s, called segments, such
that each σi is the descending sublist consisting of
all elements fromL1 that belong to Ii. Thus, moving
down one segment in L1 is the closest equivalent to
moving down one element in L2.

Let t = min{k, s}; we define descending lists
Mi, 0 ≤ i < t, as follows. We set M0 =
shift(σ0, y0), and for 1 ≤ i < t we let

Mi = merge{shift(σi, y0), shift(Mi−1,−∆)} (2)

We claim that the ordered concatenation of M0,
M1, . . . , Mt−1 truncated after the first k elements
is exactly the output of CP on input L1,L2.

To prove our claim, it helps to visualize the de-
scending list L1 ⊕ L2 (of size k2) as a k × k matrix
L whose j-th column is shift(L1, yj), 0 ≤ j < k.
For an interval I = (x, x′], we define shift(I, y) =
(x+ y, x′ + y]. Similarly to what we have done with
L1, we can split each column of L into s segments.
For each i, j with 0 ≤ i < s and 0 ≤ j < k, we de-
fine the i-th segment of the j-th column, written σi,j ,

as the descending sublist consisting of all elements
of that column that belong to shift(Ii, yj). Then we
have σi,j = shift(σi, yj).

For any d with 0 ≤ d < t, consider now all
segments σi,j with i + j = d, forming a sub-
antidiagonal in L. We observe that these segments
contain all and only those elements of L that belong
to the interval Id. It is not difficult to show by in-
duction that these elements are exactly the elements
that appear in descending order in the list Mi defined
in (2).

We can then directly use relation (2) to iteratively
compute CP on two lists of length k, under our as-
sumption that one of the two lists has constant slope.
Using the fact that the merge of two lists as in (2) can
be computed in time linear in the size of the output
list, it is not difficult to implement the above algo-
rithm to run in time O(k).

4 Linear Time Heuristic Solution

In this section we further elaborate on the exact al-
gorithm of section 3 for the constant slope case, and
develop a heuristic solution for the general CP prob-
lem. Let L1,L2, L and k be defined as in sections 2
and 3. Despite the fact that L2 does not have a con-
stant slope, we can still split each column of L into
segments, as follows.

Let Ĩi, 0 ≤ i < k − 1, be the left-open interval
(x0 + yi+1, x0 + yi] of R. Note that, unlike the case
of section 3, intervals Ĩi’s are not all of the same size
now. Let also Ĩk−1 = [xk−1 + yk−1, x0 + yk−1].
For each i, j with 0 ≤ j < k and 0 ≤ i < k −
j, we define segment σ̃i,j as the descending sublist
consisting of all elements of the j-th column of L
that belong to Ĩi+j . In this way, the j-th column
of L is split into segments Ĩj , Ĩj+1, . . . , Ĩk−1, and
we have a variable number of segments per column.
Note that segments σ̃i,j with a constant value of i+j
contain all and only those elements of L that belong
to the left-open interval Ĩi+j .

Similarly to section 3, we define descending lists
M̃i, 0 ≤ i < k, by setting M̃0 = σ̃0,0 and, for
1 ≤ i < k, by letting

M̃i = merge{σ̃i,0 , path(M̃i−1, L)} (3)

Note that the function path(M̃i−1, L) should not re-
turn shift(M̃i−1,−∆), for some value ∆, as in the

297



1: Algorithm 1 (L1, L2) : L̃⋆

2: L̃⋆.insert(L[0, 0]);
3: referColumn← 0;
4: xfollow ← L[0, 1];
5: xdeviate ← L[1, 0];
6: C ← CircularList([0, 1]);
7: C-iterator← C.begin();
8: while |L̃⋆| < k do
9: if xfollow > xdeviate then

10: L̃⋆.insert(xfollow );
11: if C-iterator.current()=[0, 1] then
12: referColumn++;
13: [i, j]← C-iterator.next();
14: xfollow ← L[i,referColumn+j];
15: else
16: L̃⋆.insert(xdeviate );
17: i← xdeviate .row();
18: C-iterator.insert([i,−referColumn]);
19: xdeviate ← L[i + 1, 0];

case of (2). This is because input list L2 does not
have constant slope in general. In an exact algo-
rithm, path(M̃i−1, L) should return the descending
list L⋆i−1 = merge

i
j=1 σ̃i−j,j: Unfortunately, we do

not know how to compute such a i-way merge with-
out introducing a logarithmic factor.

Our solution is to define path(M̃i−1, L) in such a
way that it computes a list L̃i−1 which is a permu-
tation of the correct solution L⋆i−1. To do this, we
consider the “relative” path starting at x0+yi−1 that
we need to follow in L in order to collect all the el-
ements of M̃i−1 in the given order. We then apply
such a path starting at x0 + yi and return the list of
collected elements. Finally, we compute the output
list L̃⋆ as the concatenation of all lists M̃i up to the
first k elements.

It is not difficult to see that when L2 has constant
slope we have M̃i = Mi for all i with 0 ≤ i < k,
and list L̃⋆ is the exact solution to the CP prob-
lem. When L2 does not have a constant slope, list
L̃⋆ might depart from the exact solution in two re-
spects: it might not be a descending list, because
of local variations in the ordering of the elements;
and it might not be a permutation of the exact so-
lution, because of local variations at the end of the
list. In the next section we evaluate the impact that

����� ������

�� ��

��	��
�������

� �����

���������

��

����� ������

�����

��

�� ���

����� ������

������

��

�� ��

��

����� ������

������

��

�� ��

��

�� �� ��

��

�� �� ��

��

��

�� �� ��

�� ��

��

�� �� ��

�� ��

��

�

�� �� �� ��

�� ��

��

�

� � � �

��

�

�

�

Figure 1: A running example for Algorithm 1.

our heuristic solution has on the performance of a
real-world machine translation system.

Algorithm 1 implements the idea presented in (3).
The algorithm takes as input two descending lists
L1,L2 of length k and outputs the list L̃⋆ which
approximates the desired solution. Element L[i, j]
denotes the combined value xi + yj , and is always
computed on demand.

We encode a relative path (mentioned above) as
a sequence of elements, called displacements, each
of the form [i, δ]. Here i is the index of the next row,
and δ represents the relative displacement needed to
reach the next column, to be summed to a variable
called referColumn denoting the index of the col-
umn of the first element of the path. The reason
why only the second coordinate is a relative value
is that we shift paths only horizontally (row indices
are preserved). The relative path is stored in a circu-
lar list C, with displacement [0, 1] marking the start-
ing point (paths are always shifted one element to
the right). When merging the list obtained through
the path for M̃i−1 with segment σ̃i,0, as specified
in (3), we update C accordingly, so that the new rel-
ative path can be used at the next round for M̃i. The
merge operator is implemented by the while cycle
at lines 8 to 19 of algorithm 1. The if statement at
line 9 tests whether the next step should follow the
relative path for M̃i−1 stored in C (lines 10 to 14) or

298



-5

 0

 5

 10

 15

 20

 25

 30

 35

 40

 45

 1  10  100  1000

sc
or

e 
lo

ss
 (

%
)

beam size

Baseline score loss over CP
LCP score loss over CP
FCP score loss over CP

Figure 2: Search-score loss relative to standard CP.

else depart visiting an element from σ̃i,0 in the first
column of L (lines 16 to 19). In the latter case, we
update C with the new displacement (line 18), where
the function insert() inserts a new element before
the one currently pointed to. The function next() at
line 13 moves the iterator to the next element and
then returns its value.

A running example of algorithm 1 is reported in
Figure 1. The input lists are L1 = 〈12, 7, 5, 0〉,
L2 = 〈9, 6, 3, 0〉. Each of the picture in the sequence
represents the state of the algorithm when the test at
line 9 is executed. The value in the shaded cell in the
first column is xdeviate , while the value in the other
shaded cell is xfollow .

5 Experiments

We implement Linear CP (LCP) on top of Cdec
(Dyer et al., 2010), a widely-used hierarchical MT
system that includes implementations of standard
CP and FCP algorithms. The experiments were ex-
ecuted on the NIST 2003 Chinese-English parallel
corpus. The training corpus contains 239k sentence
pairs. A binary translation grammar was extracted
using a suffix array rule extractor (Lopez, 2007).
The model was tuned using MERT (Och, 2003).
The algorithms are compared on the NIST-03 test
set, which contains 919 sentence pairs. The features
used are basic lexical features, word penalty and a
3-gram Language Model (Heafield, 2011).

Since we compare decoding algorithms on the
same search space, the accuracy comparison is done
in terms of search score. For each algorithm we

 0

 5

 10

 15

 20

 25

 1  10  100  1000

sp
ee

d 
ga

in
 (

%
)

beam size

LCP speed gain over CP
LCP speed gain over FCP

Figure 3: Linear CP relative speed gain.

compute the average score of the best translation
found for the test sentences. In Figure 2 we plot
the score-loss relative to standard CP average score.
Note that the FCP loss is always < 3%, and the LCP
loss is always < 7%. The dotted line plots the loss
of a baseline linear time heuristic algorithm which
assumes that both input lists have constant slope,
and that scans L along parallel lines whose steep
is the ratio of the average slope of each input list.
The baseline greatly deteriorates the accuracy: this
shows that finding a reasonable linear time heuristic
algorithm is not trivial. We can assume a bounded
loss in accuracy, because for larger beam size all the
algorithms tend to converge to exhaustive search.

We found that these differences in search score
resulted in no significant variations in BLEU score
(e.g. with k = 30, CP reaches 32.2 while LCP 32.3).

The speed comparison is done in terms of algo-
rithm run-time. Figure 3 plots the relative speed gain
of LCP over standard CP and over FCP. Given the
log-scale used for the beam size k, the linear shape
of the speed gain over FCP (and CP) in Figure 3 em-
pirically confirms that LCP has a log(k) asymptotic
advantage over FCP and CP.

In addition to Chinese-English, we ran experi-
ments on translating English to French (from Eu-
roparl corpus (Koehn, 2005)), and find that the LCP
score-loss relative to CP is < 9% while the speed
relative advantage of LCP over CP increases in aver-
age by 11.4% every time the beam size is multiplied
by 10 (e.g. with k = 1000 the speed advantage is
34.3%). These results confirm the bounded accu-
racy loss and log(k) speed advantage of LCP.

299



References

David Chiang. 2007. Hierarchical phrase-based transla-
tion. Computational Linguistics, 33(2):201–228.

Chris Dyer, Adam Lopez, Juri Ganitkevitch, Jonathan
Weese, Hendra Setiawan, Ferhan Ture, Vladimir Ei-
delman, Phil Blunsom, and Philip Resnik. 2010.
cdec: A decoder, alignment, and learning framework
for finite-state and context-free translation models.
In ACL ’10: Proceedings of the ACL 2010 System
Demonstrations, Uppsala, Sweden.

Andrea Gesmundo and James Henderson. 2010. Faster
Cube Pruning. In IWSLT ’10: Proceedings of the 7th
International Workshop on Spoken Language Transla-
tion, Paris, France.

Kenneth Heafield. 2011. KenLM: Faster and smaller
language model queries. In WMT ’11: Proceedings of
the 6th Workshop on Statistical Machine Translation,
Edinburgh, Scotland, UK.

E. Horowitz and S. Sahni. 1983. Fundamentals of
data structures. Computer software engineering se-
ries. Computer Science Press.

Liang Huang and David Chiang. 2005. Better k-best
parsing. In IWPT ’05: Proceedings of the 9th Interna-
tional Workshop on Parsing Technology, Vancouver,
British Columbia, Canada.

Liang Huang and David Chiang. 2007. Forest rescor-
ing: Faster decoding with integrated language mod-
els. In ACL ’07: Proceedings of the 45th Confer-
ence of the Association for Computational Linguistics,
Prague, Czech Republic.

Philipp Koehn. 2005. Europarl: A parallel corpus for
statistical machine translation. In Proceedings of the
10th Machine Translation Summit, Phuket, Thailand.

Adam Lopez. 2007. Hierarchical phrase-based transla-
tion with suffix arrays. In EMNLP-CoNLL ’07: Pro-
ceedings of the 2007 Joint Conference on Empirical
Methods in Natural Language Processing and Com-
putational Natural Language Learning, Prague, Czech
Republic.

Franz Josef Och. 2003. Minimum error rate training
in statistical machine translation. In ACL ’03: Pro-
ceedings of the 41st Conference of the Association for
Computational Linguistics, Sapporo, Japan.

Michael Pust and Kevin Knight. 2009. Faster MT decod-
ing through pervasive laziness. In NAACL ’09: Pro-
ceedings of the 10th Conference of the North American
Chapter of the Association for Computational Linguis-
tics, Boulder, CO, USA.

Jason Riesa and Daniel Marcu. 2010. Hierarchical
search for word alignment. In ACL ’10: Proceedings
of the 48th Conference of the Association for Compu-
tational Linguistics, Uppsala, Sweden.

300


