










































Natural Language Questions for the Web of Data


Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural
Language Learning, pages 379–390, Jeju Island, Korea, 12–14 July 2012. c©2012 Association for Computational Linguistics

Natural Language Questions for the Web of Data

Mohamed Yahya1, Klaus Berberich1, Shady Elbassuoni2
Maya Ramanath3, Volker Tresp4, Gerhard Weikum1

1 Max Planck Institute for Informatics, Germany
2 Qatar Computing Research Institute

3 Dept. of CSE, IIT-Delhi, India 4 Siemens AG, Corporate Technology, Munich, Germany
{myahya,kberberi,weikum}@mpi-inf.mpg.de

selbassuoni@qf.org.qa
ramanath@cse.iitd.ac.in volker.tresp@siemens.com

Abstract

The Linked Data initiative comprises struc-
tured databases in the Semantic-Web data
model RDF. Exploring this heterogeneous
data by structured query languages is tedious
and error-prone even for skilled users. To ease
the task, this paper presents a methodology
for translating natural language questions into
structured SPARQL queries over linked-data
sources.

Our method is based on an integer linear pro-
gram to solve several disambiguation tasks
jointly: the segmentation of questions into
phrases; the mapping of phrases to semantic
entities, classes, and relations; and the con-
struction of SPARQL triple patterns. Our so-
lution harnesses the rich type system provided
by knowledge bases in the web of linked data,
to constrain our semantic-coherence objective
function. We present experiments on both the
question translation and the resulting query
answering.

1 Introduction

1.1 Motivation
Recently, very large, structured, and semantically
rich knowledge bases have become available. Ex-
amples are Yago (Suchanek et al., 2007), DBpe-
dia (Auer et al., 2007), and Freebase (Bollacker et
al., 2008). DBpedia forms the nucleus of the Web of
Linked Data (Heath and Bizer, 2011), which inter-
connects hundreds of RDF data sources with a total
of 30 billion subject-property-object (SPO) triples.

The diversity of linked-data sources and their high
heterogeneity make it difficult for humans to search

and discover relevant information. As linked data
is in RDF format, the standard approach would be
to run structured queries in triple-pattern-based lan-
guages like SPARQL, but only expert programmers
are able to precisely specify their information needs
and cope with the high heterogeneity of the data
(and absence or very high complexity of schema in-
formation). For less initiated users the only option
to query this rich data is by keyword search (e.g.,
via services like sig.ma (Tummarello et al., 2010)).
None of these approaches is satisfactory. Instead, the
by far most convenient approach would be to search
in knowledge bases and the Web of linked data by
means of natural-language questions.

As an example, consider a quiz question like
“Which female actor played in Casablanca and is
married to a writer who was born in Rome?”.
The answer could be found by querying sev-
eral linked data sources together, like the IMDB-
style LinkedMDB movie database and the DB-
pedia knowledge base, exploiting that there are
entity-level sameAs links between these collections.
One can think of different formulations of the
example question, such as “Which actress from
Casablanca is married to a writer from Rome?”. A
possible SPARQL formulation, assuming a user fa-
miliar with the schema of the underlying knowl-
edge base(s), could consist of the following six
triple patterns (joined by shared-variable bind-
ings): ?x hasGender female, ?x isa actor, ?x
actedIn Casablanca (film), ?x marriedTo ?w,
?w isa writer, ?w bornIn Rome. This complex
query, which involves multiple joins, would yield
good results, but it is difficult for the user to come

379



up with the precise choices for relations, classes, and
entities. This would require familiarity with the con-
tents of the knowledge base, which no average user
is expected to have. Our goal is to automatically cre-
ate such structured queries by mapping the user’s
question into this representation. Keyword search is
usually not a viable alternative when the information
need involves joining multiple triples to construct
the final result, notwithstanding good attempts like
that of Pound et al. (2010). In the example, the obvi-
ous keyword query “female actress Casablanca mar-
ried writer born Rome” lacks a clear specification of
the relations among the different entities.

1.2 Problem

Given a natural language question qNL and a knowl-
edge base KB, our goal is to translate qNL into a
formal query qFL that captures the information need
expressed by qNL.

We focus on input questions that put the em-
phasis on entities, classes, and relations between
them. We do not consider aggregations (counting,
max/min, etc.) and negations. As a result, we gener-
ate structured queries of the form known as conjunc-
tive queries or select-project-join queries in database
terminology. Our target language is SPARQL 1.0,
where the above focus leads to queries that consist of
multiple triple patterns, that is, conjunctions of SPO
search conditions. We do not use any pre-existing
query templates, but generate queries from scratch
as they involve a variable number of joins with a-
priori unknown join structure.

A major challenge is in the ambiguity of
the phrases occurring in a natural-language ques-
tion. Phrases can denote entities (e.g., the city
of Casablanca or the movie Casablanca), classes
(e.g., actresses, movies, married people), or rela-
tions/properties (e.g., marriedTo between people,
played between people and movies). A priori, we do
not know if a phrase should be mapped to an entity,
a class, or a relation. In fact, some phrases may de-
note any of these three kinds of targets. For example,
a phrase like “wrote score for” in a question about
film music composers, could map to the composer-
film relation wroteSoundtrackForFilm, to the class
of movieSoundtracks (a subclass of music pieces),
or to an entity like the movie “The Score”. Depend-
ing on the choice, we may arrive at a structurally

good query (with triple patterns that can actually
be joined) or at a meaningless and non-executable
query (with disconnected triple patterns). This gen-
eralized disambiguation problem is much more chal-
lenging than the more focused task of named entity
disambiguation (NED). It is also different from gen-
eral word sense disambiguation (WSD), which fo-
cuses on the meaning of individual words (e.g., map-
ping them to WordNet synsets).

1.3 Contribution

In our approach, we introduce new elements towards
making translation of questions into SPARQL triple
patterns more expressive and robust. Most impor-
tantly, we solve the disambiguation and mapping
tasks jointly, by encoding them into a comprehen-
sive integer linear program (ILP): the segmentation
of questions into meaningful phrases, the mapping
of phrases to semantic entities, classes, and rela-
tions, and the construction of SPARQL triple pat-
terns. The ILP harnesses the richness of large knowl-
edge bases like Yago2 (Hoffart et al., 2011b), which
has information not only about entities and relations,
but also about surface names and textual patterns
by which web sources refer to them. For example,
Yago2 knows that “Casablanca” can refer to the city
or the film, and “played in” is a pattern that can de-
note the actedIn relation. In addition, we can lever-
age the rich type system of semantic classes. For ex-
ample, knowing that Casablanca is a film, for trans-
lating “played in” we can focus on relations with a
type signature whose range includes films, as op-
posed to sports teams, for example. Such informa-
tion is encoded in judiciously designed constraints
for the ILP. Although we intensively harness Yago2,
our approach does not depend on a specific choice of
knowledge base or language resource for type infor-
mation and phrase/name dictionaries. Other knowl-
edge bases such as DBpedia can be easily plugged
in.

Based on these ideas, we have developed a frame-
work and system, called DEANNA (DEep Answers
for maNy Naturally Asked questions), that com-
prises a full suite of components for question de-
composition, mapping constituents into the seman-
tic concept space, generating alternative candidate
mappings, and computing a coherent mapping of all
constituents into a set of SPARQL triple patterns that

380



can be directly executed on one or more linked data
sources.

2 Background
We use the Yago2 knowledge base, with its rich
type system, as a semantic backbone. Yago2 is com-
posed of instances of binary relations derived from
Wikipedia and WordNet. The instances, called facts,
provide both ontological information and instance
data. Figure 1 shows sample facts from Yago2. Each
fact is composed of semantic items that can be di-
vided into relations, entities, and classes. Entities
and classes together are referred to as concepts.

Subject Predicate Object
film subclassOfproduction
Casablanca (film)type film
“Casablanca” means Casablanca (film)
“Casablanca” means Casablanca, Morocco
Ingrid Bergman actedIn Casablanca (film)

Figure 1: Sample knowledge base

Examples of relations are type, subclassOf, and
actedIn. Each relation has a type signature: classes
for the relation’s domain and range. Classes, such as
person and film group entities. Entities are repre-
sented in canonical form such as Ingrid Bergman
and Casablanca (film). A special type of entities
are literals, such as strings, numbers, and dates.

3 Framework
Given a natural language question, Figure 2 shows
the tasks DEANNA performs to translate a ques-
tion into a structured query. The first three steps
prepare the input for constructing a disambiguation
graph for mapping the phrases in a question onto
entities, classes, and relations, in a coherent man-
ner. The fourth step formulates this generalized dis-
ambiguation problem as an ILP with complex con-
straints and computes the best solution using an
ILP solver. Finally, the fifth and sixth step together
use the disambiguated mapping to construct an exe-
cutable SPARQL query.

A question sentence is a sequence of tokens,
qNL = (t0, t1, ..., tn). A phrase is a contiguous sub-
sequence of tokens (ti, ti+1, ..., ti+l) ⊆ qNL, 0 ≤
i, 0 ≤ l ≤ n. The input question is fed into the fol-
lowing pipeline of six steps:
1. Phrase detection. Phrases are detected that
potentially correspond to semantic items such as

‘Who’, ‘played in’, ‘movie’ and ‘Casablanca’.
2. Phrase mapping to semantic items. This in-
cludes finding that the phrase ‘played in’ can ei-
ther refer to the semantic relation actedIn or to
playedForTeam and that the phrase ‘Casablanca’
can potentially refer to Casablanca (film) or
Casablanca, Morocco. This step merely constructs
a candidate space for the mapping. The actual dis-
ambiguation is addressed by step 4, discussed below.
3. Q-unit generation. Intuitively, a q-unit is a triple
composed of phrases. Their generation and role will
be discussed in detail in the next section.
4. Joint disambiguation, where the ambiguities in
the phrase-to-semantic-item mapping are resolved.
This entails resolving the ambiguity in phrase bor-
ders, and above all, choosing the best fitting can-
didates from the semantic space of entities, classes,
and relations. Here, we determine for our running
example that ‘played in’ refers to the semantic re-
lation actedIn and not to playedForTeam and the
phrase ‘Casablanca’ refers to Casablanca (film)
and not Casablanca, Morocco.
5. Semantic items grouping to form semantic
triples. For example, we determine that the relation
marriedTo connects person referred to by ‘Who’
and writer to form the semantic triple person
marriedTo writer. This is done via q-units.
6. Query generation. For SPARQL queries, seman-
tic triples such as person marriedTo writer have
to be mapped to suitable triple patterns with appro-
priate join conditions expressed through common
variables: ?x type person, ?x marriedTo ?w, and
?w type writer for the example.

3.1 Phrase Detection

A detected phrase p is a pair < Toks, l > where
Toks is a phrase and l is a label, l ∈
{concept, relation}, indicating whether a phrase is
a relation phrase or a concept phrase. Pr is the set of
all detected relation phrases and Pc is the set of all
detected concept phrases.

One special type of detected relation phrase is
the null phrase, where no relation is explicitly men-
tioned, but can be induced. The most prominent ex-
ample of this is the case of adjectives, such as ‘Aus-
tralian movie’, where we know there is a relation
being expressed between ‘Australia’ and ‘movie’.

We use multiple detectors for detecting phrases of

381



 q
ue

st
io

n

ph
ra

se
s

st
ru

ct
ur

ed
qu

er
y

 

Concept
&Relation
Phrase
Detection

 
Joint
Disambi-
guation

  

m
ap

pi
ng

s

ca
nd

id
at

e
gr

ap
h

 
entities & names
classes & subclasses
relations & pattterns
incl. dictionaries & statistics

  

Knowledge Base

 

Concept
&Relation
Phrase
Mapping

1 2 3 4

     

5

  
Semantic
Items
Grouping

Query
Gene-
ration

6

se
le

ct
ed

s-
no

de
s

tr
ip

le
pa

tt
er

ns

 
Q-unit  
Genera- 
tion

Figure 2: Architecture of DEANNA.

different types. For concept detection, we use a de-
tector that works against a phrase-concept dictionary
which looks as follows:
{‘Rome’,‘eternal city’} → Rome
{‘Casablanca’} → Casablanca (film)

We experimented with using third-party named en-
tity recognizers but the results were not satisfactory.
This dictionary was mostly constructed as part of
the knowledge base, independently of the question-
to-query translation task in the form of instances of
the means relation in Yago2, an example of which is
shown in Figure 1

For relation detection, we experimented with var-
ious approaches. We mainly rely on a relation detec-
tor based on ReVerb (Fader et al., 2011) with addi-
tional POS tag patterns, in addition to our own which
looks for patterns in dependency parses.

3.2 Phrase Mapping

After phrases are detected, each phrase is mapped
to a set of semantic items. The mapping of concept
phrases also relies on the phrase-concept dictionary.

To map relation phrases, we rely on a corpus of
textual patterns to relation mappings of the form:

{‘play’,‘star in’,‘act’,‘leading role’} → actedIn
{‘married’, ‘spouse’,‘wife’} → marriedTo

Distinct phrase occurrences will map to different
semantic item instances. We discuss why this is im-
portant when we discuss the construction of the dis-
ambiguation graph and variable assignment in the
structured query.

3.3 Dependency Parsing & Q-Unit Generation

Dependency parsing identifies triples of to-
kens, or triploids, 〈trel, targ1, targ2〉, where
trel, targ1, targ2 ∈ qNL are seeds for phrases, with
the triploid acting as a seed for a potential SPARQL
triple pattern. Here, trel is the seed for the relation
phrase, while targ1 and targ2 are seeds for the two
arguments. At this point, there is no attempt to
assign subject/object roles to the arguments.

Triploids are collected by looking for specific de-
pendency patterns in dependency graphs (de Marn-
effe et al., 2006). The most prominent pattern we
look for is a verb and its arguments. Other patterns
include adjectives and their arguments, preposition-
ally modified tokens and objects of prepositions.

By combining triploids with detected phrases, we
obtain q-units. A q-unit is a triple of sets of phrases,
〈{prel ∈ Pr}, {parg1 ∈ Pc}, {parg2 ∈ Pc}〉, where
trel ∈ prel and similarly for arg1 and arg2. Concep-
tually, one can view a q-unit as a placeholder node
with three sets of edges, each connecting the same
q-node to a phrase that corresponds to a relation or
concept phrase in the same q-unit. This notion of
nodes and edges will be made more concrete when
we present our disambiguation graph construction.

3.4 Disambiguation of Phrase Mappings

The core contribution of this paper is a framework
for disambiguating phrases into semantic items –
covering relations, classes, and entities in a unified
manner. This can be seen as a joint task combining

382



named entity disambiguation for entities, word sense
disambiguation for classes (common nouns), and re-
lation extraction. The next section presents the dis-
ambiguation framework in detail.

3.5 Query Generation

Once phrases are mapped to unique semantic items,
we proceed to generate queries in two steps. First,
semantic items are grouped into triples. This is done
using the triploids generated earlier. The power of
using a knowledge base is that we have a rich type
system that allows us to tell if two semantic items
are compatible or not. Each relation has a type sig-
nature and we check whether the candidate items are
compatible with the signature.

We did not assign subject/object roles in triploids
and q-units because a natural language relation
phrase might express the inverse of a semantic rela-
tion, e.g., the natural language expression ‘directed
by’ and the relation isDirectorOf with respect to
the movies domain are inverses of each other. There-
fore, we check which assignment of arg1 and arg2
is compatible with the semantic relation. If both ar-
rangements are compatible, then we give preference
to the assignment given by the dependency parsers.

Once semantic items are grouped into triples, it
is an easy task to expand them to SPARQL triple
patterns. This is done by replacing each seman-
tic class with a distinct type-constrained variable.
Note that this is the reason why each distinct phrase
maps to a distinct instance of a semantic class, to
ensure correct variable assignment. This becomes
clear when we consider the question “Which singer
is married to a singer?”, which requires two distinct
variables each constrained to bind to an entity of
type singer.

4 Joint Disambiguation

The goal of the disambiguation step is to compute
a partial mapping of phrases onto semantic items,
such that each phrase is assigned to at most one
semantic item. This step also resolves the phrase-
boundary ambiguity, by enforcing that only non-
overlapping phrases are mapped. As the result of
disambiguating one phrase can influence the map-
ping of other phrases, we consider all phrases jointly
in one big disambiguation task.

In the following, we construct a disambiguation
graph that encodes all possible mappings. We im-
pose a variety of complex constraints (mutual ex-
clusion among overlapping phrases, type constraints
among the selected semantic items, etc.), and define
an objective function that aims to maximize the joint
quality of the mapping. The graph construction it-
self may resemble similar models used in NED (e.g.,
(Milne and Witten, 2008; Kulkarni et al., 2009; Hof-
fart et al., 2011a)). Recall, however, that our task is
more complex because we jointly consider entities,
classes, and relations in the candidate space of pos-
sible mappings. Because of this complication and
to capture our complex constraints, we do not em-
ploy graph algorithms, but model the general disam-
biguation problem as an ILP.

4.1 Disambiguation Graph
Joint disambiguation takes place over a disambigua-
tion graph DG = (V,E), where V = Vs ∪ Vp ∪ Vq
and E = Esim ∪ Ecoh ∪ Eq, where:• Vs is the set of semantic items, vs ∈ Vs is an

s-node.
• Vp is the set of phrases, vp ∈ Vp is called a p-

node. We denote the set of p-nodes correspond-
ing to relation phrases by Vrp and the set of p-
nodes corresponding to concept phrases by Vrc .
• Vq is a set of placeholder nodes for q–units,

called q-nodes. They represent phrase triples.
• Esim ⊆ Vp × Vs is a set of weighted similarity

edges that capture the strength of the mapping
of a phrase to a semantic item.
• Ecoh ⊆ Vs × Vs is a set of weighted coherence

edges that capture the semantic coherence be-
tween two semantic items. Semantic coherence
is discussed in more detail later in this section.
• Eq ⊆ Vq×Vp×d, where d ∈ {rel, arg1, arg2}

is a q-edge. Each such edge connects a place-
holder q-node to a p-node with a specific role
as a relation, or one of the two arguments. A
q-unit, as presented earlier, can be seen as a q-
node along with its outgoing q-edges.

Figure 3 shows the disambiguation graph for our
running example (excluding coherence edges be-
tween s-nodes).

4.2 Edge Weights
We next describe how the weights on similarity
edges and semantic coherence edges are defined.

383



q1

q2

q3

a writer

Casablanca

played

played in

Who

married

married to

is married to

was born

born

Rome

c:writer
r:bornIn

r:bornOnDate

e:Max_Born
e:Born_(film)

e:Sydne_Rome
r:Rome

e:White_House
e:Casablanca

e:Casablanca_(film)
e:Played_(film)

r:actedIn
r:hasMusicalRole

c:person

e:Married_(series)

c: married_person

r:marriedTo

q-nodes p-nodes s-nodes

arg1 arg2rel

Figure 3: Disambiguation graph for the running example.

4.2.1 Semantic Coherence
Semantic coherence, Cohsem, captures to what

extent two semantic items occur in the same context.
This is different from semantic similarity (Simsem),
which is usually evaluated using the distance be-
tween nodes in a taxonomy (Resnik, 1995). While
we expect Simsem(George Bush, Woody Allen) to
be higher than Simsem(Woody Allen, Terminator)
we would like Cohsem(Woody Allen, Terminator),
both of which are from the entertainment domain, to
be higher than Cohsem(George Bush, Woody Allen).

For Yago2, we characterize an entity e by its in-
links InLinks(e): the set of Yago2 entities whose
corresponding Wikipedia pages link to the entity.

To be able to compare semantic items of different
semantic types (entities, relations, and classes), we
need to extend this to classes and relations. For class
c with entities e, its inlinks are defined as follows:

InLinks(c) =
⋃

e∈c Inlinks(e)

For relations, we only consider those that map en-
tities to entities (e.g. actedIn, produced), for which
we define the set of inlinks as follows:
InLinks(r) =

⋃
(e1,e2)∈r(InLinks(e1) ∩ InLinks(e2))

The intuition behind this is that when the two argu-
ments of an instance of the relation co-occur, then
the relation is being expressed.

We define the semantic coherence (Cohsem) be-
tween two semantic items s1 and s2 as the Jaccard
coefficient of their sets of inlinks.

4.2.2 Similarity Weights
Similarity weights are computed differently for

entities, classes, and relations. For entities, we use a
normalized prior score based on how often a phrase
refers to a certain entity in Wikipedia. For classes,
we use a normalized prior that reflects the number
of members in a class. Finally, for relations, similar-
ity reflects the maximum n-gram similarity between
the phrase and any of the relation’s surface forms.
We use Lucene for indexing and searching the rela-
tion surface forms.

4.3 Disambiguation Graph Processing

The result of disambiguation is a subgraph of the
disambiguation graph, yielding the most coherent
mappings. We employ an ILP to this end. Before
describing our ILP, we state some necessary defini-
tions:

• Triple dimensions: d ∈ {rel, arg1, arg2}
• Tokens: T = {t0, t1, ..., tn}.
• Phrases: P = {p0, p1, ..., pk}.
• Semantic items: S = {s0, s1, ..., sl}.
• Token occurrences: P(t) = {p ∈ P | t ∈ p}.
• Xi ∈ {0, 1} indicates if p-node i is selected.
• Yij ∈ {0, 1} indicates if p-node i maps to s-

node j.
• Zkl ∈ {0, 1} indicates if s-nodes k, l are both

selected so that their coherence edge matters.
• Qmnd ∈ {0, 1} indicates if the q-edge between
q-node m and p-node n for d is selected.
• Cj , Ej and Rj are {0, 1} constants indicating

if s-node j is a class, entity, or relation, resp.
• wij is the weight for a p–s similarity edge.
• vkl is the weight for an s–s semantic coherence

edge.
• trc ∈ {0, 1} indicates if the relation s-node r is

type-compatible with the concept s-node c.

Given the above definitions, our objective func-
tion is

maximize α
∑

i,j wijYij + β
∑

k,l vklZkl+

γ
∑

m,n,dQmnd

384



subject to the following constraints:
1. A p-node can be assigned to one s-node at most:∑

j Yij ≤ 1, ∀i

2. If a p-s similarity edge is chosen, then the respec-
tive p-node must be chosen:

Yij ≤ Xi, ∀j

3. If s-nodes k and l are chosen (Zkl = 1), then there
are p-nodes mapping to each of the s-nodes k and l
( Yik = 1 for some i and Yjl = 1 for some j):

Zkl ≤
∑

i Yik and Zkl ≤
∑

j Yjl

4. No token can appear as part of two phrases:∑
i∈P(t)Xi ≤ 1, ∀t ∈ T

5. At most one q-edge is selected for a dimension:∑
nQmnd ≤ 1, ∀m, d

6. If the q-edge mnd is chosen (Qmnd = 1) then
p-node n must be selected:

Qmnd ≤ Xn, ∀m, d

7. Each semantic triple should include a relation:

Er ≥ Qmn′d +Xn′ + Yn′r − 2 ∀m,n′, r, d = rel

8. Each triple should have at least one class:

Cc1 + Cc2 ≥ Qmn′′d1 +Xn′′ + Yn′′′c1+
Qmn′′′d2 +Xn′′′ + Yn′′′c2 − 5,

∀m,n′′, n′′′, r, c1, c2, d1 = arg1, d2 = arg2

This is not invoked for existential questions that
return Boolean answers and are translated to ASK
queries in SPARQL. An example is the question
“Did Tom Cruise act in Top Gun?”, which can be
translated to ASK {Tom Cruise actedIn Top Gun}.
9. Type constraints are respected (through q-edges):

trc1 + trc2 ≥ Qmn′d1 +Xn′ + Yn′r+
Qmn′′d2 +Xn′′ + Yn′′′c1+
Qmn′′′d3 +Xn′′′ + Yn′′′c2 − 7

∀m,n′, n′′, n′′′, r, c1, c2,
d1 = rel, d2 = arg1, d3 = arg2

The above is a sophisticated ILP, and most likely
NP-hard. However, even with ten thousands of vari-
ables it is within the regime of modern ILP solvers.
In our experiments, we used Gurobi (Gur, 2011), and
achieved run-times – typically of a few seconds.

q1

q2

q3

a writer

Casablanca

played in

Who

is married to

was born

Rome

c:writer

r:bornIn

r:Rome

e:Casablanca

r:actedIn

c:person

r:marriedTo

q-nodes p-nodes s-nodes

Figure 4: Computed subgraph for the running example.

Figure 4 shows the resulting subgraph for the dis-
ambiguation graph of Figure 3. Note how common
p-nodes between q-units capture joins.

5 Evaluation

5.1 Datasets

Our experiments are based on two collections of
questions: the QALD-1 task for question answer-
ing over linked data (QAL, 2011) and a collection
of questions used in (Elbassuoni et al., 2011; El-
bassuoni et al., 2009) in the context of the NAGA
project, for informative ranking of SPARQL query
answers (Elbassuoni et al. (2009) evaluated the
SPARQL queries, but the underlying questions are
formulated in natural language.) The NAGA collec-
tion is based on linking data from IMDB with the
Yago2 knowledge base. This is an interesting linked-
data case: IMDB provides data about movies, actors,
directors, and movie plots (in the form of descrip-
tive keywords and phrases); Yago2 adds semantic
types and relational facts for the participating enti-
ties. Yago2 provides nearly 3 million concepts and
100 relations, of which 41 lie within the scope of
our framework.

Typical example questions for these two col-
lections are: “Which software has been published
by Mean Hamster Software?” for QALD-1, and
“Which director has won the Academy Award for
Best director and is married to an actress that has
won the Academy Award for Best Actress?” for
NAGA. For both collections, some questions are
out-of-scope for our setting, because they mention
entities or relations that are not available in the un-
derlying datasets, contain date or time comparisons,
or involve aggregation such as counting. After re-

385



moving these questions, our test set consists of 27
QALD-1 training questions out of a total of 50 and
44 NAGA questions, out of a total of 87. We used
the 19 questions from the QALD-1 test set that are
within the scope of our method for tuning the hyper-
parameters (α, β, γ) in the ILP objective function.

5.2 Evaluation Metrics
We evaluated the output of DEANNA at three
stages in the processing pipeline: a) after the dis-
ambiguation of phrases, b) after the generation of
the SPARQL query, and c) after obtaining answers
from the underlying linked-data sources. This way,
we could obtain insights into our building blocks,
in addition to assessing the end-to-end performance.
In particular, we could assess the goodness of the
question-to-query translation independently of the
actual answer quality which may depend on partic-
ularities of the underlying datasets (e.g., slight mis-
matches between query terminology and the names
in the data.)

At each of the three stages, the output was shown
to two human assessors who judged whether an out-
put item was good or not. If the two were in dis-
agreement, then a third person resolved the judg-
ment.

For the disambiguation stage, the judges looked
at each q-node/s-node pair, in the context of the
question and the underlying data schemas, and de-
termined whether the mapping was correct or not
and whether any expected mappings were missing.
For the query-generation stage, the judges looked
at each triple pattern and determined whether the
pattern was meaningful for the question or not and
whether any expected triple pattern was missing.
Note that, because our approach does not use any
query templates, the same question may generate se-
mantically equivalent queries that differ widely in
terms of their structure. Hence, we rely on our eval-
uation metrics that are based on triple patterns, as
there is no gold-standard query for a given ques-
tion. For the query-answering stage, the judges were
asked to identify if the result sets for the generated
queries are satisfactory.

With these assessments, we computed over-
all quality measures by both micro-averaging and
macro-averaging. Micro-averaging aggregates over
all assessed items (e.g., q-node/s-node pairs or triple

patterns) regardless of the questions to which they
belong. Macro-averaging first aggregates the items
for the same question, and then averages the quality
measure over all questions.

For a question q and item set s in one of the stages
of evaluation, let correct(q, s) be the number of cor-
rect items in s, ideal(q) be the size of the ideal item
set and retrieved(q, s) be the number of retrieved
items, we define coverage and precision as follows:

cov(q, s) = correct(q, s)/ideal(q)

prec(q, s) = correct(q, s)/retrieved(q, s).

5.3 Results & Discussion
5.3.1 Disambiguation

Table 1 shows the results for disambiguation in
terms of macro and micro coverage and precision.
For both datasets, coverage is high as few mappings
are missing. We obtain perfect precision for QALD-
1 as no mapping that we generate is incorrect, while
for NAGA we generate few incorrect mappings.

5.3.2 Query Generation
Table 2 shows the same metrics for the generated

triple patterns. The results are similar to those for
disambiguation. Missing or incorrect triple patterns
can be attributed to (i) incorrect mappings in the dis-
ambiguation stage or (ii) incorrect detection of de-
pendencies between phrases despite having the cor-
rect mappings.

5.3.3 Question Answering
Table 3 shows the results for query answering.

Here, we attempt to generate answers to questions
by executing the generated queries over the datasets.
The table shows the number of questions for which
the system successfully generated SPARQL queries
(#queries), and among those, how many resulted
in satisfactory answers as judged by our evalua-
tors (#satisfactory). Answers were considered un-
satisfactory when: 1) the generated SPARQL query
was wrong, 2) the result set was empty due to the
incompleteness of the underlying knowledge base,
or 3) a small fraction of the result set was relevant
to the question. For both sets of questions, most of
the queries that were perceived unsatisfactory were
ones that returned no answers. Table 4 shows a
set of example QALD questions, the corresponding
SPARQL queries and sample answers.

386



Benchmark QALD-1 NAGA
covmacro 0.973 0.934
precmacro 1.000 0.934
covmicro 0.963 0.945
precmicro 1.000 0.941

Table 1: Disambiguation

Benchmark QALD-1 NAGA
covmacro 0.975 0.894
precmacro 1.000 0.941
covmicro 0.956 0.847
precmicro 1.000 0.906

Table 2: Query generation

Benchmark QALD-1 NAGA
#questions 27 44
#queries 20 41
#satisfactory 10 15
#relaxed +3 +3

Table 3: Query answering

Question Generated Query Sample Answers
1. Who was the wife of President

Lincoln?
?x marriedTo Abraham Lincoln .

?x type person
Mary Todd Lincoln

2. In which films did Julia Roberts
as well as Richard Gere play?

?x type movie . Richard Gere actedIn ?x .

Julia Roberts actedIn ?x

Runaway Bride

Pretty Woman

3. Which actors were born in
Germany?

?x type actor . ?x bornIn Germany NONE

Table 4: Example questions, the generated SPARQL queries and their answers

Queries that produced no answers, such as the
third query in Table 4 were further relaxed using an
incarnation of the techniques described in (Elbas-
suoni et al., 2009), by retaining the triple patterns
expressing type constraints and relaxing all other
triple patterns. Relaxing a triple pattern was done
by replacing all entities with variables and casting
entity mentions into keywords that are attached to
the relaxed triple pattern. For example, the QALD
question “Which actors were born in Germany?”
was translated into the following SPARQL query:
?x type actor . ?x bornIn Germany which pro-
duced no answers when run over the Yago2 knowl-
edge base since the relation bornIn relates peo-
ple to cities and not countries in Yago2. The
query was then relaxed into: ?x type actor . ?x
bornIn ?z[Germany]. This relaxed (and keyword-
augmented) triple-pattern query was then processed
the same way as triple-pattern queries without any
keywords. The results of such query were then
ranked based on how well they match the keyword
conditions specified in the relaxed query using the
ranking model in (Elbassuoni et al., 2009). Using
this technique, the top ranked results for the relaxed
query were all actors born in German cities as shown
in Table 5.

After relaxation, the judges again assessed the re-
sults of the relaxed queries and determined whether
they were satisfactory or not. The number of addi-
tional queries that obtained satisfactory answers af-
ter relaxation are shown under #relaxed in Table 3.

The evaluation data, in addition to a demonstra-
tion of our system (Yahya et al., 2012), can be found
at http://mpi-inf.mpg.de/yago-naga/deanna/.

6 Related Work
Question answering has a long history in NLP and
IR research. The Web and Wikipedia have proved to
be a valuable resource for answering fact-oriented
questions. State-of-the-art methods (Hirschman and
Gaizauskas, 2001; Kwok et al., 2001; Zheng, 2002;
Katz et al., 2007; Dang et al., 2007; Voorhees, 2003)
cast the user’s question into a keyword query to a
Web search engine (perhaps with phrases for loca-
tion and person names or other proper nouns). Key
to finding good results is to retrieve and rank sen-
tences or short passages that contain all or most key-
words and are likely to yield good answers. Together
with trained classifiers for the question type (and
thus the desired answer type), this methodology per-
forms fairly well for both factoid and list questions.

IBM’s Watson project (Ferrucci et al., 2010)
demonstrated a new kind of deep QA. A key ele-
ment in Watson’s approach is to decompose com-
plex questions into several cues and sub-cues,
with the aim of generating answers from matches
for the various cues (tapping into the Web and
Wikipedia). Knowledge bases like DBpedia (Auer
et al., 2007), Freebase (Bollacker et al., 2008), and
Yago (Suchanek et al., 2007)) are used for both an-
swering parts of questions that can be translated to
structured form (Chu-Carroll et al., 2012) and type-
checking possible answer candidates and thus filter-
ing out spurious results (Kalyanpur et al., 2011).

The recent QALD-1 initiative (QAL, 2011) pro-
posed a benchmark task to translate questions into
SPARQL queries over linked-data sources like DB-
pedia and MusicBrainz. FREyA (Damljanovic et
al., 2011), the best performing system, relies on

387



Q: ?x type actor . ?x wasBornIn ?z[Germany]
Martin Lawrence type actor . Martin Lawrence wasBornIn Frankfurt am Main

Robert Schwentke type actor . Robert Schwentke wasBornIn Stuttgart
Willy Millowitsch type actor . Willy Millowitsch wasBornIn Cologne

Jerry Zaks type actor . Jerry Zaks wasBornIn Stuttgart

Table 5: Top-4 results for the QALD question “Which actors were born in Germany?” after relaxation

interaction with the user to interpret the question.
Earlier work on mapping questions into structured
queries includes the work by Frank et al. (2007) and
Unger and Cimiano (2011). Frank et al. (2007) used
lexical-conceptual templates for query generation.
However, this work did not address the crucial issue
of disambiguating the constituents of the question.
In Pythia, Unger and Cimiano (2011) relied on an
ontology-driven grammar for the question language
so that questions could be directly mapped onto the
vocabulary of the underlying ontology. Such gram-
mars are obviously hard to craft for very large, com-
plex, and evolving knowledge bases. Nalix is an at-
tempt to bring question answering to XML data (Li,
Yang, and Jagadish, 2007) by mapping questions to
XQuery expressions, relying on human interaction
to resolve possible ambiguity.

Very recently, Unger et al. (2012) developed a
template-based approach based on Pythia, where
questions are automatically mapped to structured
queries in a two step process. First, a set of query
templates are generated for a question, independent
of the knowledge base, determining the structure of
the query. After that, each template is instantiated
with semantic items from the knowledge base. This
performs reasonably well for the QALD-1 bench-
mark: out of 50 test questions, 34 could be mapped,
and 19 were correctly answered.

Efforts on user-friendly exploration of struc-
tured data include keyword search over relational
databases (Bhalotia et al., 2002) and structured key-
word search (Pound et al., 2010). The latter is a com-
promise between full natural language and struc-
tured queries, where the user provides the structure
and the system takes care of the disambiguation of
keyword phrases.

Our joint disambiguation method was inspired
by recent work on NED (Milne and Witten, 2008;
Kulkarni et al., 2009; Hoffart et al., 2011a) and
WSD (Navigli, 2009). In contrast to this prior work
on related problems, our graph construction and

constraints are more complex, as we address the
joint mapping of arbitrary phrases onto entities,
classes, or relations. Moreover, instead of graph al-
gorithms or factor-graph learning, we use an ILP for
solving the ambiguity problem. This way, we can ac-
commodate expressive constraints, while being able
to disambiguate all phrases in a few seconds.

DEANNA uses dictionaries of names and phrases
for entities, classes, and relations. Spitkovsky and
Chang (2012) recently released a huge dictionary of
pairs of phrases and Wikipedia links, derived from
Google’s Web index. For relations, Nakashole et al.
(2012) released PATTY, a large taxonomy of pat-
terns with semantic types.

7 Conclusions and Future Work

We presented a method for translating natural-
language questions into structured queries. The nov-
elty of this method lies in modeling several map-
ping stages as a joint ILP problem. We harness type
signatures and other information from large-scale
knowledge bases. Although our model, in princi-
ple, leads to high combinatorial complexity, we ob-
served that the Gurobi solver could handle our ju-
diciously designed ILP very efficiently. Our experi-
mental studies showed very high precision and good
coverage of the query translation, and good results
in the actual question answers.

Future work includes relaxing some of the limita-
tions that our current approach still has. First, ques-
tions with aggregations cannot be handled at this
point. Second, queries sometimes return empty an-
swers although they perfectly capture the original
question, but the underlying data sources are incom-
plete or represent the relevant information in an un-
expected manner. We plan to extend our approach of
combining structured data with textual descriptions,
and generate queries that combine structured search
predicates with keyword or phrase matching.

388



References
Auer, S.; Bizer, C.; Kobilarov, G.; Lehmann, J.; Cyga-

niak, R.; and Ives, Z. G. 2007. DBpedia: A Nucleus
for a Web of Open Data. In ISWC/ASWC.

Bhalotia, G.; Hulgeri, A.; Nakhe, C.; Chakrabarti, S.; and
Sudarshan, S. 2002. Keyword Searching and Brows-
ing in Databases using BANKS. In ICDE.

Bollacker, K. D.; Evans, C.; Paritosh, P.; Sturge, T.; and
Taylor, J. 2008. Freebase: a Collaboratively Created
Graph Database for Structuring Human Knowledge.
In SIGMOD.

Chu-Carroll, J.; Fan, J.; Boguraev, B. K.; Carmel, D.; and
Sheinwald, D.; Welty, C. 2012. Finding needles in the
haystack: Search and candidate generation. In IBM J.
Res. & Dev., vol 56, no.3/4.

Damljanovic, D.; Agatonovic, M.; and Cunningham, H.
2011. FREyA: an Interactive Way of Querying Linked
Data using Natural Language.

Dang, H. T.; Kelly, D.; and Lin, J. J. 2007. Overview of
the trec 2007 question answering track. In TREC.

de Marneffe, M. C.; Maccartney, B.; and Manning, C. D.
2006. Generating typed dependency parses from
phrase structure parses. In LREC.

Elbassuoni, S.; Ramanath, M.; Schenkel, R.; Sydow, M.;
and Weikum, G. 2009. Language-model-based rank-
ing for queries on rdf-graphs. In CIKM.

Elbassuoni, S.; Ramanath, M.; and Weikum, G. 2011.
Query relaxation for entity-relationship search. In
ESWC.

Fader, A.; Soderland, S.; and Etzioni, O. 2011. Iden-
tifying relations for open information extraction. In
EMNLP.

Ferrucci, D. A.; Brown, E. W.; Chu-Carroll, J.; Fan, J.;
Gondek, D.; Kalyanpur, A.; Lally, A.; Murdock, J. W.;
Nyberg, E.; Prager, J. M.; Schlaefer, N.; and Welty,
C. A. 2010. Building Watson: An Overview of the
DeepQA Project. AI Magazine 31(3).

Frank, A.; Krieger, H.-U.; Xu, F.; Uszkoreit, H.; Crys-
mann, B.; Jörg, B.; and Schäfer, U. 2007. Question
Answering from Structured Knowledge Sources. J.
Applied Logic 5(1).

Gurobi Optimization, Inc. 2012. Gurobi Optimizer Ref-
erence Manual. http://www.gurobi.com/.

Heath, T., and Bizer, C. 2011. Linked Data: Evolving
the Web into a Global Data Space. San Rafael, CA:
Morgan & Claypool, 1 edition.

Hirschman, L., and Gaizauskas, R. 2001. Natural Lan-
guage Question Answering: The View from Here. Nat.
Lang. Eng. 7.

Hoffart, J.; Mohamed, A. Y.; Bordino, I.; Fürstenau, H.;
Pinkal, M.; Spaniol, M.; Taneva, B.; Thaterm S.; and
Weikum, G. 2011. Robust Disambiguation of Named
Entities in Text. In EMNLP.

Hoffart, J.; Suchanek, F. M.; Berberich, K.; Lewis-
Kelham, E.; de Melo, G.; and Weikum, G. 2011.
Yago2: exploring and querying world knowledge in
time, space, context, and many languages. In WWW
(Companion Volume).

Kalyanpur, A.; Murdock, J. W.; Fan, J.; and Welty, C. A.
2011. Leveraging community-built knowledge for
type coercion in question answering. In International
Semantic Web Conference.

Katz, B.; Felshin, S.; Marton, G.; Mora, F.; Shen, Y. K.;
Zaccak, G.; Ammar, A.; Eisner, E.; Turgut, A.; and
Westrick, L. B. 2007. CSAIL at TREC 2007 Ques-
tion Answering. In TREC.

Kulkarni, S.; Singh, A.; Ramakrishnan, G.; and
Chakrabarti, S. 2009. Collective annotation of
wikipedia entities in web text. In KDD.

Kwok, C. C. T.; Etzioni, O.; and Weld, D. S. 2001. Scal-
ing Question Answering to the Web. In WWW.

Li, Y.; Yang, H.; and Jagadish, H. V. 2007. NaLIX:
A Generic Natural Language Search Environment for
XML Data. ACM Trans. Database Syst. 32(4).

Milne, D. N., and Witten, I. H. 2008. Learning to link
with wikipedia. In CIKM.

Ndapandula Nakashole, Gerhard Weikum and Fabian
Suchanek 2012. PATTY: A Taxonomy of Relational
Patterns with Semantic Types. In EMNLP.

Navigli, R. 2009. Word sense disambiguation: A survey.
ACM Comput. Surv. 41(2).

Pound, J.; Ilyas, I. F.; and Weddell, G. E. 2010. Ex-
pressive and Flexible Access to Web-extracted Data: A
Keyword-based Structured Query Language. In SIG-
MOD.

2011. 1st Workshop on Question Answering over
Linked Data (QALD-1). http://www.sc.cit-ec.uni-
bielefeld.de/qald-1.

Resnik, P. 1995. Using Information Content to Evaluate
Semantic Similarity in a Taxonomy. In IJCAI.

Spitkovsky, V. I. Spitkovsky; Chang, A. X. ; 2012. A
Cross-Lingual Dictionary for English Wikipedia Con-
cepts. In LREC.

Suchanek, F. M.; Kasneci, G.; and Weikum, G. 2007.
Yago: a core of semantic knowledge. In WWW.

Tummarello, G.; Cyganiak, R.; Catasta, M.; Danielczyk,
S.; Delbru, R.; and Decker, S. 2010. Sig.ma: Live
views on the web of data. J. Web Sem. 8(4).

Unger, C.; and Cimiano, P. 2011. Pythia: Compositional
Meaning Construction for Ontology-Based Question
Answering on the Semantic Web. In NLDB.

Unger, C.; Bühmann, L.; Lehmann, J.; Ngonga Ngomo,
A.-C.; Gerber, D.; and Cimiano, P. 2012. Template-
based question answering over RDF data. In WWW.

Voorhees, E. M. 2003. Overview of the trec 2003 ques-
tion answering track. In TREC.

389



Yahya, M.; Berberich, K.; Elbassuoni, S.; Ramanath, M.;
Tresp, V.; and Weikum, G. 2012. Deep answers
for naturally asked questions on the web of data. In
WWW.

Zheng, Z. 2002. AnswerBus Question Answering Sys-
tem. In HLT.

390


