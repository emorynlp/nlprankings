



















































Composite Task-Completion Dialogue Policy Learning via Hierarchical Deep Reinforcement Learning


Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2231â€“2240
Copenhagen, Denmark, September 7â€“11, 2017. cÂ©2017 Association for Computational Linguistics

Composite Task-Completion Dialogue Policy Learning via
Hierarchical Deep Reinforcement Learning

Baolin Peng? Xiujun Liâ€  Lihong Liâ€  Jianfeng Gaoâ€ 
Asli Celikyilmazâ€  Sungjin Leeâ€  Kam-Fai Wong?

â€ Microsoft Research, Redmond, WA, USA
?The Chinese University of Hong Kong, Hong Kong

{blpeng, kfwong}@se.cuhk.edu.hk
{xiul,lihongli,jfgao,aslicel,sule}@microsoft.com

Abstract

Building a dialogue agent to fulfill com-
plex tasks, such as travel planning, is chal-
lenging because the agent has to learn
to collectively complete multiple subtasks.
For example, the agent needs to reserve a
hotel and book a flight so that there leaves
enough time for commute between arrival
and hotel check-in. This paper addresses
this challenge by formulating the task in
the mathematical framework of options
over Markov Decision Processes (MDPs),
and proposing a hierarchical deep rein-
forcement learning approach to learning a
dialogue manager that operates at differ-
ent temporal scales. The dialogue man-
ager consists of: (1) a top-level dialogue
policy that selects among subtasks or op-
tions, (2) a low-level dialogue policy that
selects primitive actions to complete the
subtask given by the top-level policy, and
(3) a global state tracker that helps ensure
all cross-subtask constraints be satisfied.
Experiments on a travel planning task with
simulated and real users show that our ap-
proach leads to significant improvements
over three baselines, two based on hand-
crafted rules and the other based on flat
deep reinforcement learning.

1 Introduction

There is a growing demand for intelligent personal
assistants, mainly in the form of dialogue agents,
that can help users accomplish tasks ranging from
meeting scheduling to vacation planning. How-
ever, most of the popular agents in todayâ€™s market,
such as Amazon Echo, Apple Siri, Google Home
and Microsoft Cortana, can only handle very sim-
ple tasks, such as reporting weather and requesting

songs. Building a dialogue agent to fulfill complex
tasks remains one of the most fundamental chal-
lenges for the NLP community and AI in general.

In this paper, we consider an important type of
complex tasks, termed composite task, which con-
sists of a set of subtasks that need to be fulfilled
collectively. For example, in order to make a travel
plan, we need to book air tickets, reserve a hotel,
rent a car, etc. in a collective way so as to satisfy a
set of cross-subtask constraints, which we call slot
constraints. Examples of slot constraints for travel
planning are: hotel check-in time should be later
than the flightâ€™s arrival time, hotel check-out time
may be earlier than the return flight depart time,
the number of flight tickets equals to that of hotel
check-in people, and so on.

It is common to learn a task-completion dia-
logue agent using reinforcement learning (RL);
see Su et al. (2016); CuayaÌhuitl (2017); Williams
et al. (2017); Dhingra et al. (2017) and Li et al.
(2017a) for a few recent examples. Compared
to these dialogue agents developed for individ-
ual domains, the composite task presents addi-
tional challenges to commonly used, flat RL ap-
proaches such as DQN (Mnih et al., 2015). The
first challenge is reward sparsity. Dialogue pol-
icy learning for composite tasks requires explo-
ration in a much larger state-action space, and it
often takes many more conversation turns between
user and agent to fulfill a task, leading to a much
longer trajectory. Thus, the reward signals (usu-
ally provided by users at the end of a conversa-
tion) are delayed and sparse. As we will show in
this paper, typical flat RL methods such as DQN
with naive âœ-greedy exploration is rather ineffi-
cient. The second challenge is to satisfy slot con-
straints across subtasks. This requirement makes
most of the existing methods of learning multi-
domain dialogue agents (CuayaÌhuitl, 2009; Gasic
et al., 2015b) inapplicable: these methods train a

2231



collection of policies, one for each domain, and
there is no cross-domain constraints required to
successfully complete a dialogue. The third chal-
lenge is improved user experience: we find in our
experiments that a flat RL agent tends to switch
between different subtasks frequently when con-
versing with users. Such incoherent conversations
lead to poor user experience, and are one of the
main reasons that cause a dialogue session to fail.

In this paper, we address the above mentioned
challenges by formulating the task using the math-
ematical framework of options over MDPs (Sutton
et al., 1999), and proposing a method that com-
bines deep reinforcement learning and hierarchi-
cal task decomposition to train a composite task-
completion dialogue agent. At the heart of the
agent is a dialogue manager, which consists of (1)
a top-level dialogue policy that selects subtasks
(options), (2) a low-level dialogue policy that se-
lects primitive actions to complete a given subtask,
and (3) a global state tracker that helps ensure all
cross-subtask constraints be satisfied.

Conceptually, our approach exploits the struc-
tural information of composite tasks for efficient
exploration. Specifically, in order to mitigate the
reward sparsity issue, we equip our agent with an
evaluation module (internal critic) that gives in-
trinsic reward signals, indicating how likely a par-
ticular subtask is completed based on its current
state generated by the global state tracker. Such
intrinsic rewards can be viewed as heuristics that
encourage the agent to focus on solving a sub-
task before moving on to another subtask. Our ex-
periments show that such intrinsic rewards can be
used inside a hierarchical RL agent to make ex-
ploration more efficient, yielding a significantly
reduced state-action space for decision making.
Furthermore, it leads to a better user experience,
as the resulting conversations switch between sub-
tasks less frequently.

To the best of our knowledge, this is the first
work that strives to develop a composite task-
completion dialogue agent. Our main contribu-
tions are three-fold:

â€¢ We formulate the problem in the mathemati-
cal framework of options over MDPs.

â€¢ We propose a hierarchical deep reinforce-
ment learning approach to efficiently learning
the dialogue manager that operates at differ-
ent temporal scales.

â€¢ We validate the effectiveness of the proposed
approach in a travel planning task on simu-
lated as well as real users.

2 Related Work

Task-completion dialogue systems have attracted
numerous research efforts. Reinforcement learn-
ing algorithms hold the promise for dialogue pol-
icy optimization over time with experience (Schef-
fler and Young, 2000; Levin et al., 2000; Young
et al., 2013; Williams et al., 2017). Recent ad-
vances in deep learning have inspired many deep
reinforcement learning based dialogue systems
that eliminate the need for feature engineering (Su
et al., 2016; CuayaÌhuitl, 2017; Williams et al.,
2017; Dhingra et al., 2017; Li et al., 2017a).

All the work above focuses on single-domain
problems. Extensions to composite-domain dia-
logue problems are non-trivial due to several rea-
sons: the state and action spaces are much larger,
the trajectories are much longer, and in turn re-
ward signals are much more sparse. All these
challenges can be addressed by hierarchical re-
inforcement learning (Sutton et al., 1999, 1998;
Singh, 1992; Dietterich, 2000; Barto and Mahade-
van, 2003), which decomposes a complicated task
into simpler subtasks, possibly in a recursive way.
Different frameworks have been proposed, such as
Hierarchies of Machines (Parr and Russell, 1997)
and MAXQ decomposition (Dietterich, 2000). In
this paper, we choose the options framework for its
conceptual simplicity and generality (Sutton et al.,
1998); more details are found in the next sec-
tion. Our work is also motivated by hierarchical-
DQN (Kulkarni et al., 2016) which integrates hi-
erarchical value functions to operate at different
temporal scales. The model achieved superior per-
formance on a complicated ATARI game â€œMon-
tezumaâ€™s Revengeâ€ with a hierarchical structure.

A related but different extension to single-
domain dialogues is multi-domain dialogues,
where each domain is handled by a sepa-
rate agent (Lison, 2011; Gasic et al., 2015a,b;
CuayaÌhuitl et al., 2016). In contrast to composite-
domain dialogues studied in this paper, a conver-
sation in a multi-domain dialogue normally in-
volves one domain, so completion of a task does
not require solving sub-tasks in different domains.
Consequently, work on multi-domain dialogues
focuses on different technical challenges such as
transfer learning across different domains (Gasic

2232



et al., 2015a) and domain selection (CuayaÌhuitl
et al., 2016).

3 Dialogue Policy Learning

Our composite task-completion dialogue agent
consists of four components: (1) an LSTM-
based language understanding module (Hakkani-
TuÌˆr et al., 2016; Yao et al., 2014) for identifying
user intents and extracting associated slots; (2) a
state tracker for tracking the dialogue state; (3)
a dialogue policy which selects the next action
based on the current state; and (4) a model-based
natural language generator (Wen et al., 2015) for
converting agent actions to natural language re-
sponses. Typically, a dialogue manager contains
a state tracker and a dialogue policy. In our imple-
mentation, we use a global state tracker to main-
tain the dialogue state by accumulating informa-
tion across all subtasks, thus helping ensure all
inter-subtask constraints be satisfied. In the rest of
this section, we will describe the dialogue policy
in details.

User

Top-level dialogue 
policy learning

Low-level dialogue
policy learning

Internal Critic

Dialogue
action

Dialogue
action

Intrinsic
reward

Subgoal

Dialogue
states

Extrinsic
reward

Agent

Figure 1: Overview of a composite task-
completion dialogue agent.

3.1 Options over MDPs
Consider the following process of completing a
composite task (e.g., travel planning). An agent
first selects a subtask (e.g., book-flight-ticket),
then takes a sequence of actions to gather related
information (e.g., departure time, number of tick-
ets, destination, etc.) until all usersâ€™ requirements
are met and the subtask is completed, and finally
chooses the next subtask (e.g., reserve-hotel) to
complete. The composite task is fulfilled after all

its subtasks are completed collectively. The above
process has a natural hierarchy: a top-level process
selects which subtasks to complete, and a low-
level process chooses primitive actions to com-
plete the selected subtask. Such hierarchical de-
cision making processes can be formulated in the
options framework (Sutton et al., 1999), where op-
tions generalize primitive actions to higher-level
actions. Different from the traditional MDP set-
ting where an agent can only choose a primitive
action at each time step, with options the agent
can choose a â€œmulti-stepâ€ action which for exam-
ple could be a sequence of primitive actions for
completing a subtask. As pointed out by Sutton
et al. (1999), options are closely related to actions
in a family of decision problems known as semi-
Markov decision processes.

Following Sutton et al. (1999), an option con-
sists of three components: a set of states where
the option can be initiated, an intra-option policy
that selects primitive actions while the option is in
control, and a termination condition that specifies
when the option is completed. For a composite
task such as travel planning, subtasks like book-
flight-ticket and reserve-hotel can be modeled as
options. Consider, for example, the option book-
flight-ticket: its initiation state set contains states
in which the tickets have not been issued or the
destination of the trip is long away enough that a
flight is needed; it has an intra-option policy for re-
questing or confirming information regarding de-
parture date and the number of seats, etc.; it also
has a termination condition for confirming that all
information is gathered and correct so that it is
ready to issue the tickets.

ğ‘”1

ğ‘1, ğ‘”1 ğ‘2, ğ‘”1 ğ‘3, ğ‘”1

ğ‘”2

ğ‘4, ğ‘”2 ğ‘5, ğ‘”2 ğ‘6, ğ‘”2

ğ‘”n

Top-level Dialogue Policy ğ…ğ‘”(ğ‘”ğ‘¡; ğ‘ ğ‘¡)

Low-level Dialogue Policy ğ…ğ‘,ğ‘”(ğ‘ğ‘¡; ğ‘ ğ‘¡, ğ‘”ğ‘¡)

ğ…ğ‘”(ğ‘”ğ‘¡; ğ‘ ğ‘¡) ğ…ğ‘,g(ğ‘ğ‘¡; ğ‘ ğ‘¡, ğ‘”ğ‘¡)ğ‘ ğ‘¡

ğ‘”1
ğ‘”2
ğ‘”ğ‘›

ğ‘1
ğ‘2
ğ‘ğ‘š

â€¦ â€¦

ğ‘ ğ‘¡
ğ‘”ğ‘¡

Figure 2: Illustration of a two-level hierarchical
dialogue policy learner.

3.2 Hierarchical Policy Learning
The intra-option is a conventional policy over
primitive actions, we can consider an inter-option

2233



policy over sequences of options in much the same
way as we consider the intra-option policy over
sequences of actions. We propose a method that
combines deep reinforcement learning and hierar-
chical value functions to learn a composite task-
completion dialogue agent as shown in Figure 1. It
is a two-level hierarchical reinforcement learning
agent that consists of a top-level dialogue policy
â‡¡g and a low-level dialogue policy â‡¡a,g, as shown
in Figure 2. The top-level policy â‡¡g perceives
state s from the environment and selects a subtask
g 2 G, where G is the set of all possible subtasks.
The low-level policy â‡¡a,g is shared by all options.
It takes as input a state s and a subtask g, and out-
puts a primitive action a 2 A, where A is the set
of primitive actions of all subtasks. The subtask g
remains a constant input to â‡¡a,g, until a terminal
state is reached to terminate g. The internal critic
in the dialogue manager provides intrinsic reward
rit(gt), indicating whether the subtask gt at hand
has been solved; this signal is used to optimize
â‡¡a,g. Note that the state s contains global infor-
mation, in that it keeps track of information for all
subtasks.

Naturally, we aim to optimize the low-level pol-
icy â‡¡a,g so that it maximizes the following cumu-
lative intrinsic reward at every step t:

max
â‡¡a,g

E
h X

kï¿½0
ï¿½krit+k

ï¿½ï¿½ï¿½st = s, gt = g, at+k = â‡¡a,g(st+k)i ,
where rit+k denotes the reward provided by the in-
ternal critic at step t + k. Similarly, we want the
top-level policy â‡¡g to optimize the cumulative ex-
trinsic reward at every step t:

max
â‡¡g

E
h X

kï¿½0
ï¿½kret+k

ï¿½ï¿½ï¿½st = s, at+k = â‡¡g(st+k)i ,
where ret+k is the reward received from the envi-
ronment at step t + k when a new subtask starts.

Both the top-level and low-level policies can
be learned with deep Q-learning methods, like
DQN. Specifically, the top-level dialogue policy
estimates the optimal Q-function that satisfies the
following:

Qâ‡¤1(s, g) = E
h Nï¿½1X

k=0

ï¿½kret+k+

ï¿½N Â· maxg0 Qâ‡¤1(st+N , g0)|st = s, gt = g
i
, (1)

where N is the number of steps that the low-level
dialogue policy (intra-option policy) needs to ac-
complish the subtask. g0 is the agentâ€™s next subtask

in state st+N . Similarly, the low-level dialogue
policy estimates the Q-function that satisfies the
following:

Qâ‡¤2(s, a, g) = E
h
rit+

ï¿½ Â· max
at+1

Qâ‡¤2(st+1, at+1, g)|st = s, gt = g
i
.

Both Qâ‡¤1(s, g) and Qâ‡¤2(s, a, g) are represented by
neural networks, Q1(s, g; âœ“1) and Q2(s, a, g; âœ“2),
parameterized by âœ“1 and âœ“2, respectively.

The top-level dialogue policy tries to minimize
the following loss function at each iteration i:

L1(âœ“1,i) = E(s,g,re,s0)â‡ D1 [(yi ï¿½Q1(s, g; âœ“1,i))2]
yi = re + ï¿½N max

g0
Q1(s0, g0, âœ“1,iï¿½1) ,

where, as in Equation (1), re =
PNï¿½1

k=0 ï¿½
kret+k is

the discounted sum of reward collected when sub-
goal g is being completed, and N is the number of
steps g is completed.

The low-level dialogue policy minimizes the
following loss at each iteration i using:

L2(âœ“2,i) = E(s,g,a,ri,s0)â‡ D2 [(yi ï¿½
Q2(s, g, a; âœ“2,i))2]

yi = ri + ï¿½ max
a0

Q2(s0, g, a0, âœ“2,iï¿½1) .

We use SGD to minimize the above loss func-
tions. The gradient for the top-level dialogue pol-
icy yields:

râœ“1,iL1(âœ“1,i) = E(s,g,re,s0)â‡ D1 [(re+
ï¿½N max

g0
Q2(s0, g0, âœ“1,iï¿½1)ï¿½Q1(s, g, âœ“1,i))
râœ“1,iQ1(s, g, âœ“1,i)]

(2)

The gradient for the low-level dialogue policy
yields:

râœ“2,iL2(âœ“2,i) = E(s,g,a,ri,s0)â‡ D2 [(ri+
ï¿½ max

a0
Q2(s0, g, a0, âœ“2,iï¿½1)ï¿½Q2(s, g, a, âœ“2,i))
râœ“2,iQ2(s, g, a, âœ“2,i)]

(3)

Following previous studies, we apply two most
commonly used performance boosting methods:
target networks and experience replay. Experi-
ence replay tuples (s, g, re, s0) and (s, g, a, ri, s0),
are sampled from the experience replay buffers D1
and D2 respectively. A detailed summary of the
learning algorithm for the hierarchical dialogue
policy is provided in Appendix B.

2234



4 Experiments and Results

To evaluate the proposed method, we conduct ex-
periments on the composite task-completion dia-
logue task of travel planning.

4.1 Dataset
In the study, we made use of a human-human
conversation data derived from a publicly avail-
able multi-domain dialogue corpus1 (El Asri et al.,
2017), which was collected using the Wizard-of-
Oz approach. We made a few changes to the
schema of the data set for the composite task-
completion dialogue setting. Specifically, we
added inter-subtask constraints as well as user
preferences (soft constraints). The data was
mainly used to create simulated users, as will be
explained below shortly.

4.2 Baseline Agents
We benchmark the proposed HRL agent against
three baseline agents:

â€¢ A Rule Agent uses a sophisticated hand-
crafted dialogue policy, which requests and
informs a hand-picked subset of necessary
slots, and then confirms with the user about
the reserved tickets.

â€¢ A Rule+ Agent requests and informs all the
slots in a pre-defined order exhaustedly, and
then confirms with the user about the re-
served tickets. The average turn of this agent
is longer than that of the Rule agent.

â€¢ A flat RL Agent is trained with a standard flat
deep reinforcement learning method (DQN)
which learns a flat dialogue policy using ex-
trinsic rewards only.

4.3 User Simulator
Training reinforcement learners is challenging be-
cause they need an environment to interact with.
In the dialogue research community, it is common
to use simulated users as shown in Figure 3 for
this purpose (Schatzmann et al., 2007; Asri et al.,
2016). In this work, we adapted the publicly-
available user simulator, developed by Li et al.
(2016), to the composite task-completion dialogue
setting using the human-human conversation data
described in Section 4.1.2 During training, the

1https://datasets.maluuba.com/Frames
2A detailed description of the user simulator is presented

in Appendix A.

simulator provides the agent with an (extrinsic) re-
ward signal at the end of the dialogue. A dialogue
is considered to be successful only when a travel
plan is made successfully, and the information
provided by the agent satisfies userâ€™s constraints.
At the end of each dialogue, the agent receives a
positive reward of 2â‡¤max turn (max turn = 60
in our experiments) for success, or a negative re-
ward of ï¿½max turn for failure. Furthermore, at
each turn, the agent receives a reward ofï¿½1 so that
shorter dialogue sessions are encouraged.

User Goal A user goal is represented by a set
of slots, indicating the userâ€™s request, requirement
and preference. For example, an inform slot, such
as dst city=â€œHonoluluâ€, indicates a user require-
ment, and a request slot, such as price=â€œ?â€, indi-
cates a user asking the agent for the information.

In our experiment, we compiled a list of user
goals using the slots collected from the human-
human conversation data set described in Sec-
tion 4.1, as follows. We first extracted all the
slots that appear in dialogue sessions. If a slot has
multiple values, like â€œor city=[San Francisco,
San Jose]â€, we consider it as a user preference
(soft constraint) which the user may later revise its
value to explore different options in the course of
the dialogue. If a slot has only one value, we treat
it as a user requirement (hard constraint), which is
unlikely negotiable. If a slot is with value â€?â€, we
treat it as a user request. We removed those slots
from user goals if their values do not exist in our
database. The compiled set of user goals contains
759 entries, each containing slots from at least two
subtasks: book-flight-ticket and reserve-hotel.

User Type To compare different agentsâ€™ ability
to adapt to user preferences, we also constructed
three additional user goal sets, representing three
different types of (simulated) users, respectively:

â€¢ Type A: All the informed slots in a user goal
have a single value. These users have hard
constraints for both the flight and hotel, and
have no preference on which subtask to ac-
complish first.

â€¢ Type B: At least one of informed slots in the
book-flight-ticket subtask can have multiple
values, and the user (simulator) prefers to
start with the book-flight-ticket subtask. If the
user receives â€œno ticket availableâ€ from the
agent during the conversation, she is willing
to explore alternative slot values.

2235



User Dialogue Action
Inform(depart_city=Seattle)

User 
Goal

User Agenda Modeling

User Simulator

Flight Hotel Rental Car

arrive_city=LA hotel_city=LA pickup_city=LA

depart_flight_date=4/14 checkin_date=4/14 pickup_date=4/14

depart_city=Seattle hotel_category= ? car_size= ?

Text Input
Iâ€™d like to book 
a flight to LA 
on 4/14.

â€¦

Natural Language 
Generation(NLG)

Semantic Frame
Inform(arrive_city=LA,
depart_flight_date=4/14)

Dialogue System

Dialogue 
Management 

(DM)
System Action/Policy
request_depart_city

ğœ‹g

ğœ‹ğ‘,ğ‘”

<slot>

wi wi+1 wi+2

O O

EOS

<intent>

w0 w1 w2 EOS

Natural Language 
Understanding(NLU)

Figure 3: Illustration of the Composite Task-Completion dialogue System

â€¢ Type C: Similar to Type B, at least one of in-
formed slots of the reserve-hotel subtask in a
user goal can have multiple values. The user
prefers to start with the reserve-hotel subtask.
If the user receives a â€œno room availableâ€ re-
sponse from the agent, she is willing to ex-
plore alternative slot values.

4.4 Implementation
For the RL agent, we set the size of hidden layer
to 80. For the HRL agent, both top-level and low-
level dialogue policies had a hidden layer size of
80. RMSprop was applied to optimize the pa-
rameters. We set batch size to 16. During train-
ing, we used the âœ-greedy strategy for exploration.
For each simulation epoch, we simulated 100 dia-
logues and stored these state transition tuples in an
experience replay buffer. At the end of each sim-
ulation epoch, the model was updated with all the
transition tuples in the buffer in a batch manner.

The experience replay strategy is critical to the
success of deep reinforcement learning. In our ex-
periments, at the beginning, we used a rule-based
agent to run N (N = 100) dialogues to popu-
late the experience replay buffer, which was an
implicit way of imitation learning to initialize the
RL agent. Then, the RL agent accumulated all the
state transition tuples and flushes the replay buffer
only when the current RL agent reached a success
rate threshold no worse than that of the Rule agent.

This strategy was motivated by the following
observation. The initial performance of an RL
agent was often not strong enough to result in

dialogue sessions with a reasonable success rate.
With such data, it was easy for the agent to learn
the locally optimal policy that â€œfailed fastâ€; that is,
the policy would finish the dialogue immediately,
so that the agent could suffer the least amount of
per-turn penalty. Therefore, we provided some
rule-based examples that succeeded reasonably of-
ten, and did not flush the buffer until the per-
formance of the RL agent reached an acceptable
level. Generally, one can set the threshold to be
the success rate of the Rule agent. To make a fair
comparison, for the same type of users, we used
the same Rule agent to initialize both the RL agent
and the HRL agent.

4.5 Simulated User Evaluation

On the composite task-completion dialogue task,
we compared the HRL agent with the baseline
agents in terms of three metrics: success rate3, av-
erage rewards, and the average number of turns per
dialogue session.

Figure 4 shows the learning curves of all four
agents trained on different types of users. Each
learning curve was averaged over 10 runs. Table 1
shows the performance on test data. For all types
of users, the HRL-based agent yielded more robust
dialogue policies outperforming the hand-crafted
rule-based agents and flat RL-based agent mea-
sured on success rate. It also needed fewer turns
per dialogue session to accomplish a task than the
rule-based agents and flat RL agent. The results

3Success rate is the fraction of dialogues where the tasks
are successfully accomplished within the maximum turns.

2236



Type A Type B Type C
Agent Succ. Turn Reward Succ. Turn Reward Succ. Turn Reward
Rule .322 46.2 -24.0 .240 54.2 -42.9 .205 54.3 -49.3

Rule+ .535 82.0 -3.7 .385 110.5 -44.95 .340 108.1 -51.85
RL .437 45.6 -3.3 .340 52.2 -23.8 .348 49.5 -21.1

HRL .632 43.0 33.2 .600 44.5 26.7 .622 42.7 31.7

Table 1: Performance of three agents on different User Types. Tested on 2000 dialogues using the best
model during training. Succ.: success rate, Turn: average turns, Reward: average reward.

(a) Success Rate of User Type A (b) Success Rate of User Type B (c) Success Rate of User Type C

Figure 4: Learning curves of dialogue policies for different User Types under simulation

Figure 5: Performance of HRL agent versus RL
agent tested with real users: success rate, num-
ber of tested dialogues and p-values are indicated
on each bar; the rightmost green ones are for total
(difference in mean is significant with p < 0.01).

across all three types of simulated users suggest
the following conclusions.

First, he HRL agent significantly outperformed
the RL agent. This, to a large degree, was at-
tributed to the use of the hierarchical structure of
the proposed agent. Specifically, the top-level di-
alogue policy selected a subtask for the agent to
focus on, one at a time, thus dividing a complex
task into a sequence of simpler subtasks. The se-
lected subtasks, combined with the use of intrin-
sic rewards, alleviated the sparse reward and long-
horizon issues, and helped the agent explore more

Figure 6: Distribution of user ratings for HRL
agent versus RL agent, and total.

efficiently in the state-action space. As a result, as
shown in Figure 4 and Table 1, the performance of
the HRL agent on types B and C users (who may
need to go back to revise some slots during the
dialogue) does not drop much compared to type A
users, despite the increased search space in the for-
mer. Additionally, we observed a large drop in the
performance of the RL Agent due to the increased
complexity of the task, which required more di-
alogue turns and posed a challenge for temporal
credit assignment.

Second, the HRL agent learned much faster
than the RL agent. The HRL agent could reach
the same level of performance with a smaller num-
ber of simulation examples than the RL agent,

2237



Table 2: Sample dialogue by RL and HRL agents with real user: Left column shows the dialogue with
the RL agent; Right column shows the dialogue with the HRL agent; bolded slots are the joint constraints
between two subtasks.

User Goal
reserve-hotel subtask:
{

â€œrequest slotsâ€: { â€œinform slotsâ€: {
â€œhotel priceâ€: â€œ?â€ â€œhotel cityâ€: â€œCancunâ€,
â€œhotel date checkoutâ€: â€œ?â€ â€œhotel numberofpeopleâ€: â€œ3â€,
â€œhotel nameâ€: â€œ?â€ â€œhotel date checkinâ€: â€œ09/20â€

}, }
}

book-flight-ticket subtask:
{

â€œrequest slotsâ€: { â€œinform slotsâ€: {
â€œpriceâ€: â€œ?â€ â€œor cityâ€: â€œCampinasâ€,
â€œreturn time depâ€: â€œ?â€ â€œdst cityâ€: â€œCancunâ€,
â€œreturn date depâ€: â€œ?â€ â€œnumberofpeopleâ€: â€œ3â€,
â€œdepart time depâ€: â€œ?â€ â€œdepart date:Ìˆ â€9/20â€
â€œseatâ€: â€œ?â€ }

}
}

RL agent HRL agent
Agent: Welcome to our travel agent. May I know your Agent: Welcome to our travel agent. May I know your
original city, destination city and departure date? original city, destination city and departure date?
User: I depart from Campinas to Cancun and prefer to User: I depart from Campinas to Cancun and prefer to
leave on 09-20. leave on 09-20.
Agent: There is a return flight on 9/26 and hotel checkout date Agent: Only Business class seat is available.
is on 9/26 too.
User: My wife and son will travel with me, three people in total. User: What is the depart time?
Agent: There is a hotel called Hotel Tropic available for you. Agent: Departure time is at 10:00AM.
User: What depart time is available? User: My wife and son will travel with me,

three people in total.
Agent: Departure time is at 10:00AM. Agent: There is one return flight departed at 4:00PM.
User: What is the departure time of return flight? User: What is the date of the return flight?
Agent: It is 4:00PM. Agent: It is on 9/26 and hotel checkout date is also 9/26.
User: Which seat is available? User: Whatâ€™s the price for the flight?
Agent: Only Business class available. Agent: Total is 1399 dollars for flight.
User: Whatâ€™s the price for the flight? User: Which hotel is available?
Agent: Total is 1399 dollars for flight. Agent: A hotel called Hotel Tropic is available for you.
User: Whatâ€™s the price for the hotel? User: Whatâ€™s the price for the hotel?
Agent: It is 1091 dollars for hotel. Agent: It is 1091 dollars for hotel.
User: Could you please help me book the tickets? User: Could you please help me book the tickets?
Agent: Departure flight on 9/20 and hotel checkin date Agent: Okay. Tickets are issued.
on 9/20 are available.
User: Could you please help me book the tickets? User: Thanks!
Agent: Okay. Tickets are issued. Agent: Thanks!
User: Thanks!
Agent: Thanks!

Success: but the agent does not behave naturally where is an Success
inter-subtask transition from book-flight-ticket to reserve-hotel.

demonstrating that the hierarchical dialogue poli-
cies were more sample-efficient than flat RL pol-
icy and could significantly reduce the sample com-
plexity on complex tasks.

Finally, we also found that the Rule+ and flat RL
agents had comparable success rates, as shown in
Figure 4. However, a closer look at the correlation
between success rate and the average number of
turns in Table 1 suggests that the Rule+ agent re-
quired more turns which adversely affects its suc-
cess, whilst the flat RL agent achieves similar suc-
cess with much less number of turns in all the user
types. It suffices to say that our hierarchical RL
agent outperforms all in terms of success rate as
depicted in Figure 4.

4.6 Human Evaluation

We further evaluated the agents, which were
trained on simulated users, against real human
users, recruited from the authorsâ€™ affiliation. We
conducted the study using the HRL and RL agents,
each tested against two types of users: Type A
users who had no preference for subtask, and Type
B users who preferred to complete the book-flight-
ticket subtask first. Note that Type C users were
symmetric to Type B ones, so were not included
in the study. We compared two (agent, user type)
pairs: {RL A, HRL A} and {RL B, HRL B}; in
other words, four agents were trained against their
specific user types. In each dialogue session, one
of the agents was randomly picked to converse
with a user. The user was presented with a user

2238



goal sampled from our corpus, and was instructed
to converse with the agent to complete the task. If
one of the slots in the goal had multiple values, the
user had multiple choices for this slot and might
revise the slot value when the agent replied with
a message like â€œNo ticket is availableâ€ during the
conversation. At the end of each session, the user
was asked to give a rating on a scale from 1 to 5
based on the naturalness and coherence of the di-
alogue. (1 is the worst rating, and 5 the best). We
collected a total of 225 dialogue sessions from 12
human users.

Figure 5 presents the performance of these
agents against real users in terms of success rate.
Figure 6 shows the comparison in user rating. For
all the cases, the HRL agent was consistently bet-
ter than the RL agent in terms of success rate and
user rating. Table 2 shows a sample dialogue ses-
sion. We see that the HRL agent produced a more
coherent conversation, as it switched among sub-
tasks much less frequently than the flat RL agent.

5 Discussion and Conclusions

This paper considers composite task-completion
dialogues, where a set of subtasks need to be ful-
filled collectively for the entire dialogue to be suc-
cessful. We formulate the policy learning prob-
lem using the options framework, and take a hier-
archical deep RL approach to optimizing the pol-
icy. Our experiments, both on simulated and real
users, show that the hierarchical RL agent signifi-
cantly outperforms a flat RL agent and rule-based
agents. The hierarchical structure of the agent also
improves the coherence of the dialogue flow.

The promising results suggest several directions
for future research. First, the hierarchical RL
approach demonstrates strong adaptation ability
to tailor the dialogue policy to different types of
users. This motivates us to systematically inves-
tigate its use for dialogue personalization. Sec-
ond, our hierarchical RL agent is implemented us-
ing a two-level dialogue policy. But more com-
plex tasks might require multiple levels of hierar-
chy. Thus, it is valuable to extend our approach to
handle such deep hierarchies, where a subtask can
invoke another subtask and so on, taking full ad-
vantage of the options framework. Finally, design-
ing task hierarchies requires substantial domain
knowledge and is time-consuming. This challenge
calls for future work on automatic learning of hi-
erarchies for complex dialogue tasks.

Acknowledgments

Baolin Peng was in part supported by General Re-
search Fund of Hong Kong (14232816). We would
like thank anonymous reviewers for their insight-
ful comments.

References
Layla El Asri, Jing He, and Kaheer Suleman. 2016.

A sequence-to-sequence model for user simulation
in spoken dialogue systems. In Interspeech 2016,
pages 1151â€“1155. ISCA.

Andrew G. Barto and Sridhar Mahadevan. 2003. Re-
cent advances in hierarchical reinforcement learn-
ing. Discrete Event Dynamic Systems, 13(1-2):41â€“
77.

Heriberto CuayaÌhuitl. 2009. Hierarchical reinforce-
ment learning for spoken dialogue systems.

Heriberto CuayaÌhuitl. 2017. SimpleDS: A simple deep
reinforcement learning dialogue system. In Dia-
logues with Social Robots, pages 109â€“118. Springer.

Heriberto CuayaÌhuitl, Seunghak Yu, Ashley
Williamson, and Jacob Carse. 2016. Deep re-
inforcement learning for multi-domain dialogue
systems. arXiv preprint arXiv:1611.08675.

Bhuwan Dhingra, Lihong Li, Xiujun Li, Jianfeng
Gao, Yun-Nung Chen, Faisal Ahmed, and Li Deng.
2017. End-to-end reinforcement learning of dia-
logue agents for information access. In Proceedings
of the 55th Annual Meeting of the Association for
Computational Linguistics (ACL).

Thomas G. Dietterich. 2000. Hierarchical reinforce-
ment learning with the MAXQ value function de-
composition. Journal of Artificial Intelligence Re-
search, 13:227â€“303.

Layla El Asri, Hannes Schulz, Shikhar Sharma,
Jeremie Zumer, Justin Harris, Emery Fine, Rahul
Mehrotra, and Kaheer Suleman. 2017. Frames: A
corpus for adding memory to goal-oriented dialogue
systems. arXiv preprint arXiv:1704.00057.

Milica Gasic, Dongho Kim, Pirros Tsiakoulis, and
Steve J. Young. 2015a. Distributed dialogue poli-
cies for multi-domain statistical dialogue manage-
ment. In 2015 IEEE International Conference on
Acoustics, Speech and Signal Processing, ICASSP
2015, South Brisbane, Queensland, Australia, April
19-24, 2015, pages 5371â€“5375. IEEE.

Milica Gasic, Nikola Mrksic, Pei-hao Su, David
Vandyke, Tsung-Hsien Wen, and Steve J. Young.
2015b. Policy committee for adaptation in multi-
domain spoken dialogue systems. In 2015 IEEE
Workshop on Automatic Speech Recognition and
Understanding, ASRU 2015, Scottsdale, AZ, USA,
December 13-17, 2015, pages 806â€“812. IEEE.

2239



Dilek Hakkani-TuÌˆr, Gokhan Tur, Asli Celikyilmaz,
Yun-Nung Chen, Jianfeng Gao, Li Deng, and Ye-
Yi Wang. 2016. Multi-domain joint semantic frame
parsing using bi-directional RNN-LSTM. In Pro-
ceedings of The 17th Annual Meeting of the Interna-
tional Speech Communication Association.

Tejas D. Kulkarni, Karthik Narasimhan, Ardavan
Saeedi, and Josh Tenenbaum. 2016. Hierarchical
deep reinforcement learning: Integrating temporal
abstraction and intrinsic motivation. In Advances in
Neural Information Processing Systems 29: Annual
Conference on Neural Information Processing Sys-
tems 2016, December 5-10, 2016, Barcelona, Spain,
pages 3675â€“3683.

Esther Levin, Roberto Pieraccini, and Wieland Eckert.
2000. A stochastic model of human-machine inter-
action for learning dialog strategies. IEEE Trans.
Speech and Audio Processing, 8(1):11â€“23.

Xiujun Li, Yun-Nung Chen, Lihong Li, and Jianfeng
Gao. 2017a. End-to-end task-completion neural di-
alogue systems. arXiv preprint arXiv:1703.01008.

Xiujun Li, Yun-Nung Chen, Lihong Li, Jianfeng Gao,
and Asli Celikyilmaz. 2017b. Investigation of
language understanding impact for reinforcement
learning based dialogue systems. arXiv preprint
arXiv:1703.07055.

Xiujun Li, Zachary C Lipton, Bhuwan Dhingra, Lihong
Li, Jianfeng Gao, and Yun-Nung Chen. 2016. A
user simulator for task-completion dialogues. arXiv
preprint arXiv:1612.05688.

Pierre Lison. 2011. Multi-policy dialogue manage-
ment. In Proceedings of the SIGDIAL 2011, pages
294â€“300. The Association for Computer Linguis-
tics.

Volodymyr Mnih, Koray Kavukcuoglu, David Silver,
Andrei A. Rusu, Joel Veness, Marc G. Bellemare,
Alex Graves, Martin A. Riedmiller, Andreas Fidje-
land, Georg Ostrovski, Stig Petersen, Charles Beat-
tie, Amir Sadik, Ioannis Antonoglou, Helen King,
Dharshan Kumaran, Daan Wierstra, Shane Legg,
and Demis Hassabis. 2015. Human-level con-
trol through deep reinforcement learning. Nature,
518(7540):529â€“533.

Ronald Parr and Stuart J. Russell. 1997. Reinforce-
ment learning with hierarchies of machines. In
Advances in Neural Information Processing Sys-
tems 10, [NIPS Conference, Denver, Colorado, USA,
1997], pages 1043â€“1049. The MIT Press.

Jost Schatzmann, Blaise Thomson, Karl Weilhammer,
Hui Ye, and Steve J. Young. 2007. Agenda-based
user simulation for bootstrapping a POMDP dia-
logue system. In Human Language Technology
Conference of the North American Chapter of the
Association of Computational Linguistics, Proceed-
ings, April 22-27, 2007, Rochester, New York, USA,
pages 149â€“152. The Association for Computational
Linguistics.

Jost Schatzmann and Steve Young. 2009. The hid-
den agenda user simulation model. IEEE Transac-
tions on Audio, Speech, and Language Processing,
17(4):733â€“747.

Konrad Scheffler and Steve J. Young. 2000. Prob-
abilistic simulation of human-machine dialogues.
In IEEE International Conference on Acoustics,
Speech, and Signal Processing. ICASSP 2000, 5-9
June, 2000, Hilton Hotel and Convention Center, Is-
tanbul, Turkey, pages 1217â€“1220. IEEE.

Satinder P. Singh. 1992. Reinforcement learning with a
hierarchy of abstract models. In Proceedings of the
10th National Conference on Artificial Intelligence.
San Jose, CA, July 12-16, 1992., pages 202â€“207.
AAAI Press / The MIT Press.

Pei-Hao Su, Milica Gasic, Nikola Mrksic, Lina Rojas-
Barahona, Stefan Ultes, David Vandyke, Tsung-
Hsien Wen, and Steve Young. 2016. Continu-
ously learning neural dialogue management. arXiv
preprint arXiv:1606.02689.

Richard S. Sutton, Doina Precup, and Satinder P. Singh.
1998. Intra-option learning about temporally ab-
stract actions. In Proceedings of the Fifteenth Inter-
national Conference on Machine Learning (ICML
1998), Madison, Wisconsin, USA, July 24-27, 1998,
pages 556â€“564.

Richard S. Sutton, Doina Precup, and Satinder P.
Singh. 1999. Between MDPs and Semi-MDPs: A
framework for temporal abstraction in reinforcement
learning. Artificial Intelligence, 112(1-2):181â€“211.

Tsung-Hsien Wen, Milica Gasic, Nikola Mrksic, Pei-
hao Su, David Vandyke, and Steve J. Young. 2015.
Semantically conditioned LSTM-based natural lan-
guage generation for spoken dialogue systems. In
Proceedings of the 2015 Conference on Empirical
Methods in Natural Language Processing, EMNLP
2015, Lisbon, Portugal, September 17-21, 2015,
pages 1711â€“1721.

Jason D Williams, Kavosh Asadi, and Geoffrey Zweig.
2017. Hybrid code networks: Practical and efficient
end-to-end dialog control with supervised and rein-
forcement learning. In Proceedings of the 55th An-
nual Meeting of the Association for Computational
Linguistics (ACL).

Kaisheng Yao, Baolin Peng, Yu Zhang, Dong Yu, Ge-
offrey Zweig, and Yangyang Shi. 2014. Spoken lan-
guage understanding using long short-term memory
neural networks. In 2014 IEEE Spoken Language
Technology Workshop, SLT 2014, South Lake Tahoe,
NV, USA, December 7-10, 2014, pages 189â€“194.

Steve J. Young, Milica Gasic, Blaise Thomson, and Ja-
son D. Williams. 2013. POMDP-based statistical
spoken dialog systems: A review. Proceedings of
the IEEE, 101(5):1160â€“1179.

2240


