










































SystemT: An Algebraic Approach to Declarative Information Extraction


Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 128–137,
Uppsala, Sweden, 11-16 July 2010. c©2010 Association for Computational Linguistics

SystemT: An Algebraic Approach to Declarative Information Extraction

Laura Chiticariu Rajasekar Krishnamurthy Yunyao Li

Sriram Raghavan Frederick R. Reiss Shivakumar Vaithyanathan

IBM Research – Almaden

San Jose, CA, USA

{chiti,sekar,yunyaoli,rsriram,frreiss,vaithyan}@us.ibm.com

Abstract

As information extraction (IE) becomes

more central to enterprise applications,

rule-based IE engines have become in-

creasingly important. In this paper, we

describe SystemT, a rule-based IE sys-

tem whose basic design removes the ex-

pressivity and performance limitations of

current systems based on cascading gram-

mars. SystemT uses a declarative rule

language, AQL, and an optimizer that

generates high-performance algebraic ex-

ecution plans for AQL rules. We com-

pare SystemT’s approach against cascad-

ing grammars, both theoretically and with

a thorough experimental evaluation. Our

results show that SystemT can deliver re-

sult quality comparable to the state-of-the-

art and an order of magnitude higher an-

notation throughput.

1 Introduction

In recent years, enterprises have seen the emer-

gence of important text analytics applications like

compliance and data redaction. This increase,

combined with the inclusion of text into traditional

applications like Business Intelligence, has dra-

matically increased the use of information extrac-

tion (IE) within the enterprise. While the tradi-

tional requirement of extraction quality remains

critical, enterprise applications also demand ef-

ficiency, transparency, customizability and main-

tainability. In recent years, these systemic require-

ments have led to renewed interest in rule-based

IE systems (Doan et al., 2008; SAP, 2010; IBM,

2010; SAS, 2010).

Until recently, rule-based IE systems (Cunning-

ham et al., 2000; Boguraev, 2003; Drozdzynski

et al., 2004) were predominantly based on the

cascading grammar formalism exemplified by the

Common Pattern Specification Language (CPSL)

specification (Appelt and Onyshkevych, 1998). In

CPSL, the input text is viewed as a sequence of an-

notations, and extraction rules are written as pat-

tern/action rules over the lexical features of these

annotations. In a single phase of the grammar, a

set of rules are evaluated in a left-to-right fash-

ion over the input annotations. Multiple grammar

phases are cascaded together, with the evaluation

proceeding in a bottom-up fashion.

As demonstrated by prior work (Grishman and

Sundheim, 1996), grammar-based IE systems can

be effective in many scenarios. However, these

systems suffer from two severe drawbacks. First,

the expressivity of CPSL falls short when used

for complex IE tasks over increasingly pervasive

informal text (emails, blogs, discussion forums

etc.). To address this limitation, grammar-based

IE systems resort to significant amounts of user-

defined code in the rules, combined with pre-

and post-processing stages beyond the scope of

CPSL (Cunningham et al., 2010). Second, the

rigid evaluation order imposed in these systems

has significant performance implications.

Three decades ago, the database community

faced similar expressivity and efficiency chal-

lenges in accessing structured information. The

community addressed these problems by introduc-

ing a relational algebra formalism and an associ-

ated declarative query language SQL. The ground-

breaking work on System R (Chamberlin et al.,

1981) demonstrated how the expressivity of SQL

can be efficiently realized in practice by means of

a query optimizer that translates an SQL query into

an optimized query execution plan.

Borrowing ideas from the database community,

we have developed SystemT, a declarative IE sys-

tem based on an algebraic framework, to address

both expressivity and performance issues. In Sys-

temT, extraction rules are expressed in a declar-

ative language called AQL. At compilation time,

128



({First} {Last} ) :full �:full.Person

({Caps}  {Last} ) :full �:full.Person

({Last} {Token.orth = comma} {Caps | First}) : reverse
�:reverse.Person

({First}) : fn � :fn.Person

({Last}) : ln � :ln.Person

({Lookup.majorType = FirstGaz})  : fn � :fn.First

({Lookup.majorType = LastGaz}) : ln � :ln.Last

({Token.orth = upperInitial} | 
{Token.orth = mixedCaps } ) :cw � :cw.Caps

Rule Patterns

50

20

10

10

10

50

50

10

Priority

P2R1

P2R2

P2R3

P2R4

P2R5

P1R1

P1R2

P1R3

RuleId

Input

First

Last

Caps

Token

Output

Person

Input

Lookup

Token

Output

First

Last

Caps

TypesPhase

P2

P1

P2R3        ({Last} {Token.orth = comma} {Caps | First}) : reverse  � :reverse.Person

Last followed by Token whose orth attribute has value 

comma followed by Caps or First

Rule part Action part

Create Person

annotation

Bind match 

to variables

Syntax:

Gazetteers containing first names and last names

Figure 1: Cascading grammar for identifying Person names

SystemT translates AQL statements into an al-

gebraic expression called an operator graph that

implements the semantics of the statements. The

SystemT optimizer then picks a fast execution

plan from many logically equivalent plans. Sys-

temT is currently deployed in a multitude of real-

world applications and commercial products1.

We formally demonstrate the superiority of

AQL and SystemT in terms of both expressivity

and efficiency (Section 4). Specifically, we show

that 1) the expressivity of AQL is a strict superset

of CPSL grammars not using external functions

and 2) the search space explored by the SystemT

optimizer includes operator graphs correspond-

ing to efficient finite state transducer implemen-

tations. Finally, we present an extensive experi-

mental evaluation that validates that high-quality

annotators can be developed with SystemT, and

that their runtime performance is an order of mag-

nitude better when compared to annotators devel-

oped with a state-of-the-art grammar-based IE sys-

tem (Section 5).

2 Grammar-based Systems and CPSL

A cascading grammar consists of a sequence of

phases, each of which consists of one or more

rules. Each phase applies its rules from left to

right over an input sequence of annotations and

generates an output sequence of annotations that

the next phase consumes. Most cascading gram-

mar systems today adhere to the CPSL standard.

Fig. 1 shows a sample CPSL grammar that iden-

tifies person names from text in two phases. The

first phase, P1, operates over the results of the tok-

1A trial version is available at
http://www.alphaworks.ibm.com/tech/systemt

Rule skipped 

due to priority 

semantics
CPSL
Phase P1

Last(P1R2) Last(P1R2)

… Mark        Scott     ,            Howard         Smith   …

First(P1R1) First(P1R1) First(P1R1) Last(P1R2)

CPSL
Phase P2

… Mark        Scott     ,        Howard          Smith    …

Person(P2R1)

Person (P2R4)

Person(P2R4)

Person (P2R5)

Person(P2R4)

… Mark        Scott     ,            Howard         Smith   …

First(P1R1) First(P1R1) First(P1R1) Last(P1R2)
JAPE

Phase P1
(Brill) Caps(P1R3) Last(P1R2) Last(P1R2)

Caps(P1R3) Caps(P1R3)

Caps(P1R3)

… Mark        Scott     ,        Howard          Smith    …

Person(P2R1)

Person (P2R4, P2R5)
JAPE
Phase P2
(Appelt)

Person(P2R1)

Person (P2R2)
Some discarded 

matches omitted

for clarity

… Tomorrow, we will meet Mark Scott, Howard Smith and …Document d1

Rule fired

Legend

3 persons

identified

2 persons

identified

(a)

(b)

Figure 2: Sample output of CPSL and JAPE

enizer and gazetteer (input types Token and Lookup,

respectively) to identify words that may be part of

a person name. The second phase, P2, identifies

complete names using the results of phase P1.

Applying the above grammar to document d1
(Fig. 2), one would expect that to match “Mark

Scott” and “Howard Smith” as Person. However,

as shown in Fig. 2(a), the grammar actually finds

three Person annotations, instead of two. CPSL has

several limitations that lead to such discrepancies:

L1. Lossy sequencing. In a CPSL grammar,

each phase operates on a sequence of annotations

from left to right. If the input annotations to a

phase may overlap with each other, the CPSL en-

gine must drop some of them to create a non-

overlapping sequence. For instance, in phase P1
(Fig. 2(a)), “Scott” has both a Lookup and a To-

ken annotation. The system has made an arbitrary

choice to retain the Lookup annotation and discard

the Token annotation. Consequently, no Caps anno-

tations are output by phase P1.

L2. Rigid matching priority. CPSL specifies

that, for each input annotation, only one rule can

actually match. When multiple rules match at the

same start position, the following tie-breaker con-

ditions are applied (in order): (a) the rule match-

ing the most annotations in the input stream; (b)

the rule with highest priority; and (c) the rule de-

clared earlier in the grammar. This rigid match-

ing priority can lead to mistakes. For instance,

as illustrated in Fig. 2(a), phase P1 only identi-

fies “Scott” as a First. Matching priority causes

the grammar to skip the corresponding match for

“Scott” as a Last. Consequently, phase P2 fails to

identify “Mark Scott” as one single Person.

L3. Limited expressivity in rule patterns. It is

not possible to express rules that compare annota-

tions overlapping with each other. E.g., “Identify

129



[A-Z]{\w|-}+

DocumentInput Tuple

…

we will meet Mark 

Scott, …

Output Tuple 2 Span 2Document

Span 1Output Tuple 1 Document

Regex

Caps

Figure 3: Regular Expression Extraction Operator

words that are both capitalized and present in the

FirstGaz gazetteer” or “Identify Person annotations

that occur within an EmailAddress”.

Extensions to CPSL

In order to address the above limitations, several

extensions to CPSL have been proposed in JAPE,

AFst and XTDL (Cunningham et al., 2000; Bogu-

raev, 2003; Drozdzynski et al., 2004). The exten-

sions are summarized as below, where each solu-

tion Si corresponds to limitation Li.

• S1. Grammar rules are allowed to operate on
graphs of input annotations in JAPE and AFst.

• S2. JAPE introduces more matching regimes
besides the CPSL’s matching priority and thus

allows more flexibility when multiple rules

match at the same starting position.

• S3. The rule part of a pattern has been ex-
panded to allow more expressivity in JAPE,

AFst and XTDL.

Fig. 2(b) illustrates how the above extensions

help in identifying the correct matches ‘Mark Scott’

and ‘Howard Smith’ in JAPE. Phase P1 uses a match-

ing regime (denoted by Brill) that allows multiple

rules to match at the same starting position, and

phase P2 uses CPSL’s matching priority, Appelt.

3 SystemT

SystemT is a declarative IE system based on an

algebraic framework. In SystemT, developers

write rules in a language called AQL. The system

then generates a graph of operators that imple-

ment the semantics of the AQL rules. This decou-

pling allows for greater rule expressivity, because

the rule language is not constrained by the need to

compile to a finite state transducer. Likewise, the

decoupled approach leads to greater flexibility in

choosing an efficient execution strategy, because

many possible operator graphs may exist for the

same AQL annotator.

In the rest of the section, we describe the parts

of SystemT, starting with the algebraic formalism

behind SystemT’s operators.

3.1 Algebraic Foundation of SystemT

SystemT executes IE rules using graphs of op-

erators. The formal definition of these operators

takes the form of an algebra that is similar to the

relational algebra, but with extensions for text pro-

cessing.

The algebra operates over a simple relational

data model with three data types: span, tuple, and

relation. In this data model, a span is a region of

text within a document identified by its “begin”

and “end” positions; a tuple is a fixed-size list of

spans. A relation is a multiset of tuples, where ev-

ery tuple in the relation must be of the same size.

Each operator in our algebra implements a single

basic atomic IE operation, producing and consum-

ing sets of tuples.

Fig. 3 illustrates the regular expression ex-

traction operator in the algebra, which per-

forms character-level regular expression match-

ing. Overall, the algebra contains 12 different op-

erators, a full description of which can be found

in (Reiss et al., 2008). The following four oper-

ators are necessary to understand the examples in

this paper:

• The Extract operator (E) performs character-
level operations such as regular expression and

dictionary matching over text, creating a tuple

for each match.

• The Select operator (σ) takes as input a set of
tuples and a predicate to apply to the tuples. It

outputs all tuples that satisfy the predicate.

• The Join operator (⊲⊳) takes as input two sets
of tuples and a predicate to apply to pairs of

tuples from the input sets. It outputs all pairs

of input tuples that satisfy the predicate.

• The consolidate operator (Ω) takes as input a
set of tuples and the index of a particular col-

umn in those tuples. It removes selected over-

lapping spans from the indicated column, ac-

cording to the specified policy.

3.2 AQL

Extraction rules in SystemT are written in AQL,

a declarative relational language similar in syn-

tax to the database language SQL. We chose SQL

as a basis for our language due to its expres-

sivity and its familiarity. The expressivity of

SQL, which consists of first-order logic predicates

130



Figure 4: Person annotator as AQL query

over sets of tuples, is well-documented and well-

understood (Codd, 1990). As SQL is the pri-

mary interface to most relational database sys-

tems, the language’s syntax and semantics are

common knowledge among enterprise application

programmers. Similar to SQL terminology, we

call a collection of AQL rules an AQL query.

Fig. 4 shows portions of an AQL query. As

can be seen, the basic building block of AQL is

a view: A logical description of a set of tuples in

terms of either the document text (denoted by a

special view called Document) or the contents of

other views. Every SystemT annotator consists

of at least one view. The output view statement in-

dicates that the tuples in a view are part of the final

results of the annotator.

Fig. 4 also illustrates three of the basic con-

structs that can be used to define a view.

• The extract statement specifies basic
character-level extraction primitives to be

applied directly to a tuple.

• The select statement is similar to the SQL
select statement but it contains an additional

consolidate on clause, along with an exten-

sive collection of text-specific predicates.

• The union all statement merges the outputs
of one or more select or extract statements.

To keep rules compact, AQL also provides a

shorthand sequence pattern notation similar to the

syntax of CPSL. For example, the CapsLast

view in Figure 4 could have been written as:

create view CapsLast as

extract pattern <C.name> <L.name>

from Caps C, Last L;

Internally, SystemT translates each of these ex-

tract pattern statements into one or more select

and extract statements.

AQL SystemT

Optimizer

SystemT

Runtime

Compiled
Operator

Graph

Figure 5: The compilation process in SystemT

Figure 6: Execution strategies for the CapsLast rule

in Fig. 4

SystemT has built-in multilingual support in-

cluding tokenization, part of speech and gazetteer

matching for over 20 languages using Language-

Ware (IBM, 2010). Rule developers can utilize

the multilingual support via AQL without hav-

ing to configure or manage any additional re-

sources. In addition, AQL allows user-defined

functions to be used in a restricted context in or-

der to support operations such as validation (e.g.

for extracted credit card numbers), or normaliza-

tion (e.g., compute abbreviations of multi-token

organization candidates that are useful in gener-

ating additional candidates). More details on AQL

can be found in the AQL manual (SystemT, 2010).

3.3 Optimizer and Operator Graph

Grammar-based IE engines place rigid restrictions

on the order in which rules can be executed. Due

to the semantics of the CPSL standard, systems

that implement the standard must use a finite state

transducer that evaluates each level of the cascade

with one or more left to right passes over the entire

token stream.

In contrast, SystemT places no explicit con-

straints on the order of rule evaluation, nor does

it require that intermediate results of an annota-

tor collapse to a fixed-size sequence. As shown in

Fig. 5, the SystemT engine does not execute AQL

directly; instead, the SystemT optimizer compiles

AQL into a graph of operators. By tying a collec-

tion of operators together by their inputs and out-

puts, the system can implement a wide variety of

different execution strategies. Different execution

strategies are associated with different evaluation

costs. The optimizer chooses the execution strat-

egy with the lowest estimated evaluation cost.

131



Fig. 6 presents three possible execution strate-

gies for the CapsLast rule in Fig. 4. If the opti-

mizer estimates that the evaluation cost of Last is

much lower than that of Caps, then it can deter-

mine that Plan C has the lowest evaluation cost

among the three, because Plan C only evaluates

Caps in the “left” neighborhood for each instance

of Last. More details of our algorithms for enumer-

ating plans can be found in (Reiss et al., 2008).

The optimizer in SystemT chooses the best ex-

ecution plan from a large number of different al-

gebra graphs available to it. Many of these graphs

implement strategies that a transducer could not

express: such as evaluating rules from right to left,

sharing work across different rules, or selectively

skipping rule evaluations. Within this large search

space, there generally exists an execution strategy

that implements the rule semantics far more effi-

ciently than the fastest transducer could. We refer

the reader to (Reiss et al., 2008) for a detailed de-

scription of the types of plan the optimizer consid-

ers, as well as an experimental analysis of the per-

formance benefits of different parts of this search

space.

Several parallel efforts have been made recently

to improve the efficiency of IE tasks by optimiz-

ing low-level feature extraction (Ramakrishnan et

al., 2006; Ramakrishnan et al., 2008; Chandel et

al., 2006) or by reordering operations at a macro-

scopic level (Ipeirotis et al., 2006; Shen et al.,

2007; Jain et al., 2009). However, to the best of

our knowledge, SystemT is the only IE system

in which the optimizer generates a full end-to-end

plan, beginning with low-level extraction primi-

tives and ending with the final output tuples.

3.4 Deployment Scenarios

SystemT is designed to be usable in various de-

ployment scenarios. It can be used as a stand-

alone system with its own development and run-

time environment. Furthermore, SystemT ex-

poses a generic Java API that enables the integra-

tion of its runtime environment with other applica-

tions. For example, a specific instantiation of this

API allows SystemT annotators to be seamlessly

embedded in applications using the UIMA analyt-

ics framework (UIMA, 2010).

4 Grammar vs. Algebra

Having described both the traditional cascading

grammar approach and the declarative approach

Figure 7: Supporting Complex Rule Interactions

used in SystemT, we now compare the two in

terms of expressivity and performance.

4.1 Expressivity

In Section 2, we described three expressivity lim-

itations of CPSL grammars: Lossy sequencing,

rigid matching priority, and limited expressivity in

rule patterns. As we noted, cascading grammar

systems extend the CPSL specification in various

ways to provide workarounds for these limitations.

In SystemT, the basic design of the AQL lan-

guage eliminates these three problems without the

need for any special workaround. The key design

difference is that AQL views operate over sets of

tuples, not sequences of tokens. The input or out-

put tuples of a view can contain spans that overlap

in arbitrary ways, so the lossy sequencing prob-

lem never occurs. The annotator will retain these

overlapping spans across any number of views un-

til a view definition explicitly removes the over-

lap. Likewise, the tuples that a given view pro-

duces are in no way constrained by the outputs of

other, unrelated views, so the rigid matching prior-

ity problem never occurs. Finally, the select state-

ment in AQL allows arbitrary predicates over the

cross-product of its input tuple sets, eliminating

the limited expressivity in rule patterns problem.

Beyond eliminating the major limitations of

CPSL grammars, AQL provides a number of other

information extraction operations that even ex-

tended CPSL cannot express without custom code.

Complex rule interactions. Consider an exam-

ple document from the Enron corpus (Minkov et

al., 2005), shown in Fig. 7, which contains a list

of person names. Because the first person in the

list (‘Skilling’) is referred to by only a last name,

rule P2R3 in Fig. 1 incorrectly identifies ‘Skilling,

Cindy’ as a person. Consequently, the output of

phase P2 of the cascading grammar contains sev-

eral mistakes as shown in the figure. This problem

132



went to the Switchfoot concert at the Roxy. It was pretty fun,… The lead singer/guitarist 

was really good, and even though there was another guitarist  (an Asian guy), he ended up 

playing most of the guitar parts, which was really impressive. The biggest surprise though is 

that I actually liked the opening bands. …I especially liked the first band

Consecutive review snippets are within 25 tokens

At least 4 occurrences of MusicReviewSnippet or GenericReviewSnippet

At least 3 of them should be MusicReviewSnippets

Review ends with one of these.

Start with 
ConcertMention

Complete review is

within 200 tokens

ConcertMention

MusicReviewSnippet

GenericReviewSnippet

Example Rule

Informal Band Review

Figure 8: Extracting informal band reviews from web logs

occurs because CPSL only evaluates rules over

the input sequence in a strict left-to-right fashion.

On the other hand, the AQL query Q1 shown in

the figure applies the following condition: “Al-

ways discard matches to Rule P2R3 if they overlap

with matches to rules P2R1 or P2R2” (even if the

match to Rule P2R3 starts earlier). Applying this

rule ensures that the person names in the list are

identified correctly. Obtaining the same effect in

grammar-based systems would require the use of

custom code (as recommended by (Cunningham

et al., 2010)).

Counting and Aggregation. Complex extraction

tasks sometimes require operations such as count-

ing and aggregation that go beyond the expressiv-

ity of regular languages, and thus can be expressed

in CPSL only using external functions. One such

task is that of identifying informal concert reviews

embedded within blog entries. Fig. 8 describes, by

example, how these reviews consist of reference

to a live concert followed by several review snip-

pets, some specific to musical performances and

others that are more general review expressions.

An example rule to identify informal reviews is

also shown in the figure. Notice how implement-

ing this rule requires counting the number of Mu-

sicReviewSnippet and GenericReviewSnippet annotations

within a region of text and aggregating this occur-

rence count across the two review types. While

this rule can be written in AQL, it can only be ap-

proximated in CPSL grammars.

Character-Level Regular Expression CPSL

cannot specify character-level regular expressions

that span multiple tokens. In contrast, the extract

regex statement in AQL fully supports these ex-

pressions.

We have described above several cases where

AQL can express concepts that can only be ex-

pressed through external functions in a cascad-

ing grammar. These examples naturally raise the

question of whether similar cases exist where a

cascading grammar can express patterns that can-

not be expressed in AQL.

It turns out that we can make a strong statement

that such examples do not exist. In the absence

of an escape to arbitrary procedural code, AQL is

strictly more expressive than a CPSL grammar. To

state this relationship formally, we first introduce

the following definitions.

We refer to a grammar conforming to the CPSL

specification as a CPSL grammar. When a CPSL

grammar contains no external functions, we refer

to it as a Code-free CPSL grammar. Finally, we

refer to a grammar that conforms to one of the

CPSL, JAPE, AFst and XTDL specifications as an

expanded CPSL grammar.

Ambiguous Grammar Specification An ex-

panded CPSL grammar may be under-specified in

some cases. For example, a single rule contain-

ing the disjunction operator (|) may match a given
region of text in multiple ways. Consider the eval-

uation of Rule P2R3 over the text fragment “Scott,

Howard” from document d1 (Fig. 1). If “Howard”

is identified both as Caps and First, then there are

two evaluations for Rule P2R3 over this text frag-

ment. Since the system has to arbitrarily choose

one evaluation, the results of the grammar can be

non-deterministic (as pointed out in (Cunning-

ham et al., 2010)). We refer to a grammar G as

an ambiguous grammar specification for a docu-

ment collection D if the system makes an arbitrary
choice while evaluating G over D.

Definition 1 (UnambigEquiv) A query Q is Un-

ambigEquiv to a cascading grammar G if and only
if for every document collection D, where G is not
an ambiguous grammar specification for D, the
results of the grammar invocation and the query

evaluation are identical.

We now formally compare the expressivity of

AQL and expanded CPSL grammars. The detailed

proof is omitted due to space limitations.

Theorem 1 The class of extraction tasks express-

ible as AQL queries is a strict superset of that ex-

pressible through expanded code-free CPSL gram-

mars. Specifically,

(a) Every expanded code-free CPSL grammar can

be expressed as an UnambigEquiv AQL query.

(b) AQL supports information extraction opera-

tions that cannot be expressed in expanded code-

free CPSL grammars.

133



Proof Outline: (a) A single CPSL grammar can

be expressed in AQL as follows. First, each rule

r in the grammar is translated into a set of AQL

statements. If r does not contain the disjunct (|)
operator, then it is translated into a single AQL

select statement. Otherwise, a set of AQL state-

ments are generated, one for each disjunct opera-

tor in rule r, and the results merged using union

all statements. Then, a union all statement is used

to combine the results of individual rules in the

grammar phase. Finally, the AQL statements for

multiple phases are combined in the same order as

the cascading grammar specification.

The main extensions to CPSL supported by ex-

panded CPSL grammars (listed in Sec. 2) are han-

dled as follows. AQL queries operate on graphs

on annotations just like expanded CPSL gram-

mars. In addition, AQL supports different match-

ing regimes through consolidation operators, span

predicates through selection predicates and co-

references through join operators.

(b) Example operations supported in AQL that

cannot be expressed in expanded code-free CPSL

grammars include (i) character-level regular ex-

pressions spanning multiple tokens, (ii) count-

ing the number of annotations occurring within a

given bounded window and (iii) deleting annota-

tions if they overlap with other annotations start-

ing later in the document. 2

4.2 Performance

For the annotators we test in our experiments

(See Section 5), the SystemT optimizer is able to

choose algebraic plans that are faster than a com-

parable transducer-based implementation. The

question arises as to whether there are other an-

notators for which the traditional transducer ap-

proach is superior. That is, for a given annota-

tor, might there exist a finite state transducer that

is combinatorially faster than any possible algebra

graph? It turns out that this scenario is not possi-

ble, as the theorem below shows.

Definition 2 (Token-Based FST) A token-based

finite state transducer (FST) is a nondeterministic

finite state machine in which state transitions are

triggered by predicates on tokens. A token-based

FST is acyclic if its state graph does not contain

any cycles and has exactly one “accept” state.

Definition 3 (Thompson’s Algorithm)

Thompson’s algorithm is a common strategy

for evaluating a token-based FST (based on

(Thompson, 1968)). This algorithm processes the

input tokens from left to right, keeping track of the

set of states that are currently active.

Theorem 2 For any acyclic token-based finite

state transducer T , there exists an UnambigEquiv

operator graph G, such that evaluating G has the

same computational complexity as evaluating T

with Thompson’s algorithm starting from each to-

ken position in the input document.

Proof Outline: The proof constructs G by struc-

tural induction over the transducer T . The base

case converts transitions out of the start state into

Extract operators. The inductive case adds a Se-

lect operator to G for each of the remaining state

transitions, with each selection predicate being the

same as the predicate that drives the corresponding

state transition. For each state transition predicate

that T would evaluate when processing a given

document, G performs a constant amount of work

on a single tuple. 2

5 Experimental Evaluation

In this section we present an extensive comparison

study between SystemT and implementations of

expanded CPSL grammar in terms of quality, run-

time performance and resource requirements.

TasksWe chose two tasks for our evaluation:

• NER : named-entity recognition for Person,
Organization, Location, Address, PhoneNumber,

EmailAddress, URL and DateTime.

• BandReview : identify informal reviews in
blogs (Fig. 8).

We chose NER primarily because named-entity

recognition is a well-studied problem and standard

datasets are available for evaluation. For this task

we use GATE and ANNIE for comparison3. We

chose BandReview to conduct performance evalu-

ation for a more complex extraction task.

Datasets. For quality evaluation, we use:

• EnronMeetings (Minkov et al., 2005): collec-
tion of emails with meeting information from

the Enron corpus4 with Person labeled data;

• ACE (NIST, 2005): collection of newswire re-
ports and broadcast news/conversations with

Person, Organization, Location labeled data5.

3To the best of our knowledge, ANNIE (Cunningham et
al., 2002) is the only publicly available NER library imple-
mented in a grammar-based system (JAPE in GATE).

4http://www.cs.cmu.edu/ enron/
5Only entities of type NAM have been considered.

134



Table 1: Datasets for performance evaluation.

Dataset Description of the Content Number of Document size

documents range average

Enronx Emails randomly sampled from the Enron corpus of average size xKB (0.5 < x < 100)
2 1000 xKB +/− 10% xKB

WebCrawl Small to medium size web pages representing company news, with HTML tags removed 1931 68b - 388.6KB 8.8KB

FinanceM Medium size financial regulatory filings 100 240KB - 0.9MB 401KB

FinanceL Large size financial regulatory filings 30 1MB - 3.4MB 1.54MB

Table 2: Quality of Person on test datasets.

Precision (%) Recall (%) F1 measure (%)

(Exact/Partial) (Exact/Partial) (Exact/Partial)

EnronMeetings

ANNIE 57.05/76.84 48.59/65.46 52.48/70.69

T-NE 88.41/92.99 82.39/86.65 85.29/89.71
Minkov 81.1/NA 74.9/NA 77.9/NA

ACE

ANNIE 39.41/78.15 30.39/60.27 34.32/68.06

T-NE 93.90/95.82 90.90/92.76 92.38/94.27

Table 1 lists the datasets used for performance

evaluation. The size of FinanceLis purposely

small because GATE takes a significant amount of

time processing large documents (see Sec. 5.2).

Set Up. The experiments were run on a server

with two 2.4 GHz 4-core Intel Xeon CPUs and

64GB of memory. We use GATE 5.1 (build 3431)

and two configurations for ANNIE: 1) the default

configuration, and 2) an optimized configuration

where the Ontotext Japec Transducer6 replaces the

default NE transducer for optimized performance.

We refer to these configurations as ANNIE and

ANNIE-Optimized, respectively.

5.1 Quality Evaluation

The goal of our quality evaluation is two-fold:

to validate that annotators can be built in Sys-

temT with quality comparable to those built in

a grammar-based system; and to ensure a fair

performance comparison between SystemT and

GATE by verifying that the annotators used in the

study are comparable.

Table 2 shows results of our comparison study

for Person annotators. We report the classical

(exact) precision, recall, and F1 measures that

credit only exact matches, and corresponding par-

tial measures that credit partial matches in a fash-

ion similar to (NIST, 2005). As can be seen, T-

NE produced results of significantly higher quality

than ANNIE on both datasets, for the same Person

extraction task. In fact, on EnronMeetings, the F1

measure of T-NE is 7.4% higher than the best pub-

lished result (Minkov et al., 2005). Similar results

6http://www.ontotext.com/gate/japec.html

a) Throughput on Enron

0

100

200

300

400

500

600

700

0 20 40 60 80 100

Average document size (KB)

T
h

ro
u

g
h

p
u

t 
(K

B
/s

e
c
)

ANNIE

ANNIE-Optimized

T-NE

x

b) Memory Utilization on Enron

0

200

400

600

0 20 40 60 80 100
Average document size (KB)

A
v
g

 H
e
a
p

 s
iz

e
 (

M
B

) ANNIE

ANNIE-Optimized

T-NE

Error bars show

25th and 75th

percentile 

x

Figure 9: Throughput (a) and memory consump-

tion (b) comparisons on Enronx datasets.

can be observed for Organization and Location on

ACE (exact numbers omitted in interest of space).

Clearly, considering the large gap between

ANNIE’s F1 and partial F1 measures on both

datasets, ANNIE’s quality can be improved via

dataset-specific tuning as demonstrated in (May-

nard et al., 2003). However, dataset-specific tun-

ing for ANNIE is beyond the scope of this paper.

Based on the experimental results above and our

previous formal comparison in Sec. 4, we believe

it is reasonable to conclude that annotators can be

built in SystemT of quality at least comparable to

those built in a grammar-based system.

5.2 Performance Evaluation

We now focus our attention on the throughput and

memory behavior of SystemT, and draw a com-

parison with GATE. For this purpose, we have con-

figured both ANNIE and T-NE to identify only the

same eight types of entities listed for NER task.

Throughput. Fig. 9(a) plots the throughput of

the two systems on multiple Enronx datasets with

average document sizes of between 0.5KB and

100KB. For this experiment, both systems ran

with a maximum Java heap size of 1GB.

135



Table 3: Throughput and mean heap size.

ANNIE ANNIE-Optimized T-NE
Dataset ThroughputMemoryThroughput Memory ThroughputMemory

(KB/s) (MB) (KB/s) (MB) (KB/s) (MB)

WebCrawl 23.9 212.6 42.8 201.8 498.9 77.2

FinanceM 18.82 715.1 26.3 601.8 703.5 143.7

FinanceL 19.2 2586.2 21.1 2683.5 954.5 189.6

As shown in Fig. 9(a), even though the through-

put of ANNIE-Optimized (using the optimized trans-

ducer) increases two-fold compared to ANNIE un-

der default configuration, T-NE is between 8 and

24 times faster compared to ANNIE-Optimized. For

both systems, throughput varied with document

size. For T-NE, the relatively low throughput on

very small document sizes (less than 1KB) is due

to fixed overhead in setting up operators to pro-

cess a document. As document size increases, the

overhead becomes less noticeable.

We have observed similar trends on the rest

of the test collections. Table 3 shows that T-

NE is at least an order of magnitude faster than

ANNIE-Optimized across all datasets. In partic-

ular, on FinanceL T-NE’s throughput remains

high, whereas the performance of both ANNIE and

ANNIE-Optimized degraded significantly.

To ascertain whether the difference in perfor-

mance in the two systems is due to low-level com-

ponents such as dictionary evaluation, we per-

formed detailed profiling of the systems. The pro-

filing revealed that 8.2%, 16.2% and respectively

14.2% of the execution time was spent on aver-

age on low-level components in the case of ANNIE,

ANNIE-Optimized and T-NE, respectively, thus lead-

ing us to conclude that the observed differences

are due to SystemT’s efficient use of resources at

a macroscopic level.

Memory utilization. In theory, grammar based

systems can stream tuples through each stage

for minimal memory consumption, whereas Sys-

temT operator graphs may need to materialize in-

termediate results for the full document at certain

points to evaluate the constraints in the original

AQL. The goal of this study is to evaluate whether

this potential problem does occur in practice.

In this experiment we ran both systems with a

maximum heap size of 2GB, and used the Java

garbage collector’s built-in telemetry to measure

the total quantity of live objects in the heap over

time while annotating the different test corpora.

Fig. 9(b) plots the minimum, maximum, and mean

heap sizes with the Enronx datasets. On small doc-

uments of size up to 15KB, memory consumption

is dominated by the fixed size of the data struc-

tures used (e.g., dictionaries, FST/operator graph),

and is comparable for both systems. As docu-

ments get larger, memory consumption increases

for both systems. However, the increase is much

smaller for T-NE compared to that for both AN-

NIE and ANNIE-Optimized. A similar trend can be

observed on the other datasets as shown in Ta-

ble 3. In particular, for FinanceL, both ANNIE and

ANNIE-Optimized required 8GB of Java heap size to

achieve reasonable throughput7 , in contrast to T-

NE which utilized at most 300MB out of the 2GB

of maximum Java heap size allocation.

SystemT requires much less memory than

GATE in general due to its runtime, which monitors

data dependencies between operators and clears

out low-level results when they are no longer

needed. Although a streaming CPSL implemen-

tation is theoretically possible, in practice mecha-

nisms that allow an escape to custom code make it

difficult to decide when an intermediate result will

no longer be used, hence GATE keeps most inter-

mediate data in memory until it is done analyzing

the current document.

The BandReviewTask. We conclude by briefly dis-

cussing our experience with the BandReview task

from Fig. 8. We built two versions of this anno-

tator, one in AQL, and the other using expanded

CPSL grammar. The grammar implementation

processed a 4.5GB collection of 1.05 million blogs

in 5.6 hours and output 280 reviews. In contrast,

the SystemT version (85 AQL statements) ex-

tracted 323 reviews in only 10 minutes!

6 Conclusion

In this paper, we described SystemT, a declar-

ative IE system based on an algebraic frame-

work. We presented both formal and empirical

arguments for the benefits of our approach to IE.

Our extensive experimental results show that high-

quality annotators can be built using SystemT,

with an order of magnitude throughput improve-

ment compared to state-of-the-art grammar-based

systems. Going forward, SystemT opens up sev-

eral new areas of research, including implement-

ing better optimization strategies and augmenting

the algebra with additional operators to support

advanced features such as coreference resolution.

7GATE ran out of memory when using less than 5GB of
Java heap size, and thrashed when run with 5GB to 7GB

136



References

Douglas E. Appelt and Boyan Onyshkevych. 1998.
The common pattern specification language. In TIP-
STER workshop.

Branimir Boguraev. 2003. Annotation-based finite
state processing in a large-scale nlp arhitecture. In
RANLP, pages 61–80.

D. D. Chamberlin, A. M. Gilbert, and Robert A. Yost.
1981. A history of System R and SQL/data system.
In vldb.

Amit Chandel, P. C. Nagesh, and Sunita Sarawagi.
2006. Efficient batch top-k search for dictionary-
based entity recognition. In ICDE.

E. F. Codd. 1990. The relational model for database
management: version 2. Addison-Wesley Longman
Publishing Co., Inc., Boston, MA, USA.

H. Cunningham, D. Maynard, and V. Tablan. 2000.
JAPE: a Java Annotation Patterns Engine (Sec-
ond Edition). Research Memorandum CS–00–10,
Department of Computer Science, University of
Sheffield, November.

H. Cunningham, D. Maynard, K. Bontcheva, and
V. Tablan. 2002. GATE: A framework and graphical
development environment for robust NLP tools and
applications. In Proceedings of the 40th Anniver-
sary Meeting of the Association for Computational
Linguistics, pages 168 – 175.

Hamish Cunningham, Diana Maynard, Kalina
Bontcheva, Valentin Tablan, Marin Dimitrov, Mike
Dowman, Niraj Aswani, Ian Roberts, Yaoyong
Li, and Adam Funk. 2010. Developing language
processing components with gate version 5 (a user
guide).

AnHai Doan, Luis Gravano, Raghu Ramakrishnan, and
Shivakumar Vaithyanathan. 2008. Special issue on
managing information extraction. SIGMOD Record,
37(4).

Witold Drozdzynski, Hans-Ulrich Krieger, Jakub
Piskorski, Ulrich Schäfer, and Feiyu Xu. 2004.
Shallow processing with unification and typed fea-
ture structures — foundations and applications.
Künstliche Intelligenz, 1:17–23.

Ralph Grishman and Beth Sundheim. 1996. Message
understanding conference - 6: A brief history. In
COLING, pages 466–471.

IBM. 2010. IBM LanguageWare.

P. G. Ipeirotis, E. Agichtein, P. Jain, and L. Gravano.
2006. To search or to crawl?: towards a query opti-
mizer for text-centric tasks. In SIGMOD.

Alpa Jain, Panagiotis G. Ipeirotis, AnHai Doan, and
Luis Gravano. 2009. Join optimization of informa-
tion extraction output: Quality matters! In ICDE.

Diana Maynard, Kalina Bontcheva, and Hamish Cun-
ningham. 2003. Towards a semantic extraction of
named entities. In Recent Advances in Natural Lan-
guage Processing.

Einat Minkov, Richard C. Wang, and William W. Co-
hen. 2005. Extracting personal names from emails:
Applying named entity recognition to informal text.
In HLT/EMNLP.

NIST. 2005. The ACE evaluation plan.

Ganesh Ramakrishnan, Sreeram Balakrishnan, and
Sachindra Joshi. 2006. Entity annotation based on
inverse index operations. In EMNLP.

Ganesh Ramakrishnan, Sachindra Joshi, Sanjeet Khai-
tan, and Sreeram Balakrishnan. 2008. Optimization
issues in inverted index-based entity annotation. In
InfoScale.

Frederick Reiss, Sriram Raghavan, Rajasekar Kr-
ishnamurthy, Huaiyu Zhu, and Shivakumar
Vaithyanathan. 2008. An algebraic approach to
rule-based information extraction. In ICDE, pages
933–942.

SAP. 2010. Inxight ThingFinder.

SAS. 2010. Text Mining with SAS Text Miner.

Warren Shen, AnHai Doan, Jeffrey F. Naughton, and
Raghu Ramakrishnan. 2007. Declarative informa-
tion extraction using datalog with embedded extrac-
tion predicates. In vldb.

SystemT. 2010. AQL Manual.
http://www.alphaworks.ibm.com/tech/systemt.

Ken Thompson. 1968. Regular expression search al-
gorithm. pages 419–422.

UIMA. 2010. Unstructured Information Management
Architecture.
http://uima.apache.org.

137


