



















































WordRank: Learning Word Embeddings via Robust Ranking


Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 658–668,
Austin, Texas, November 1-5, 2016. c©2016 Association for Computational Linguistics

WordRank: Learning Word Embeddings via Robust Ranking

Shihao Ji
Parallel Computing Lab, Intel
shihao.ji@intel.com

Hyokun Yun
Amazon

yunhyoku@amazon.com

Pinar Yanardag
Purdue University

ypinar@purdue.edu

Shin Matsushima
University of Tokyo

shin matsushima@mist.
i.u-tokyo.ac.jp

S. V. N. Vishwanathan
Univ. of California, Santa Cruz

vishy@ucsc.edu

Abstract

Embedding words in a vector space has gained
a lot of attention in recent years. While state-
of-the-art methods provide efficient computa-
tion of word similarities via a low-dimensional
matrix embedding, their motivation is often
left unclear. In this paper, we argue that word
embedding can be naturally viewed as a rank-
ing problem due to the ranking nature of the
evaluation metrics. Then, based on this in-
sight, we propose a novel framework Wor-
dRank that efficiently estimates word repre-
sentations via robust ranking, in which the
attention mechanism and robustness to noise
are readily achieved via the DCG-like rank-
ing losses. The performance of WordRank is
measured in word similarity and word anal-
ogy benchmarks, and the results are com-
pared to the state-of-the-art word embedding
techniques. Our algorithm is very competi-
tive to the state-of-the- arts on large corpora,
while outperforms them by a significant mar-
gin when the training set is limited (i.e., sparse
and noisy). With 17 million tokens, WordRank
performs almost as well as existing methods
using 7.2 billion tokens on a popular word
similarity benchmark. Our multi-node dis-
tributed implementation of WordRank is pub-
licly available for general usage.

1 Introduction

Embedding words into a vector space, such that se-
mantic and syntactic regularities between words are
preserved, is an important sub-task for many appli-
cations of natural language processing. Mikolov et
al. (2013a) generated considerable excitement in the

machine learning and natural language processing
communities by introducing a neural network based
model, which they call word2vec. It was shown that
word2vec produces state-of-the-art performance on
both word similarity as well as word analogy tasks.
The word similarity task is to retrieve words that
are similar to a given word. On the other hand,
word analogy requires answering queries of the form
a:b;c:?, where a, b, and c are words from the vocab-
ulary, and the answer to the query must be semanti-
cally related to c in the same way as b is related to
a. This is best illustrated with a concrete example:
Given the query king:queen;man:? we expect the
model to output woman.

The impressive performance of word2vec led to
a flurry of papers, which tried to explain and im-
prove the performance of word2vec both theoreti-
cally (Arora et al., 2015) and empirically (Levy and
Goldberg, 2014). One interpretation of word2vec
is that it is approximately maximizing the positive
pointwise mutual information (PMI), and Levy and
Goldberg (2014) showed that directly optimizing
this gives good results. On the other hand, Penning-
ton et al. (2014) showed performance comparable to
word2vec by using a modified matrix factorization
model, which optimizes a log loss.

Somewhat surprisingly, Levy et al. (2015) showed
that much of the performance gains of these new
word embedding methods are due to certain hyper-
parameter optimizations and system-design choices.
In other words, if one sets up careful experiments,
then existing word embedding models more or less
perform comparably to each other. We conjecture
that this is because, at a high level, all these methods

658



are based on the following template: From a large
text corpus eliminate infrequent words, and compute
a |W| × |C| word-context co-occurrence count ma-
trix; a context is a word which appears less than d
distance away from a given word in the text, where
d is a tunable parameter. Let w ∈ W be a word
and c ∈ C be a context, and let Xw,c be the (poten-
tially normalized) co-occurrence count. One learns a
function f(w, c) which approximates a transformed
version ofXw,c. Different methods differ essentially
in the transformation function they use and the para-
metric form of f (Levy et al., 2015). For exam-
ple, GloVe (Pennington et al., 2014) uses f (w, c) =
〈uw,vc〉 where uw and vc are k dimensional vec-
tors, 〈·, ·〉 denotes the Euclidean dot product, and
one approximates f (w, c) ≈ logXw,c. On the other
hand, as Levy and Goldberg (2014) show, word2vec
can be seen as using the same f(w, c) as GloVe
but trying to approximate f (w, c) ≈ PMI(Xw,c) −
log n, where PMI(·) is the pairwise mutual informa-
tion (Cover and Thomas, 1991) and n is the number
of negative samples.

In this paper, we approach the word embedding
task from a different perspective by formulating
it as a ranking problem. That is, given a word
w, we aim to output an ordered list (c1, c2, · · · )
of context words from C such that words that co-
occur with w appear at the top of the list. If
rank(w, c) denotes the rank of c in the list, then typ-
ical ranking losses optimize the following objective:∑

(w,c)∈Ω ρ (rank(w, c)), where Ω ⊂ W × C is the
set of word-context pairs that co-occur in the corpus,
and ρ(·) is a ranking loss function that is monotoni-
cally increasing and concave (see Sec. 2 for a justi-
fication).

Casting word embedding as ranking has two dis-
tinctive advantages. First, our method is discrimina-
tive rather than generative; in other words, instead
of modeling (a transformation of) Xw,c directly, we
only aim to model the relative order of Xw,· val-
ues in each row. This formulation fits naturally to
popular word embedding tasks such as word simi-
larity/analogy since instead of the likelihood of each
word, we are interested in finding the most relevant
words in a given context1. Second, casting word

1Roughly speaking, this difference in viewpoint is analo-
gous to the difference between pointwise loss function vs list-

embedding as a ranking problem enables us to de-
sign models robust to noise (Yun et al., 2014) and
focusing more on differentiating top relevant words,
a kind of attention mechanism that has been proved
very useful in deep learning (Larochelle and Hin-
ton, 2010; Mnih et al., 2014; Bahdanau et al., 2015).
Both issues are very critical in the domain of word
embedding since (1) the co-occurrence matrix might
be noisy due to grammatical errors or unconven-
tional use of language, i.e., certain words might co-
occur purely by chance, a phenomenon more acute
in smaller document corpora collected from diverse
sources; and (2) it’s very challenging to sort out a
few most relevant words from a very large vocabu-
lary, thus some kind of attention mechanism that can
trade off the resolution on most relevant words with
the resolution on less relevant words is needed. We
will show in the experiments that our method can
mitigate some of these issues; with 17 million to-
kens our method performs almost as well as existing
methods using 7.2 billion tokens on a popular word
similarity benchmark.

2 Word Embedding via Ranking

2.1 Notation
We use w to denote a word and c to denote a con-
text. The set of all words, that is, the vocabulary
is denoted as W and the set of all context words is
denoted C. We will use Ω ⊂ W × C to denote the
set of all word-context pairs that were observed in
the data, Ωw to denote the set of contexts that co-
occured with a given word w, and similarly Ωc to
denote the words that co-occurred with a given con-
text c. The size of a set is denoted as |·|. The inner
product between vectors is denoted as 〈·, ·〉.

2.2 Ranking Model
Let uw denote the k-dimensional embedding of a
word w, and vc denote that of a context c. For
convenience, we collect embedding parameters for
words and contexts as U := {uw}w∈W , and V :=
{vc}c∈C .

We aim to capture the relevance of context c for
word w by the inner product between their embed-
ding vectors, 〈uw,vc〉; the more relevant a context
is, the larger we want their inner product to be.

wise loss function used in ranking (Lee and Lin, 2013).

659



We achieve this by learning a ranking model that is
parametrized by U and V. If we sort the set of con-
texts C for a given word w in terms of each context’s
inner product score with the word, the rank of a spe-
cific context c in this list can be written as (Usunier
et al., 2009):

rank (w, c) =
∑

c′∈C\{c}
I (〈uw,vc〉 − 〈uw,vc′〉 ≤ 0)

=
∑

c′∈C\{c}
I (〈uw,vc − vc′〉 ≤ 0) , (1)

where I(x ≤ 0) is a 0-1 loss function which is 1 if
x ≤ 0 and 0 otherwise. Since I(x ≤ 0) is a dis-
continuous function, we follow the popular strategy
in machine learning which replaces the 0-1 loss by
its convex upper bound `(·), where `(·) can be any
popular loss function for binary classification such
as the hinge loss `(x) = max (0, 1− x) or the lo-
gistic loss `(x) = log2 (1 + 2

−x) (Bartlett et al.,
2006). This enables us to construct the following
convex upper bound on the rank:

rank (w, c)≤rank (w, c)=
∑

c′∈C\{c}
`(〈uw,vc−vc′〉) (2)

It is certainly desirable that the ranking model po-
sitions relevant contexts at the top of the list; this
motivates us to write the objective function to mini-
mize as:

J (U,V):=
∑

w∈W

∑

c∈Ωw
rw,c ·ρ

(
rank (w, c)+β

α

)
(3)

where rw,c is the weight between word w and con-
text c quantifying the association between them, ρ(·)
is a monotonically increasing and concave ranking
loss function that measures goodness of a rank, and
α > 0, β > 0 are the hyperparameters of the model
whose role will be discussed later. Following Pen-
nington et al. (2014), we use

rw,c =

{
(Xw,c/xmax)

� if Xw,c < xmax
1 otherwise,

(4)

where we set xmax = 100 and � = 0.75 in our ex-
periments. That is, we assign larger weights (with a
saturation) to contexts that appear more often with
the word of interest, and vice-versa. For the ranking

loss function ρ(·), on the other hand, we consider
the class of monotonically increasing and concave
functions. While monotonicity is a natural require-
ment, we argue that concavity is also important so
that the derivative of ρ is always non-increasing; this
implies that the ranking loss to be the most sensitive
at the top of the list (where the rank is small) and
becomes less sensitive at the lower end of the list
(where the rank is high). Intuitively this is desir-
able, because we are interested in a small number of
relevant contexts which frequently co-occur with a
given word, and thus are willing to tolerate errors on
infrequent contexts2. Meanwhile, this insensitivity
at the bottom of the list makes the model robust to
noise in the data either due to grammatical errors or
unconventional use of language. Therefore, a sin-
gle ranking loss function ρ(·) serves two different
purposes at two ends of the curve (see the example
plots of ρ in Figure 1); while the left hand side of
the curve encourages “high resolution” on most rel-
evant words, the right hand side becomes less sen-
sitive (with “low resolution”) to infrequent and pos-
sibly noisy words3. As we will demonstrate in our
experiments, this is a fundamental attribute (in addi-
tion to the ranking nature) of our method that con-
tributes its superior performance as compared to the
state-of-the-arts when the training set is limited (i.e.,
sparse and noisy).

What are interesting loss functions that can be
used for ρ (·)? Here are four possible alternatives,
all of which have a natural interpretation (see the
plots of all four ρ functions in Figure 1(a) and the
related work in Sec. 3 for a discussion).

ρ0 (x) := x (identity) (5)

ρ1 (x) := log2 (1 + x) (logarithm) (6)

ρ2 (x) := 1−
1

log2(2 + x)
(negative DCG) (7)

ρ3 (x) :=
x1−t − 1

1− t (logt with t 6= 1) (8)

2This is similar to the attention mechanism found in human
visual system that is able to focus on a certain region of an im-
age with “high resolution” while perceiving the surrounding im-
age in “low resolution” (Larochelle and Hinton, 2010; Mnih et
al., 2014).

3Due to the linearity of ρ0(x)=x, this ranking loss doesn’t
have the benefit of attention mechanism and robustness to noise
since it treats all ranking errors uniformly.

660



0 0.5 1 1.5 2
−1

−0.5

0

0.5

1

1.5

2

x

ρ(
x)

 

 

ρ
0
(x)

ρ
1
(x)

ρ
2
(x)

ρ
3
(x) with t=1.5

0 20 40 60 80 100
0

1

2

3

4

5

6

7

x

ρ 1
((

x+
β)

/α
)

 

 

ρ
0

ρ
1
 with (α=1,   β=0)

ρ
1
 with (α=10, β=9)

ρ
1
 with (α=100,β=99)

Figure 1: (a) Visualizing different ranking loss functions ρ(x) as defined in Eqs. (5–8); the lower part of ρ3(x) is truncated in
order to visualize the other functions better. (b) Visualizing ρ1((x + β)/α) with different α and β; ρ0 is included to illustrate the

dramatic scale differences between ρ0 and ρ1.

We will explore the performance of each of these
variants in our experiments. For now, we turn our
attention to efficient stochastic optimization of the
objective function (3).

2.3 Stochastic Optimization
Plugging (2) into (3), and replacing

∑
w∈W

∑
c∈Ωw

by
∑

(w,c)∈Ω, the objective function becomes:

J (U,V) =
∑

(w,c)∈Ω
rw,c·

ρ

(∑
c′∈C\{c}` (〈uw,vc−vc′〉)+β

α

)
. (9)

This function contains summations over Ω and C,
both of which are expensive to compute for a large
corpus. Although stochastic gradient descent (SGD)
(Bottou and Bousquet, 2011) can be used to re-
place the summation over Ω by random sampling,
the summation over C cannot be avoided unless ρ(·)
is a linear function. To work around this problem,
we propose to optimize a linearized upper bound of
the objective function obtained through a first-order
Taylor approximation. Observe that due to the con-
cavity of ρ(·), we have

ρ(x) ≤ ρ
(
ξ−1
)

+ ρ′
(
ξ−1
)
·
(
x− ξ−1

)
(10)

for any x and ξ 6= 0. Moreover, the bound is tight
when ξ = x−1. This motivates us to introduce a
set of auxiliary parameters Ξ := {ξw,c}(w,c)∈Ω and
define the following upper bound of J (U,V):

J (U,V,Ξ) :=
∑

(w,c)∈Ω
rw,c ·

{
ρ(ξ−1wc ) + ρ

′(ξ−1wc ) ·

(
α−1β+α−1

∑

c′∈C\{c}
` (〈uw,vc−vc′〉)−ξ−1w,c

)}
. (11)

Note that J (U,V) ≤ J (U,V,Ξ) for any Ξ, due
to (10)4. Also, minimizing (11) yields the same U
and V as minimizing (9). To see this, suppose Û :=
{ûw}w∈W and V̂ := {v̂c}c∈C minimizes (9). Then,
by letting Ξ̂ :=

{
ξ̂w,c

}
(w,c)∈Ω

where

ξ̂w,c =
α∑

c′∈C\{c} ` (〈ûw, v̂c − v̂c′〉) + β
, (12)

we have J
(
Û, V̂, Ξ̂

)
= J

(
Û, V̂

)
. Therefore,

it suffices to optimize (11). However, unlike (9),
(11) admits an efficient SGD algorithm. To see this,
rewrite (11) as

J(U,V,Ξ)=
∑

(w,c,c′)

rw,c·
(
ρ(ξ−1w,c)+ρ

′(ξ−1w,c)·(α−1β−ξ−1w,c)
|C| − 1

+
1

α
ρ′(ξ−1w,c) · ` (〈uw,vc − vc′〉)

)
, (13)

where (w, c, c′) ∈ Ω × (C \ {c}). Then, it can be
seen that if we sample uniformly from (w, c) ∈ Ω
and c′ ∈ C \ {c}, then j(w, c, c′) :=

|Ω|·(|C|−1) · rw,c ·
(
ρ(ξ−1w,c)+ρ

′(ξ−1w,c)·(α−1β−ξ−1w,c)
|C| − 1

+
1

α
ρ′(ξ−1w,c)·` (〈uw,vc − vc′〉)

)
, (14)

which does not contain any expensive summa-
tions and is an unbiased estimator of (13), i.e.,
E [j(w, c, c′)] = J (U,V,Ξ). On the other hand,
one can optimize ξw,c exactly by using (12). Putting

4When ρ = ρ0, one can simply set the auxiliary variables
ξw,c=1 because ρ0 is already a linear function.

661



everything together yields a stochastic optimiza-
tion algorithm WordRank, which can be special-
ized to a variety of ranking loss functions ρ(·) with
weights rw,c (e.g., DCG (Discounted Cumulative
Gain) (Manning et al., 2008) is one of many pos-
sible instantiations). Algorithm 1 contains detailed
pseudo-code. It can be seen that the algorithm is di-
vided into two stages: a stage that updates (U,V)
and another that updates Ξ. Note that the time com-
plexity of the first stage is O(|Ω|) since the cost of
each update in Lines 8–10 is independent of the size
of the corpus. On the other hand, the time complex-
ity of updating Ξ in Line 15 is O(|Ω| |C|), which
can be expensive. To amortize this cost, we em-
ploy two tricks: we only update Ξ after a few it-
erations of U and V update, and we exploit the fact
that the most computationally expensive operation
in (12) involves a matrix and matrix multiplication
which can be calculated efficiently via the SGEMM
routine in BLAS (Dongarra et al., 1990).

Algorithm 1 WordRank algorithm.
1: η: step size
2: repeat
3: // Stage 1: Update U and V
4: repeat
5: Sample (w, c) uniformly from Ω
6: Sample c′ uniformly from C \ {c}
7: // following three updates

are executed simultaneously
8: uw ← uw − η · rw,c · ρ′(ξ−1w,c) ·

`′ (〈uw,vc−vc′〉) · (vc−vc′)
9: vc ← vc − η · rw,c · ρ′(ξ−1w,c) ·

`′ (〈uw,vc−vc′〉) · uw
10: vc′ ← vc′ + η · rw,c · ρ′(ξ−1w,c) ·

`′ (〈uw,vc−vc′〉) · uw
11: until U and V are converged
12: // Stage 2: Update Ξ
13: for w ∈ W do
14: for c ∈ C do
15: ξw,c=α/

(∑
c′∈C\{c} ` (〈uw,vc−vc′〉)+β

)

16: end for
17: end for
18: until U, V and Ξ are converged

2.4 Parallelization
The updates in Lines 8–10 have one remarkable
property: To update uw, vc and vc′ , we only need
to read the variables uw, vc, vc′ and ξw,c. What this
means is that updates to another triplet of variables
uŵ, vĉ and vĉ′ can be performed independently.
This observation is the key to developing a parallel
optimization strategy, by distributing the computa-
tion of the updates among multiple processors. Due
to lack of space, details including pseudo-code are
relegated to the supplementary material.

2.5 Interpreting of α and β
The update (12) indicates that ξ−1w,c is proportional
to rank (w, c). On the other hand, one can observe
that the loss function ` (·) in (14) is weighted by a
ρ′
(
ξ−1w,c

)
term. Since ρ (·) is concave, its gradient

ρ′ (·) is monotonically non-increasing (Rockafellar,
1970). Consequently, when rank (w, c) and hence
ξ−1w,c is large, ρ

′ (ξ−1w,c
)

is small. In other words, the
loss function “gives up” on contexts with high ranks
in order to focus its attention on top of the list. The
rate at which the algorithm gives up is determined
by the hyperparameters α and β. For the illustration
of this effect, see the example plots of ρ1 with dif-
ferent α and β in Figure 1(b). Intuitively, α can be
viewed as a scale parameter while β can be viewed
as an offset parameter. An equivalent interpretation
is that by choosing different values of α and β one
can modify the behavior of the ranking loss ρ (·) in a
problem dependent fashion. In our experiments, we
found that a common setting of α= 1 and β= 0 of-
ten yields uncompetitive performance, while setting
α=100 and β=99 generally gives good results.

3 Related Work

Our work sits at the intersection of word embed-
ding and ranking optimization. As we discussed in
Sec. 2.2 and Sec. 2.5, it’s also related to the atten-
tion mechanism widely used in deep learning. We
therefore review the related work along these three
axes.

Word Embedding. We already discussed some
related work (word2vec and GloVe) on word em-
bedding in the introduction. Essentially, word2vec
and GloVe derive word representations by modeling
a transformation (PMI or log) ofXw,c directly, while

662



WordRank learns word representations via robust
ranking. Besides these state-of-the-art techniques, a
few ranking-based approaches have been proposed
for word embedding recently, e.g., (Collobert and
Weston, 2008; Vilnis and McCallum, 2015; Liu et
al., 2015). However, all of them adopt a pair-wise
binary classification approach with a linear rank-
ing loss ρ0. For example, (Collobert and Weston,
2008; Vilnis and McCallum, 2015) employ a hinge
loss on positive/negative word pairs to learn word
representations and ρ0 is used implicitly to evaluate
ranking losses. As we discussed in Sec. 2.2, ρ0 has
no benefit of the attention mechanism and robust-
ness to noise since its linearity treats all the rank-
ing errors uniformly; empirically, sub-optimal per-
formances are often observed with ρ0 in our exper-
iments. More recently, by extending the Skip-Gram
model of word2vec, Liu et al. (2015) incorporates
additional pair-wise constraints induced from 3rd-
party knowledge bases, such as WordNet, and learns
word representations jointly. In contrast, WordRank
is a fully ranking-based approach without using any
additional data source for training.

Robust Ranking. The second line of work that is
very relevant to WordRank is that of ranking objec-
tive (3). The use of score functions 〈uw,vc〉 for
ranking is inspired by the latent collaborative re-
trieval framework of Weston et al. (2012). Writing
the rank as a sum of indicator functions (1), and
upper bounding it via a convex loss (2) is due to
Usunier et al. (2009). Using ρ0 (·) (5) corresponds
to the well-known pairwise ranking loss (see e.g.,
(Lee and Lin, 2013)). On the other hand, Yun et
al. (2014) observed that if they set ρ = ρ2 as in
(7), then −J (U,V) corresponds to the DCG (Dis-
counted Cumulative Gain), one of the most popular
ranking metrics used in web search ranking (Man-
ning et al., 2008). In their RobiRank algorithm they
proposed the use of ρ = ρ1 (6), which they consid-
ered to be a special function for which one can de-
rive an efficient stochastic optimization procedure.
However, as we showed in this paper, the general
class of monotonically increasing concave functions
can be handled efficiently. Another important differ-
ence of our approach is the hyperparameters α and
β, which we use to modify the behavior of ρ, and
which we find are critical to achieve good empirical

results. Ding and Vishwanathan (2010) proposed the
use of ρ=logt in the context of robust binary classi-
fication, while here we are concerned with ranking,
and our formulation is very general and applies to a
variety of ranking losses ρ (·) with weights rw,c. Op-
timizing over U and V by distributing the computa-
tion across processors is inspired by work on dis-
tributed stochastic gradient for matrix factorization
(Gemulla et al., 2011).

Attention. Attention is one of the most impor-
tant advancements in deep learning in recent years
(Larochelle and Hinton, 2010), and is now widely
used in state-of-the-art image recognition and ma-
chine translation systems (Mnih et al., 2014; Bah-
danau et al., 2015). Recently, attention has also been
applied to the domain of word embedding. For ex-
ample, under the intuition that not all contexts are
created equal, Wang et al. (2015) assign an impor-
tance weight to each word type at each context po-
sition and learn an attention-based Continuous Bag-
Of-Words (CBOW) model. Similarly, within a rank-
ing framework, WordRank expresses the context im-
portance by introducing the auxiliary variable ξw,c,
which “gives up” on contexts with high ranks in or-
der to focus its attention on top of the list.

4 Experiments

In our experiments, we first evaluate the impact of
the weight rw,c and the ranking loss function ρ(·)
on the test performance using a small dataset. We
then pick the best performing model and compare it
against word2vec (Mikolov et al., 2013b) and GloVe
(Pennington et al., 2014). We closely follow the
framework of Levy et al. (2015) to set up a careful
and fair comparison of the three methods. Our code
is publicly available at https://bitbucket.
org/shihaoji/wordrank.

Training Corpus Models are trained on a com-
bined corpus of 7.2 billion tokens, which consists
of the 2015 Wikipedia dump with 1.6 billion tokens,
the WMT14 News Crawl5 with 1.7 billion tokens,
the “One Billion Word Language Modeling Bench-
mark”6 with almost 1 billion tokens, and UMBC

5http://www.statmt.org/wmt14/
translation-task.html

6http://www.statmt.org/lm-benchmark

663



Corpus Size 17M∗ 32M 64M 128M 256M 512M 1.0B 1.6B 7.2B
Vocabulary Size |W| 71K 100K 100K 200K 200K 300K 300K 400K 620K
Window Size win 15 15 15 10 10 10 10 10 10
Dimension k 100 100 100 200 200 300 300 300 300

* This is the Text8 dataset from http://mattmahoney.net/dc/text8.zip, which is widely used for word embedding demo.
Table 1: Parameter settings used in the experiments.

Task Robi ρ0 ρ1 ρ2 ρ3
off on off on off on off on

Similarity 41.2 69.0 71.0 66.7 70.4 66.8 70.8 68.1 68.0
Analogy 22.7 24.9 31.9 34.3 44.5 32.3 40.4 33.6 42.9

Table 2: Performance of different ρ functions on Text8 dataset with 17M tokens.

webbase corpus7 with around 3 billion tokens. The
pre-processing pipeline breaks the paragraphs into
sentences, tokenizes and lowercases each corpus
with the Stanford tokenizer. We further clean up
the dataset by removing non-ASCII characters and
punctuation, and discard sentences that are shorter
than 3 tokens or longer than 500 tokens. In the end,
we obtain a dataset of 7.2 billion tokens, with the
first 1.6 billion tokens from Wikipedia. When we
want to experiment with a smaller corpus, we ex-
tract a subset which contains the specified number
of tokens.

Co-occurrence matrix construction We use the
GloVe code to construct the co-occurrence matrix
X , and the same matrix is used to train GloVe and
WordRank models. When constructing X , we must
choose the size of the vocabulary, the context win-
dow and whether to distinguish left context from
right context. We follow the findings and design
choices of GloVe and use a symmetric window of
size win with a decreasing weighting function, so
that word pairs that are d words apart contribute 1/d
to the total count. Specifically, when the corpus is
small (e.g., 17M, 32M, 64M) we let win = 15 and
for larger corpora we let win= 10. The larger win-
dow size alleviates the data sparsity issue for small
corpus at the expense of adding more noise to X .
The parameter settings used in our experiments are
summarized in Table 1.

Using the trained model It has been shown by
Pennington et al. (2014) that combining the uw and
vc vectors with equal weights gives a small boost

7http://ebiquity.umbc.edu/resource/html/
id/351

in performance. This vector combination was origi-
nally motivated as an ensemble method (Pennington
et al., 2014), and later Levy et al. (2015) provided
a different interpretation of its effect on the cosine
similarity function, and show that adding context
vectors effectively adds first-order similarity terms
to the second-order similarity function. In our ex-
periments, we find that vector combination boosts
the performance in word analogy task when training
set is small, but when dataset is large enough (e.g.,
7.2 billion tokens), vector combination doesn’t help
anymore. More interestingly, for the word similarity
task, we find that vector combination is detrimen-
tal in all the cases, sometimes even substantially8.
Therefore, we will always use uw on word similarity
task, and use uw + vc on word analogy task unless
otherwise noted.

4.1 Evaluation

Word Similarity We use six datasets to evaluate
word similarity: WS-353 (Finkelstein et al., 2002)
partitioned into two subsets: WordSim Similarity
and WordSim Relatedness (Agirre et al., 2009);
MEN (Bruni et al., 2012); Mechanical Turk (Radin-
sky et al., 2011); Rare words (Luong et al., 2013);
and SimLex-999 (Hill et al., 2014). They contain
word pairs together with human-assigned similarity
judgments. The word representations are evaluated
by ranking the pairs according to their cosine simi-
larities, and measuring the Spearman’s rank correla-
tion coefficient with the human judgments.

8This is possible since we optimize a ranking loss: the ab-
solute scores don’t matter as long as they yield an ordered list
correctly. Thus, WordRank’s uw and vc are less comparable
to each other than those generated by GloVe, which employs a
point-wise L2 loss.

664



Word Analogies For this task, we use the Google
analogy dataset (Mikolov et al., 2013a). It contains
19544 word analogy questions, partitioned into 8869
semantic and 10675 syntactic questions. A question
is correctly answered only if the algorithm selects
the word that is exactly the same as the correct word
in the question: synonyms are thus counted as mis-
takes. There are two ways to answer these questions,
namely, by using 3CosAdd or 3CosMul (see (Levy
and Goldberg, 2014) for details). We will report
scores by using 3CosAdd by default, and indicate
when 3CosMul gives better performance.

4.2 The impact of rw,c and ρ(·)
In Sec. 2.2 we argued the need for adding weight
rw,c to ranking objective (3), and we also presented
our framework which can deal with a variety of
ranking loss functions ρ. We now study the utility
of these two ideas. We report results on the 17 mil-
lion token dataset in Table 2. For the similarity task,
we use the WS-353 test set and for the analogy task
we use the Google analogy test set. The best scores
for each task are underlined. We set t= 1.5 for ρ3.
“Off” means that we used uniform weight rw,c = 1,
and “on” means that rw,c was set as in (4). For com-
parison, we also include the results using RobiRank
(Yun et al., 2014)9.

It can be seen from Table 2 that adding the weight
rw,c improves performance in all the cases, espe-
cially on the word analogy task. Among the four
ρ functions, ρ0 performs the best on the word simi-
larity task but suffers notably on the analogy task,
while ρ1 = log performs the best overall. Given
these observations, which are consistent with the re-
sults on large scale datasets, in the experiments that
follow we only report WordRank with the best con-
figuration, i.e., using ρ1 with the weight rw,c as de-
fined in (4).

4.3 Comparison to state-of-the-arts
In this section we compare the performance of Wor-
dRank with word2vec10 and GloVe11, by using the

9We used the code provided by the authors at https://
bitbucket.org/d_ijk_stra/robirank. Although
related to RobiRank, we attribute the superior performance of
WordRank to the use of weight rw,c (4), introduction of hyper-
parameters α and β, and many implementation details.

10https://code.google.com/p/word2vec/
11http://nlp.stanford.edu/projects/glove

code provided by the respective authors. For a fair
comparison, GloVe and WordRank are given as in-
put the same co-occurrence matrix X; this elimi-
nates differences in performance due to window size
and other such artifacts, and the same parameters
are used to word2vec. Moreover, the embedding di-
mensions used for each of the three methods is the
same (see Table 1). With word2vec, we train the
Skip-Gram with Negative Sampling (SGNS) model
since it produces state-of-the-art performance, and
is widely used in the NLP community (Mikolov et
al., 2013b). For GloVe, we use the default parame-
ters as suggested by (Pennington et al., 2014). The
results are provided in Figure 2 (also see Table 4 in
the supplementary material for additional details).

As can be seen, when the size of corpus increases,
in general all three algorithms improve their predic-
tion accuracy on both tasks. This is to be expected
since a larger corpus typically produces better statis-
tics and less noise in the co-occurrence matrix X .
When the corpus size is small (e.g., 17M, 32M,
64M, 128M), WordRank yields the best performance
with significant margins among three, followed by
word2vec and GloVe; when the size of corpus in-
creases further, on the word analogy task word2vec
and GloVe become very competitive to WordRank,
and eventually perform neck-to-neck to each other
(Figure 2(b)). This is consistent with the findings of
(Levy et al., 2015) indicating that when the number
of tokens is large even simple algorithms can per-
form well. On the other hand, WordRank is dom-
inant on the word similarity task for all the cases
(Figure 2(a)) since it optimizes a ranking loss explic-
itly, which aligns more naturally with the objective
of word similarity than the other methods; with 17
million tokens our method performs almost as well
as existing methods using 7.2 billion tokens on the
word similarity benchmark.

To further evaluate the model performance on the
word similarity/analogy tasks, we use the best per-
forming models trained on the 7.2-billion-token cor-
pus to predict on the six word similarity datasets de-
scribed in Sec. 4.1. Moreover, we breakdown the
performance of the models on the Google word anal-
ogy dataset into the semantic and syntactic subtasks.
Results are listed in Table 3. As can be seen, Wor-
dRank outperforms word2vec and GloVe on 5 of 6
similarity tasks, and 1 of 2 Google analogy subtasks.

665



17M 32M 64M 128M 256M 512M 1B 1.6B 7.2B
45

50

55

60

65

70

75

80

Number of Tokens

A
cc

ur
ac

y 
[%

]

 

 

Word2Vec
GloVe
WordRank

17M 32M 64M 128M 256M 512M 1B 1.6B 7.2B
30

35

40

45

50

55

60

65

70

75

80

Number of Tokens

A
cc

ur
ac

y 
[%

]

 

 

Word2Vec
GloVe
WordRank

Figure 2: Performance evolution as a function of corpus size (a) on WS-353 word similarity benchmark; (b) on Google word
analogy benchmark.

Word Similarity Word Analogy
Model WordSim WordSim Bruni et Radinsky Luong et Hill et al. Goog Goog

Similarity Relatedness al. MEN et al. MT al. RW SimLex Sem. Syn.
word2vec 73.9 60.9 75.4 66.4 45.5 36.6 78.8 72.0
GloVe 75.7 67.5 78.8 69.7 43.6 41.6 80.9 71.1
WordRank 79.4 70.5 78.1 73.5 47.4 43.5 78.4 74.7

Table 3: Performance of the best word2vec, GloVe and WordRank models, learned from 7.2 billion tokens, on six similarity tasks
and Google semantic and syntactic subtasks.

5 Visualizing the results

To understand whether WordRank produces syntat-
ically and semantically meaningful vector space,
we did the following experiment: we use the best
performing model produced using 7.2 billion to-
kens, and compute the nearest neighbors of the word
“cat”. We then visualize the words in two dimen-
sions by using t-SNE (Maaten and Hinton, 2008).
As can be seen in Figure 3, our ranking-based model
is indeed capable of capturing both semantic (e.g.,
cat, feline, kitten, tabby) and syntactic (e.g., leash,
leashes, leashed) regularities of the English lan-
guage.

6 Conclusion

We proposed WordRank, a ranking-based approach,
to learn word representations from large scale tex-
tual corpora. The most prominent difference be-
tween our method and the state-of-the-art tech-
niques, such as word2vec and GloVe, is that Wor-
dRank learns word representations via a robust rank-
ing model, while word2vec and GloVe typically
model a transformation of co-occurrence countXw,c
directly. Moreover, by a ranking loss function ρ(·),
WordRank achieves its attention mechanism and ro-
bustness to noise naturally, which are usually lack-

25 30 35 40 45 50

−6

−4

−2

0

2

4

6

8

10

12

14

cats
feline

kitten

felines

dog

pet

dogs

kittens
pets

tabby

paws

caninepuppypuppiespooch

doggie
canines

pups

kitties

puppaw

leashed

feral

pawprints

zoo

doggy

pooches

aspca

zoos

cub

mutts

petting

stray

zookeepers

groomers

leash

panda

groomer

pandas

leashes

mutt

cat

Figure 3: Nearest neighbors of “cat” found by projecting a
300d word embedding learned from WordRank onto a 2d space.

ing in other ranking-based approaches. These at-
tributes significantly boost the performance of Wor-
dRank in the cases where training data are sparse and
noisy. Our multi-node distributed implementation of
WordRank is publicly available for general usage.

Acknowledgments

We’d like to thank Omer Levy for sharing his script
for preprocessing the corpora used in the paper. We
also thank the anonymous reviewers for their valu-
able comments and suggestions.

666



References

Eneko Agirre, Enrique Alfonseca, Keith Hall, Jana
Kravalova, Marius Pasca, and Aitor Soroa. 2009. A
study on similarity and relatedness using distributional
and wordnet-based approaches. Proceedings of Hu-
man Language Technologies, pages 19–27.

Sanjeev Arora, Yuanzhi Li, Yingyu Liang, Tengyu Ma,
and Andrej Risteski. 2015. Random walks on context
spaces: Towards an explanation of the mysteries of se-
mantic word embeddings. Technical report, ArXiV.
http://arxiv.org/pdf/1502.03520.pdf.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proceedings of
the International Conference on Learning Represen-
tations (ICLR).

Peter L. Bartlett, Michael I. Jordan, and Jon D.
McAuliffe. 2006. Convexity, classification, and risk
bounds. Journal of the American Statistical Associa-
tion, 101(473):138–156.

Léon Bottou and Olivier Bousquet. 2011. The trade-
offs of large-scale learning. Optimization for Machine
Learning, page 351.

Elia Bruni, Gemma Boleda, Marco Baroni, and
Nam Khanh Tran. 2012. Distributional semantics
in technicolor. Proceedings of the 50th Annual Meet-
ing of the Association for Computational Linguistics,
pages 136–145.

Ronan Collobert and Jason Weston. 2008. A unified ar-
chitecture for natural language processing: Deep neu-
ral networks with multitask learning. In Proceedings
of the 25th international conference on Machine learn-
ing, pages 160–167. ACM.

T. M. Cover and J. A. Thomas. 1991. Elements of Infor-
mation Theory. John Wiley and Sons, New York.

Nan Ding and S. V. N. Vishwanathan. 2010. t-logistic re-
gression. In Richard Zemel, John Shawe-Taylor, John
Lafferty, Chris Williams, and Alan Culota, editors, Ad-
vances in Neural Information Processing Systems 23.

J. J. Dongarra, J. Du Croz, S. Duff, and S. Hammarling.
1990. A set of level 3 basic linear algebra subpro-
grams. ACM Transactions on Mathematical Software,
16:1–17.

Lev Finkelstein, Evgeniy Gabrilovich, Yossi Matias,
Ehud Rivlin, Zach Solan, Gadi Wolfman, and Eytan
Ruppin. 2002. Placing search in context: The concept
revisited. ACM Transactions on Information Systems,
20:116–131.

R. Gemulla, E. Nijkamp, P. J. Haas, and Y. Sisma-
nis. 2011. Large-scale matrix factorization with dis-
tributed stochastic gradient descent. In Conference on
Knowledge Discovery and Data Mining, pages 69–77.

Felix Hill, Roi Reichart, and Anna Korhonen. 2014.
Simlex-999: Evaluating semantic models with (gen-
uine) similarity estimation. Proceedings of the Sev-
enteenth Conference on Computational Natural Lan-
guage Learning.

Hugo Larochelle and Geoffrey E. Hinton. 2010. Learn-
ing to combine foveal glimpses with a third-order
boltzmann machine. In Advances in Neural Informa-
tion Processing Systems (NIPS) 23, pages 1243–1251.

Ching-Pei Lee and Chih-Jen Lin. 2013. Large-scale lin-
ear ranksvm. Neural Computation. To Appear.

Omer Levy and Yoav Goldberg. 2014. Neural word
embedding as implicit matrix factorization. In Max
Welling, Zoubin Ghahramani, Corinna Cortes, Neil
Lawrence, and Kilian Weinberger, editors, Advances
in Neural Information Processing Systems 27, pages
2177–2185.

Omer Levy, Yoav Goldberg, and Ido Dagan. 2015. Im-
proving distributional similarity with lessons learned
from word embeddings. Transactions of the Associa-
tion for Computational Linguistics, 3:211–225.

Quan Liu, Hui Jiang, Si Wei, Zhen-Hua Ling, and Yu Hu.
2015. Learning semantic word embeddings based on
ordinal knowledge constraints. In Proceedings of the
Annual Meeting of the Association for Computational
Linguistics (ACL), pages 1501–1511.

Minh-Thang Luong, Richard Socher, and Christopher D.
Manning. 2013. Better word representations with re-
cursive neural networks for morphology. Proceedings
of the Seventeenth Conference on Computational Nat-
ural Language Learning, pages 104–113.

L. van der Maaten and G.E. Hinton. 2008. Visualizing
high-dimensional data using t-sne. jmlr, 9:2579–2605.

C. D. Manning, P. Raghavan, and H. Schütze. 2008. In-
troduction to Information Retrieval. Cambridge Uni-
versity Press.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey
Dean. 2013a. Efficient estimation of word representa-
tions in vector space. arXiv preprint arXiv:1301.3781.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Cor-
rado, and Jeffrey Dean. 2013b. Distributed represen-
tations of words and phrases and their composition-
ality. In Chris Burges, Leon Bottou, Max Welling,
Zoubin Ghahramani, and Kilian Weinberger, editors,
Advances in Neural Information Processing Systems
26.

Volodymyr Mnih, Nicolas Heess, Alex Graves, and Ko-
ray Kavukcuoglu. 2014. Recurrent models of visual
attention. In Advances in Neural Information Process-
ing Systems (NIPS) 27, pages 2204–2212.

Jeffrey Pennington, Richard Socher, and Christopher D
Manning. 2014. Glove: Global vectors for word rep-
resentation. Proceedings of the Empiricial Methods in
Natural Language Processing (EMNLP 2014), 12.

667



Kira Radinsky, Eugene Agichtein, Evgeniy Gabrilovich,
and Shaul Markovitch. 2011. A word at a time: Com-
puting word relatedness using temporal semantic anal-
ysis. Proceedings of the 20th international conference
on World Wide Web, pages 337–346.

R. T. Rockafellar. 1970. Convex Analysis, volume 28 of
Princeton Mathematics Series. Princeton University
Press, Princeton, NJ.

Nicolas Usunier, David Buffoni, and Patrick Gallinari.
2009. Ranking with ordered weighted pairwise clas-
sification. In Proceedings of the International Confer-
ence on Machine Learning.

Luke Vilnis and Andrew McCallum. 2015. Word repre-
sentations via gaussian embedding. In Proceedings of
the International Conference on Learning Representa-
tions (ICLR).

Ling Wang, Chu-Cheng Lin, Yulia Tsvetkov, Silvio Amir,
Ramon Fernandez Astudillo, Chris Dyer, Alan Black,
and Isabel Trancoso. 2015. Not all contexts are cre-
ated equal: Better word representations with variable
attention. In EMNLP.

Jason Weston, Chong Wang, Ron Weiss, and Adam
Berenzweig. 2012. Latent collaborative retrieval.
arXiv preprint arXiv:1206.4603.

Hyokun Yun, Parameswaran Raman, and S. V. N. Vish-
wanathan. 2014. Ranking via robust binary classifi-
cation and parallel parameter estimation in large-scale
data. In nips.

668


