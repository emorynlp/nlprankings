



















































Discovering Latent Structure in Task-Oriented Dialogues


Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics, pages 36–46,
Baltimore, Maryland, USA, June 23-25 2014. c©2014 Association for Computational Linguistics

Discovering Latent Structure in Task-Oriented Dialogues

Ke Zhai∗
Computer Science, University of Maryland

College Park, MD 20740
zhaike@cs.umd.edu

Jason D. Williams
Microsoft Research

Redmond, WA 98052
jason.williams@microsoft.com

Abstract

A key challenge for computational conver-
sation models is to discover latent struc-
ture in task-oriented dialogue, since it pro-
vides a basis for analysing, evaluating, and
building conversational systems. We pro-
pose three new unsupervised models to
discover latent structures in task-oriented
dialogues. Our methods synthesize hidden
Markov models (for underlying state) and
topic models (to connect words to states).
We apply them to two real, non-trivial
datasets: human-computer spoken dia-
logues in bus query service, and human-
human text-based chats from a live tech-
nical support service. We show that our
models extract meaningful state represen-
tations and dialogue structures consistent
with human annotations. Quantitatively,
we show our models achieve superior per-
formance on held-out log likelihood eval-
uation and an ordering task.

1 Introduction

Modeling human conversation is a fundamental
scientific pursuit. In addition to yielding ba-
sic insights into human communication, compu-
tational models of conversation underpin a host
of real-world applications, including interactive
dialogue systems (Young, 2006), dialogue sum-
marization (Murray et al., 2005; Daumé III and
Marcu, 2006; Liu et al., 2010), and even medi-
cal applications such as diagnosis of psychological
conditions (DeVault et al., 2013).

Computational models of conversation can be
broadly divided into two genres: modeling and
control. Control is concerned with choosing ac-
tions in interactive settings—for example to maxi-
mize task completion—using reinforcement learn-

∗Work done at Microsoft Research.

ing (Levin et al., 2000), supervised learning (Hur-
tado et al., 2010), hand-crafted rules (Larsson and
Traum, 2000), or mixtures of these (Henderson
and Lemon, 2008). By contrast, modeling—the
genre of this paper—is concerned with inferring
a phenomena in an existing corpus, such as di-
alogue acts in two-party conversations (Stolcke
et al., 2000) or topic shifts in multi-party dia-
logues (Galley et al., 2003; Purver et al., 2006;
Hsueh et al., 2006; Banerjee and Rudnicky, 2006).

Many past works rely on supervised learning or
human annotations, which usually requires man-
ual labels and annotation guidelines (Jurafsky et
al., 1997). It constrains scaling the size of training
examples, and application domains. By contrast,
unsupervised methods operate only on the observ-
able signal (e.g. words) and are estimated with-
out labels or their attendant limitations (Crook et
al., 2009). They are particularly relevant because
conversation is a temporal process where models
are trained to infer a latent state which evolves as
the dialogue progresses (Bangalore et al., 2006;
Traum and Larsson, 2003).

Our basic approach is to assume that each ut-
terance in the conversation is in a latent state,
which has a causal effect on the words the conver-
sants produce. Inferring this model yields basic
insights into the structure of conversation and also
has broad practical benefits, for example, speech
recognition (Williams and Balakrishnan, 2009),
natural language generation (Rieser and Lemon,
2010), and new features for dialogue policy opti-
mization (Singh et al., 2002; Young, 2006).

There has been limited past work on unsuper-
vised methods for conversation modeling. Choti-
mongkol (2008) studies task-oriented conversa-
tion and proposed a model based on a hidden
Markov model (HMM). Ritter et al. (2010) ex-
tends it by introducing additional word sources,
and applies to non-task-oriented conversations—
social interactions on Twitter, where the subjects

36



discussed are very diffuse. The additional word
sources capture the subjects, leaving the state-
specific models to express common dialogue flows
such as question/answer pairs.

In this paper, we retain the underlying HMM,
but assume words are emitted using topic models
(TM), exemplified by latent Dirichlet allocation
(Blei et al., 2003, LDA). LDA assumes each word
in an utterance is drawn from one of a set of latent
topics, where each topic is a multinomial distri-
bution over the vocabulary. The key idea is that
the set of topics is shared across all states, and
each state corresponds to a mixture of topics. We
propose three model variants that link topics and
states in different ways.

Sharing topics across states is an attractive
property in task-oriented dialogue, where a sin-
gle concept can be discussed at many points in a
dialogue, yet different topics often appear in pre-
dictable sequences. Compared to past works, the
decoupling of states and topics gives our mod-
els more expressive power and the potential to be
more data efficient. Empirically, we find that our
models outperform past approaches on two real-
world corpora of task-oriented dialogues.

This paper is organized as follows: Section 2 in-
troduces two task-oriented domains and corpora;
Section 3 details three new unsupervised genera-
tive models which combine HMMs and LDA and
efficient inference schemes; Section 4 evaluates
our models qualitatively and quantitatively, and fi-
nally conclude in Section 5.

2 Data

To test the generality of our models, we study two
very different datasets: a set of human-computer
spoken dialogues in quering bus timetable (Bus-
Time), and a set of human-human text-based dia-
logues in the technical support domain (TechSup-
port). In BusTime, the conversational structure is
known because the computer followed a determin-
istic program (Williams, 2012), making it possible
to directly compare an inferred model to ground
truth on this corpus.1 In TechSupport, there is no
known flowchart,2 making this a realistic applica-
tion of unsupervised methods.

1Available for download at http://research.microsoft.
com/en-us/events/dstc/

2Technical support human agents use many types of
documentation—mainly checklists and guidelines, but in
general, there are no flowcharts.

BusTime This corpus consists of logs of tele-
phone calls between a spoken dialogue system and
real bus users in Pittsburgh, USA (Black et al.,
2010). For the user side, the words logged are the
words recognized by the automatic speech recog-
nizer. The vocabulary of the recognizer was con-
strained to the bus timetable task, so only words
known to the recognizer in advance are output.
Even so, the word error rate is approximately 30-
40%, due to the challenging audio conditions of
usage—with traffic noise and extraneous speech.
The system asked users sequentially for a bus
route, origin and destination, and optionally date
and time. The system confirmed low-confidence
speech recognition results. Due to the speech
recognition channel, system and user turns always
alternate. An example dialogue is given below:

System: Say a route like 〈bus-route〉, or say I’m not sure.
User: 〈bus-route〉.
System: I thought you said 〈bus-route〉, is that right?
User: Yes.
System: Say where’re you leaving from, like 〈location〉.
User: 〈location〉.
System: Okay, 〈location〉, where are you going to?
...

We discard dialogues with fewer than 20 ut-
terances. We also map all named entities (e.g.,
“downtown” and “28X”) to their semantic types
(resp. 〈location〉 and 〈bus-route〉) to reduce vo-
cabulary size. The corpus we use consists of ap-
proximately 850 dialogue sessions or 30, 000 ut-
terances. It contains 370, 000 tokens (words or se-
mantic types) with vocabulary size 250.

TechSupport This corpus consists of logs of
real web-based human-human text “chat” con-
versations between clients and technical support
agents at a large corporation. Usually, clients and
agents first exchange names and contact informa-
tion; after that, dialogues are quite free-form, as
agents ask questions and suggest fixes. Most dia-
logues ultimately end when the client’s issue has
been resolved; some clients are provided with a
reference number for future follow-up. An exam-
ple dialogue is given below:

Agent: Welcome to the answer desk! My name is 〈agent-
name〉. How can I help you today?
Agent: May I have your name, email and phone no.?
Client: Hi, 〈agent-name〉. I recently installed new soft-
ware but I kept getting error, can you help me?
Agent: Sorry to hear that. Let me help you with that.
Agent: May I have your name, email and phone no.?
Client: The error code is 〈error-code〉.
Client: It appears every time when I launch it.
Client: Sure. My name is 〈client-name〉.
Client: My email and phone are 〈email〉, 〈phone〉.
Agent: Thanks, 〈client-name〉, please give me a minute.

37



s0

w0,i

N0

M

s0
M

s0

w0,i

N0

s1
M

s0

w0,i

N0

s1

w1,i

N1

M

s0

w0,i

N0

s1

w1,i

N1

... sn

wn,i

Nn

M

M

(a) LM-HMM

s0

w0,i

N0

s1 ... sn
M

w1,i

N1

wn,i

Nn

r1,ir0,i rn,i
πm

ψE

φm

s0

w0,i

N0

s1 ... sn
M

w1,i

N1

wn,i

Nn

r1,ir0,i rn,i

tm

gE

um

s0

w0,i

N0

s1
M

w1,i

N1

r1,ir0,i

tm

gE

um

s0

w0,i

N0

s1
M

r0,i

tm

gE

um

s0

w0,i

N0

s1
M

N1

r1,ir0,i

tm

gE

um

s0

N0

M

r0,i

tm

gE

um

s0

w0,i

N0

M

r0,i

tm

gE

um

M

tm

gE

um

s0

N0

M

tm

gE

um

(b) LM-HMMS

Figure 1: Plate diagrams of baseline models, from
existing work (Chotimongkol, 2008; Ritter et al.,
2010). Variable definitions are given in the text.

...

This data is less structured than BusTime;
clients’ issues span software, hardware, network-
ing, and other topics. In addition, clients use com-
mon internet short-hand (e.g., “thx”, “gtg”, “ppl”,
“hv”, etc), with mis-spellings (e.g., “ofice”, “off-
fice”, “erorr”, etc). In addition, chats from the web
interface are segmented into turns when a user hits
“Enter” on a keyboard. Therefore, clients’ input
and agents’ responses do not necessarily alternate
consecutively, e.g., an agent’s response may take
multiple turns as in the above example. Also, it
is unreasonable to group consecutive chats from
the same party to form a “alternating” structure
like BusTime dataset due to the asynchronism of
different states. For instance, the second block
of client inputs clearly comes from two different
states which should not be merged together.

We discard dialogues with fewer than 30 utter-
ances. We map named entities to their semantic
types, apply stemming, and remove stop words.3

The corpus we use contains approximately 2, 000
dialogue sessions or 80, 000 conversation utter-
ances. It consists of 770, 000 tokens, with a a vo-
cabulary size of 6, 600.

3 Latent Structure in Dialogues

In this work, our goal is to infer latent structure
presented in task-oriented conversation. We as-
sume that the structure can be encoded in a prob-
abilistic state transition diagram, where the dia-
logue is in one state at each utterance, and states
have a causal effect on the words observed. We as-
sume the boundaries between utterances are given,
which is trivial in many corpora.

The simplest formulation we consider is an
HMM where each state contains a unigram lan-
guage model (LM), proposed by Chotimongkol
(2008) for task-oriented dialogue and originally

3We used regular expression to map named entities, and
Porter stemmer in NLTK to stem all tokens.

developed for discourse analysis by Barzilay and
Lee (2004). We call it LM-HMM as in Figure 1(a).
For a corpus of M dialogues, the m-th dialogue
contains n utterances, each of which contains Nn
words (we omit index m from terms because it
will be clear from context). At n-th utterance,
we assume the dialogue is in some latent state sn.
Words in n-th utterance wn,1, . . . , wn,Nn are gen-
erated (independently) according to the LM. When
an utterance is complete, the next state is drawn
according to HMM, i.e., P (s′|s).

While LM-HMM captures the basic intuition of
conversation structure, it assumes words are con-
ditioned only on state. Ritter et al. (2010) extends
LM-HMM to allow words to be emitted from two
additional sources: the topic of current dialogue
φ, or a background LM ψ shared across all dia-
logues. A multinomial π indicates the expected
fraction of words from these three sources. For
every word in an utterance, first draw a source in-
dicator r from π, and then generate the word from
the corresponding source. We call it LM-HMMS
(Figure 1(b)). Ritter et al. (2010) finds these al-
ternate sources are important in non-task-oriented
domains, where events are diffuse and fleeting.
For example, Twitter exchanges often focus on a
particular event (labeled X), and follow patterns
like “saw X last night?”, “X was amazing”. Here
X appears throughout the dialogue but does not
help to distinguish conversational states in social
media. We also explore similar variants.

In this paper, these two models form our base-
lines. For all models, we use Markov chain Monte
Carlo (MCMC) inference (Neal, 2000) to find la-
tent variables that best fit observed data. We also
assume symmetric Dirichlet priors on all multino-
mial distributions and apply collapsed Gibbs sam-
pling. In the rest of this section, we present our
models and their inference algorithms in turn.

3.1 TM-HMM

Our approach is to modify the emission probabil-
ities of states to be distributions over topics rather
than distributions over words. In other words, in-
stead of generating words via a LM, we generate
words from a topic model (TM), where each state
maps to a mixture of topics. The key benefit of this
additional layer of abstraction is to enable states
to express higher-level concepts through pooling
of topics across states. For example, topics might
be inferred for content like “bus-route” or “lo-

38



s0

w0,i

N0

s1 ... sn
M

z0,i

w1,i

N1
z1,i

wn,i

Nn
zn,i

T

K

θt

φk

s0

w0,i

N0

s1 ... sn
M

z0,i

w1,i

N1
z1,i

wn,i

Nn
zn,i

T

K

ht

gk

s0

w0,i

N0

s1
M

z0,i

w1,i

N1
z1,i

T

K

ht

gk

s0

w0,i

N0

s1
M

z0,i

N1
z1,i

T

K

ht

gk

s0

w0,i

N0

s1
M

z0,i

T

K

ht

gk

s0

w0,i

N0

M

z0,i

T

K

ht

gk

s0

N0

M

z0,i

T

K

ht

gk

s0
M

T

K

ht

gk

M
T

K

ht

gk

(a) TM-HMM

s0

w0,i

N0

s1 ... sn
M

z0,i

w1,i

N1

z1,i

wn,i

Nn
zn,iK

r1,ir0,i rn,i

θm

τm

φk

s0

w0,i

N0

s1 ... sn
M

z0,i

w1,i

N1

z1,i

wn,i

Nn
zn,iK

r1,ir0,i rn,i

hm

um

gk

s0

w0,i

N0

s1
M

z0,i

N1

z1,iK

r1,ir0,i

hm

um

gk

s0

w0,i

N0

s1
M

z0,i

w1,i

N1

z1,iK

r1,ir0,i

hm

um

gk

s0

w0,i

N0

s1
M

z0,i

N1

z1,iK

r0,i

hm

um

gk

s0

w0,i

N0

s1
M

z0,iK

r0,i

hm

um

gk

s0

w0,i

N0

M

z0,iK

r0,i

hm

um

gk

s0

N0

M

z0,iK

r0,i

hm

um

gk

s0

N0

M

z0,iK

hm

um

gk

s0
M

K

hm

um

gk

M

K

hm

um

gk

M

K

gk

(b) TM-HMMS

s0

w0,i

N0

s1 ... sn
M

z0,i

w1,i

N1

z1,i

wn,i

Nn
zn,iK

r1,ir0,i rn,i

T

θm

φk

τt

s0

w0,i

N0

s1 ... sn
M

z0,i

w1,i

N1

z1,i

wn,i

Nn
zn,iK

r1,ir0,i rn,i

T

hm

gk

ut

s0

w0,i

N0

s1
M

z0,i

w1,i

N1

z1,iK

r1,ir0,i

T

hm

gk

ut

s0

w0,i

N0

s1
M

z0,i

N1

z1,iK

r1,ir0,i

T

hm

gk

ut

s0

w0,i

N0

s1
M

z0,i

N1

z1,iK

r0,i

T

hm

gk

ut

s0

w0,i

N0

s1
M

z0,iK

r0,i

T

hm

gk

ut

s0

w0,i

N0

M

z0,iK

r0,i

T

hm

gk

ut

s0

N0

M

z0,iK

r0,i

T

hm

gk

ut

s0

N0

M

z0,iK

T

hm

gk

ut

s0
M

K

T

hm

gk

ut

M

K

T

hm

gk

ut

M

K

T

gk

ut

(c) TM-HMMSS

Figure 2: Plate diagrams of proposed models. TM-HMM is an HMM with state-wise topic distributions.
TM-HMMS adds session-wise topic distribution and a source generator. TM-HMMSS adds a state-wise
source generator. Variable definitions are given in the text.

cations”; and other topics for dialogue acts, like
to “ask” or “confirm” information. States could
then be combinations of these, e.g., a state might
express “ask bus route” or “confirm location”.
This approach also decouples the number of top-
ics from the number of states. Throughout this pa-
per, we denote the number of topics as K and the
number of states as T . We index words, turns and
dialogues in the same ways as baseline models.

We develop three generative models. In the first
variant (TM-HMM, Figure 2(a)), we assume every
state s in HMM is associated with a distribution
over topics θ, and topics generate wordsw at each
utterance. The other two models allow words to
be generated from different sources (in addition to
states), akin to the LM-HMMS model.

TM-HMM generates a dialogue as following:
1: For each utterance n in that dialogue, sample

a state sn based on the previous state sn−1.
2: For each word in utterance n, first draw a

topic z from the state-specified distribution
over topics θsn conditioned on sn, then gener-
ate word w from the topic-specified distribu-
tion over vocabulary φz based on z.

We assume θ’s and φ’s are drawn from corre-
sponding Dirichlet priors, as in LDA.

The posterior distributions of state assignment
sn and topic assignment zn,i are

p(sn|s−n, z,α,γ) ∝ p(sn|s−n,γ)
· p(zn|s, z−n,α), (1)

p(zn,i|s,w, z−(n,i),α,β) ∝ p(zn,i|s, z−(n,i),α)
· p(wn,i|sn,w−(n,i), z,β),

where α, β, γ are symmetric Dirichlet priors on
state-wise topic distribution θt’s, topic-wise word
distribution φt’s and state transition multinomials,
respectively. All probabilities can be computed
using collapsed Gibbs sampler for LDA (Griffiths

and Steyvers, 2004) and HMM (Goldwater and
Griffiths, 2007). We iteratively sample all param-
eters until convergence.

3.2 TM-HMMS

TM-HMMS (Figure 2(b)) extends TM-HMM to al-
low words to be generated either from state LM
(as in LM-HMM), or a set of dialogue topics
(akin to LM-HMMS). Because task-oriented dia-
logues usually focus on a specific domain, a set
of words appears repeatedly throughout a given
dialogue. Therefore, the topic distribution is of-
ten stable throughout the entire dialogue, and
does not vary from turn to turn. For example,
in the troubleshooting domain, dialogues about
network connections, desktop productivity, and
anti-virus software could each map to different
session-wide topics. To express this, words in
the TM-HMMS model are generated either from
a dialogue-specific topic distribution, or from a
state-specific language model.4 A distribution
over sources is sampled once at the beginning of
each dialogue and selects the expected fraction of
words generated from different sources.

The generative story for a dialogue session is:
1: At the beginning of each session, draw a dis-

tribution over topics θ and a distribution over
word sources τ .

2: For each utterance n in the conversation, draw
a state sn based on previous state sn−1.

3: For each word in utterance n, first choose a
word source r according to τ , and then de-
pending on r, generate a word w either from
the session-wide topic distribution θ or the
language model specified by the state sn.

4Note that a TM-HMMS model with state-specific topic
models (instead of state-specific language models) would be
subsumed by TM-HMM, since one topic could be used as the
background topic in TM-HMMS.

39



Again, we impose Dirichlet priors on distributions
over topics θ’s and distributions over words φ’s
as in LDA. We also assume the distributions over
sources τ ’s are governed by a Beta distribution.

The session-wide topics is slightly different
from that used in LM-HMMS: LM-HMMS was de-
veloped for social chats on Twitter where topics
are very diffuse and unlikely to repeat; hence of-
ten unique to each dialogue. By contrast, our mod-
els are designed for task-oriented dialogues which
pertain to a given domain where topics are more
tightly clustered; thus, in TM-HMMS session-wide
topics are shared across the corpus.

The posterior distributions of state assignment
sn, word source rn,i and topic assignment zn,i are

p(sn|r, s−n,w,γ,π) ∝ p(sn|s−n,γ)
· p(wn|r, s,π),

p(rn,i|r−(n,i), s,w,π) ∝ p(rn,i|r−(n,i),π)
· p(wn,i|r, s,w−(n,i), z,β), (2)

p(zn,i|r,w, z−(n,i),α,β) ∝ p(zn,i|r, z−(n,i),α)
· p(wn,i|r,w−(n,i), z,β),

where π is a symmetric Dirichlet prior on session-
wise word source distribution τm’s, and other
symbols are defined above. All these probabilities
are Dirichlet-multinomial distributions and there-
fore can be computed efficiently.

3.3 TM-HMMSS

The TM-HMMSS (Figure 2(c)) model modifies
TM-HMMS to re-sample the distribution over
word sources τ at every utterance, instead of once
at the beginning of each session. This modifica-
tion allows the fraction of words drawn from the
session-wide topics to vary over the course of the
dialogue. This is attractive in task-oriented di-
alogue, where some sections of the dialogue al-
ways follow a similar script, regardless of session
topic—for example, the opening, closing, or ask-
ing the user if they will take a survey. To support
these patterns, TM-HMMSS conditions the source
generator distribution on the current state.

The generative story of TM-HMMSS is very
similar to TM-HMMS, except the distribution over
word sources τ ’s are sampled at every state. A
dialogue is generated as following:

1: For each session, draw a topic distribution θ.
2: For each utterance n in the conversation, draw

a state sn based on previous state sn−1, and

subsequently retrieve the state-specific distri-
bution over word sources τ sn .

3: For each word in utterance n, first sample a
word source r according to τ sn , and then de-
pending on r, generate a word w either from
the session-wide topic distribution θ or the
language model specified by the state sn.

As in TM-HMMS, we assume multinomial distri-
butions θ’s and φ’s are drawn from Dirichlet pri-
ors; and τ ’s are governed by Beta distributions.

The inference for TM-HMMSS is exactly same
as the inference for TM-HMMS, except the poste-
rior distributions over word source rn,i is now

p(rn,i|r−(n,i), s,w,π) ∝ p(rn,i|r−(n,i), sn,π)
· p(wn,i|r, s,w−(n,i), z,β), (3)

where the first term is integrated over all sessions
and conditioned on the state assignment.

3.4 Supporting Multiple Parties
Since our primary focus is task-oriented dia-
logues between two parties, we assume every
word source is associated with two sets of LMs—
one for system/agent and another for user/client.
This configuration is similar to PolyLDA (Mimno
et al., 2009) or LinkLDA (Yano et al., 2009), such
that utterances from different parties are treated
as different languages or blog-post and comments
pairs. In this work, we implement all models un-
der this setting, but omit details in plate diagrams
for the sake of simplicity.

In settings where the agent and client always al-
ternate, each state emits both text before transi-
tioning to the next state. This is the case in the
BusTime dataset, where the spoken dialogue sys-
tem enforces strict turn-taking. In settings where
agents or client may produce more than one utter-
ance in a row, each state emits either agent text or
client text, then transitions to the next state. This
is the case in the TechSupport corpus, where either
conversant may send a message at any time.

3.5 Likelihood Estimation
To evaluate performance across different models,
we compute the likelihood on held-out test set.
For TM-HMM model, there are no local depen-
dencies, and we therefore compute the marginal
likelihood using the forward algorithm. However,
for TM-HMMS and TM-HMMSS models, the la-
tent topic distribution θ creates local dependen-
cies, rendering computation of marginal likeli-

40



hoods intractable. Hence, we use a Chib-style
estimator (Wallach et al., 2009). Although it is
computationally more expensive, it gives less bi-
ased approximation of marginal likelihood, even
for finite samples. This ensures likelihood mea-
surements are comparable across models.

4 Experiments

In this section, we examine the effectiveness of our
models. We first evaluate our models qualitatively
by exploring the inferred state diagram. We then
perform quantitative analysis with log likelihood
measurements and an ordering task on a held-out
test set. We train all models with 80% of the en-
tire dataset and use the rest for testing. We run
the Gibbs samplers for 1000 iterations and update
all hyper-parameters using slice sampling (Neal,
2003; Wallach, 2008) every 10 iterations. The
training likelihood suggest all models converge
within 500−800 iterations. For all Chib-style esti-
mators, we collect 100 samples along the Markov
chain to approximate the marginal likelihood.

4.1 Qualitative Evaluation
Figure 3 shows the state diagram for BusTime cor-
pus inferred by TM-HMM without any supervi-
sion.5 Every dialogue is opened by asking the user
to say a bus route, or to say “I’m not sure.” It then
transits to a state about location, e.g., origin and
destination. Both these two states may continue
to a confirmation step immediately after. After
verifying all the necessary information, the system
asks if the user wants “the next few buses”.6 Oth-
erwise, the system follows up with the user on the
particular date and time information. After system
reads out bus times, the user has options to “re-
peat” or ask for subsequent schedules.

In addition, we also include the human-
annotated dialogue flow in Figure 4 for refer-
ence (Williams, 2012). It only illustrates the most
common design of system actions, without show-
ing edge cases. Comparing these two figures, the
dialogue flow inferred by our model along the
most probable path (highlighted in bold red in Fig-
ure 3) is consistent with underlying design. Fur-
thermore, our models are able to capture edge
cases—omitted for space—through a more gen-
eral and probabilistic fashion. In summary, our

5Recall in BusTime, state transitions occur after each pair
of system/user utterances, so we display them synchronously.

6The system was designed this way because most users
say “yes” to this question, obviating the date and time.

models yield a very similar flowchart to the under-
lying design in a completely unsupervised way.7

Figure 5 shows part of the flowchart for
the TechSupport corpus, generated by the TM-
HMMSS model.8 A conversation usually starts
with a welcome message from a customer support
agent. Next, clients sometimes report a problem;
otherwise, the agent gathers the client’s identity.
After these preliminaries, the agent usually checks
the system version or platform settings. Then, in-
formation about the problem is exchanged, and a
cycle ensues where agents propose solutions, and
clients attempt them, reporting results. Usually,
a conversation loops among these states until ei-
ther the problem is resolved (as the case shown
in the figure) or the client is left with a reference
number for future follow-up (not shown due to
space limit). Although technical support is task-
oriented, the scope of possible issues is vast and
not prescribed. The table in Figure 5 lists the top
ranked words of selected topics—the categories
clients often report problems in. It illustrates that,
qualitatively, TM-HMMSS discovers both problem
categories and conversation structures on our data.

As one of the baseline model, we also include a
part of flowchart generated by LM-HMM model
with similar settings of T = 20 states. Illus-
trated by the highlighted states in 6, LM-HMM
model conflates interactions that commonly occur
at the beginning and end of a dialogue—i.e., “ac-
knowledge agent” and “resolve problem”, since
their underlying language models are likely to pro-
duce similar probability distributions over words.
By incorporating topic information, our proposed
models (e.g., TM-HMMSS in Figure 5) are able to
enforce the state transitions towards more frequent
flow patterns, which further helps to overcome the
weakness of language model.

4.2 Quantitative Evaluation

In this section, we evaluate our models using log
likelihood and an ordering task on a held-out test
set. Both evaluation metrics measure the predic-
tive power of a conversation model.

7We considered various ways of making a quantitative
evaluation of the inferred state diagram, and proved difficult.
Rather than attempt to justify a particular sub-division of each
“design states”, we instead give several straightforward quan-
titative evaluations in the next section.

8Recall in this corpus, state transitions occur after emit-
ting each agent or client utterances, which does not necessar-
ily alternate in a dialogue, so we display client request and
agent response separately.

41



state: ask for bus route
(route:0.14), (say:0.13), (<bus-route>:0.12), (not:0.10), 

(sure:0.10), (im:0.09), (a:0.08), (bus:0.07), (like:0.06), ...
e.g.: say a bus route like <bus-route> or say i am not sure

(<bus-route>:0.7), (the:0.07), (im:0.06), (not:
0.05), (sure:0.04), (route:0.02), (any:0.01), ...

e.g.: <bus-route>/im not sure
0.53

state: confirm low-confidence speech recognition results
(right:0.19), (is:0.19), (that:0.19), (<location>:0.12), (<bus-route>:

0.05), (i:0.04), (you:0.03), (said:0.03), (thought:0.03), (over:0.03), ...
e.g.: i thought you said (<bus-route>/<location>) is that right

(yes:0.45), (no:0.3), (yeah:0.12), (wrong:0.04), 
(correct:0.03), (back:0.02), (go:0.02), (nope:0.01), ...

e.g.: yes/no/yeah/wrong/correct/go back/nope

0.12
0.32

0.53

0.15

state: ask for locations
(you:0.1), (are:0.09), (where:0.08), (to:0.07), (say:0.06), (from:0.05), 

(leaving:0.05), (going:0.05), (<location>:0.05), (okay:0.04), ...
e.g.: (okay <location>) say where are you (going to/leaving from)

(<location>:0.84), (back:
0.05), (go:0.05), ...

e.g.: <location>
0.210.23

0.85

0.44

0.28

state: ask if user is traveling now
(say:0.8), (the:0.07), (you:0.07), (no:0.06), (yes:0.06), (do:
0.06), (want:0.06), (buses:0.05), (few:0.05), (next:0.04), ...

e.g.: do you want the next few buses say yes or no

(yes:0.5), (no:0.17), (yeah:0.16), (<bus-route>:
0.07), (back:0.04), (go:0.04), (nope:0.01), ...

e.g.: yes/no/yeah

0.31

state: read out bus timetables
(<location>:0.08), (at:0.05), (<time>:0.05), (next:0.05), (say:0.05), (from:0.04), (there:

0.04), (<bus-route>:0.04), (to:0.04), ...
e.g.: there is a <bus-route> from <location> to <location> at <time> say next or repeat

(next:0.4), (repeat:0.16), (over:0.11), (start:0.11), 
(previous:0.07), (go:0.06), (back:0.06), (goodbye:0.05), ...

e.g.: next/repeat/start over/previous

0.12

0.42
state: ask for date and time (optional)

(<time>:0.14), (<date>:0.1), (the:0.06), (or:0.05), (like:0.05), 
(say:0.05), (you:0.05), (want:0.05), (at:0.04), (depart:0.04), ...

e.g.: say the time you want to depart like <time>

(<time>:0.26), (<date>:0.14), (m:0.11), 
(depart:0.07), (a:0.07), (at:0.07), (by:0.03), ...

e.g.: depart (at/by) <time> a m <date>

0.55

Start	  

I	  heard	  61C,	  is	  that	  right?	  

Downtown,	  is	  that	  correct?	  

Did	  you	  just	  say	  Norwood?	  

Say	  just	  the	  day	  you	  want.	  

Say	  just	  the	  <me	  you	  want.	  

I'm	  sorry,	  I	  can't	  find	  any	  bus	  
at	  all	  that	  run	  from	  Milton	  to	  
Norwell.	  I	  checked	  route	  61C	  
and	  I	  also	  checked	  all	  the	  
other	  bus	  routes	  I	  know	  too.	  

Repeat,	  next,	  previous	  

At	  11:45	  PM	  today,	  
there	  is	  a	  61	  C	  from	  
5th	  Ave	  and	  Main	  St	  

Canton,	  arriving	  2nd	  St	  
and	  Grant	  Ave	  in	  

Norwood	  at	  12:34	  AM.	  

Say	  a	  bus	  route,	  or	  
say	  I’m	  not	  sure.	  

Where	  are	  you	  leaving	  
from?	  (query	  database)	  

Where	  are	  you	  going	  
to?	  (query	  database)	  

Do	  you	  want	  <mes	  for	  
the	  next	  few	  buses?	  

(query	  database)	  

Figure 3: (Upper) Part of the flowchart inferred on Bus-
Time, by TM-HMM model with K = 10 topics and
T = 10 states. The most probable path is highlighted,
which is consistent with the underlying design (Figure 4).
Cyan blocks are system actions and yellow blocks are
user responses. In every block, the upper cell shows the
top ranked words marginalized over all topics and the
lower cell shows some examples of that state. Transition
probability cut-off is 0.1. States are labelled manually.
Figure 4: (Left) Hand-crafted reference flowchart for
BusTime (Williams, 2012). Only the most common di-
alogue flows are displayed. System prompts shown are
example paraphrases. Edge cases are not included.

Log Likelihood The likelihood metric measures
the probability of generating the test set under a
specified model. As shown in Figure 7, our models
yield as good or better likelihood than LM-HMM
and LM-HMMS models on both datasets under all
settings. For our proposed models, TM-HMMS
and TM-HMMSS perform better than TM-HMM
on TechSupport, but not necessarily on BusTime.
In addition, we notice that the marginal benefit of
TM-HMMSS over TM-HMM is greater on Tech-
Support dataset, where each dialogue focuses on
one of many possible tasks. This coincides with
our belief that topics are more conversation de-
pendent and shared across the entire corpus in cus-
tomer support data—i.e., different clients in differ-
ent sessions might ask about similar issues.

Ordering Test Ritter et al. (2010) proposes an
evaluation based on rank correlation coefficient,
which measures the degree of similarity between
any two orderings over sequential data. They use
Kendall’s τ as evaluation metric, which is based
on the agreement between pairwise orderings of
two sequences (Kendall, 1938). It ranges from −1

to +1, where +1 indicates an identical ordering
and −1 indicates a reverse ordering. The idea is
to generate all permutations of the utterances in
a dialogue (including true ordering), and compute
the log likelihood for each under the model. Then,
Kendall’s τ is computed between the most proba-
ble permutation and true ordering. The result is the
average of τ values for all dialogues in test corpus.

Ritter et al. (2010) limits their dataset by choos-
ing Twitter dialogues containing 3 to 6 posts (ut-
terances), making it tractable to enumerate all per-
mutations. However, our datasets are much larger,
and enumerating all possible permutations of dia-
logues with more than 20 or 30 utterances is infea-
sible. Instead, we incrementally build up the per-
mutation set by adding one random permutation at
a time, and taking the most probable permutation
after each addition. If this process were continued
(intractably!) until all permutations are enumer-
ated, the true value of Kendall’s τ test would be
reached. In practice, the value appears to plateau
after a few dozen measurements.

We present our results in Figure 8. Our mod-
els consistently perform as good or better than

42



Agent: conversation opening + identity check
help, answer, desk, microsoft, may, 

<agent>, welcom, name, number, phone, ...
e.g.: welcome to microsoft answer desk, i'm 

<agent>, how can i help you, may i have 
your name?

Client: report problem
tri, get, comput, cant, window, message, 

error, problem, instal, say, ...
e.g.: get problem in windows, cant install 

on computer, it says error message

Agent: conversation closure
thank, answer, microsoft, desk, <client>, 

contact, help, chat, day, welcom, ...
e.g.: thank you for contacting microsoft answer 

desk, you are welcome, have a nice day

Agent: acknowledge identity
thank, minut, pleas, let, <client>, check, 

give, moment, ok, wait, ...
e.g.: thank you, <client>, please give me 

a moment, wait for a minute, let me check

Agent: system check 
window, comput, instal, 7, use, 8, 

system, version, may, oper, ...
e.g.: may i know what version is 

operating system you used? windows 7?

Client: system verification
ok, ye(s), sure, pleas, thank, k, 

<prodkey>, one, problem, fine, ...
e.g.: ok, thanks, sure, <prodkey>, 

one problem

Agent: acknowledge problem
error, messag, see, issu, sorri, help, get, 

thank, <client>, oh, ...
e.g.: sorry to hear that, thanks for error 

message, i see, let me help you on issue

Agent: troubleshoot attempt
click, <href>, pleas, link, code, let, go, 

download, run, ok, ...
e.g.: please click <href> and go download 

the code, let it run and see it is ok 

Client: troubleshoot acknowledgement
ok, link, click, ye(s), code, dont, tri, 

download, get, say, ...
e.g.: ok, i am trying to download the code

Client: identity verification
<email>, <phoneno>, <client>, ye(s), 

number, phone, email, name, sure, call, ...
e.g.: yes, my name is <client>

sure, <client>, <phoneno>, <email>

Agent: troubleshoot attempt
instal, comput, program, tri, issu, 

system, file, work, run, see, ...
e.g.: try to install file or run program 

and see the issue goes away

Client: resolved problem
thank, ok, help, great, good, much, 

<agent>, ye(s), day, bye, ...
e.g.: yes, thank you <agent> so much 

for your great help, good day, bye
0.240581

0.20916 0.207256

0.145682

0.131558
0.122512

0.117276

0.108547

0.1291865

0.0798235

0.0764909
0.0893519

0.0801476

0.0854540.077694

0.088172

0.0728498

0.083912

0.0917323
0.0888547

Agent: conversation opening + identity check

help, answer, desk, microsoft, may, #agent#, welcom, 
name, number, phone, ...

e.g.: welcome to microsoft answer desk, i'm #agent#, 
how can i help you, may i have your name?

Client: report problem

tri, get, comput, cant, window, message, error, 
problem, instal, say, ...

e.g.: i get this problem in windows, cant install 
on my computer, it says this error message

Agent: conversation closure

thank, answer, microsoft, desk, #client#, 
contact, help, chat, day, welcom, ...

e.g.: thank you for contacting microsoft answer 
desk, you are welcome, have a nice day

Agent: acknowledge identity

thank, minut, pleas, let, #client#, check, 
give, moment, ok, wait, ...

e.g.: thank you, #client#, please give me a 
moment, wait for a minute, let me check

Agent: system check 

window, comput, instal, 7, use, 8, 
system, version, may, oper, ...

e.g.: may i know what version is 
operating system you used? windows 7?

Client: system verification

ok, ye(s), sure, pleas, thank, k, #prodkey#, 
one, problem, fine, ...

e.g.: ok, thanks, sure, #prodkey#, one problem

Agent: acknowledge problem

error, messag, see, issu, sorri, help, get, 
thank, #client#, oh, ...

e.g.: sorry to hear that, thanks for error 
message, i see, let me help you on issue

Agent: troubleshoot attempt

click, #href#, pleas, link, code, let, go, 
download, run, ok, ...

e.g.: please click #href# and go download 
the code, let it run and see it is ok 

Client: troubleshoot acknowledgement

ok, link, click, ye(s), code, 
dont, tri, download, get, say, ...

e.g.: ok, i am trying to 
download the code, yes

Client: identity verification

#email#, #phoneno#, #client#, ye(s), 
number, phone, email, name, sure, call, ...

e.g.: yes, my name is #client#
sure, #client#, #phoneno#, #email#

Agent: troubleshoot attempt

instal, comput, program, tri, issu, 
system, file, work, run, see, ...

e.g.: try to install file or run program 
and see the issue goes away

Client: resolved problem

thank, ok, help, great, good, much, 
#agent#, ye(s), day, bye, ...

e.g.: yes, thank you #agent# so much 
for your great help, good day, bye

0.0240581

0.020916 0.0207256

0.0145682

0.01315580.0122512

0.0117276

0.0108547

0.00891865

0.00798235

0.007649090.00593519

0.00801476

0.004554540.00377694

0.00568172

0.00328498

0.0053912

0.00617323

0.00588547

Agent: conversation opening + identity check
help, answer, desk, may, <agent-name>, 

welcom, name, number, phone, ...
e.g.: welcome to answer desk, i'm <agent-

name>, how can i help you, may i have 
your name?

Client: report problem
tri, get, comput, cant, window, message, 

error, problem, instal, say, ...
e.g.: get problem in windows, cant install 

on computer, it says error message

Agent: conversation closure
thank, answer, desk, <client-name>, contact, 

help, chat, day, welcom, ...
e.g.: thank you for contacting answer desk, 

you are welcome, have a nice day

Agent: acknowledge identity
thank, minut, pleas, let, <client-name>, 

check, give, moment, ok, wait, ...
e.g.: thank you, <client-name>, please 

give me a moment, let me check

Agent: system check 
window, comput, instal, 7, use, 8, 

system, version, may, oper, ...
e.g.: may i know what version is 

operating system you used? windows 7?

Client: system verification
ok, ye(s), sure, pleas, thank, k, 

<prodkey>, one, problem, fine, ...
e.g.: ok, thanks, sure, <prodkey>, 

one problem

Agent: acknowledge problem
error, messag, see, issu, sorri, help, get, 

thank, <client-name>, oh, ...
e.g.: sorry to hear that, thanks for error 

message, i see, let me help you on issue

Agent: troubleshoot attempt
click, <href>, pleas, link, code, let, go, 

download, run, ok, ...
e.g.: please click <href> and go download 

the code, let it run and see it is ok 

Client: troubleshoot acknowledgement
ok, link, click, ye(s), code, dont, tri, 

download, get, say, ...
e.g.: ok, i am trying to download the code

Client: identity verification
<email>, <phone>, <client-name>, ye(s), 

number, phone, email, name, sure, call, ...
e.g.: yes, my name is <client-name>

sure, <client-name>, <phone>, <email>

Agent: troubleshoot attempt
instal, comput, program, tri, issu, 

system, file, work, run, see, ...
e.g.: try to install file or run program 

and see the issue goes away

Client: resolved problem
thank, ok, help, great, good, much, 
<agent-name>, ye(s), day, bye, ...

e.g.: great, thanks <agent-name> so 
much for your help, good day, bye

0.24

0.21 0.21

0.15

0.13
0.12

0.12

0.11

0.13

0.08

0.08
0.09

0.08

0.090.08

0.09

0.07

0.08

0.09
0.09

Agent: conversation opening + identity check
help, answer, desk, microsoft, may, <agent-
name>, welcom, name, number, phone, ...

e.g.: welcome to microsoft answer desk, i'm 
<agent-name>, how can i help you, may i 

have your name?

Client: report problem
tri, get, comput, cant, window, message, 

error, problem, instal, say, ...
e.g.: get problem in windows, cant install 

on computer, it says error message

Agent: conversation closure
thank, answer, microsoft, desk, <client-name>, 

contact, help, chat, day, welcom, ...
e.g.: thank you for contacting microsoft answer 

desk, you are welcome, have a nice day

Agent: acknowledge identity
thank, minut, pleas, let, <client-name>, 

check, give, moment, ok, wait, ...
e.g.: thank you, <client-name>, please 

give me a moment, let me check

Agent: system check 
window, comput, instal, 7, use, 8, 

system, version, may, oper, ...
e.g.: may i know what version is 

operating system you used? windows 7?

Client: system verification
ok, ye(s), sure, pleas, thank, k, 

<prodkey>, one, problem, fine, ...
e.g.: ok, thanks, sure, <prodkey>, 

one problem

Agent: acknowledge problem
error, messag, see, issu, sorri, help, get, 

thank, <client-name>, oh, ...
e.g.: sorry to hear that, thanks for error 

message, i see, let me help you on issue

Agent: troubleshoot attempt
click, <href>, pleas, link, code, let, go, 

download, run, ok, ...
e.g.: please click <href> and go download 

the code, let it run and see it is ok 

Client: troubleshoot acknowledgement
ok, link, click, ye(s), code, dont, tri, 

download, get, say, ...
e.g.: ok, i am trying to download the code

Client: identity verification
<email>, <phone>, <client-name>, ye(s), 

number, phone, email, name, sure, call, ...
e.g.: yes, my name is <client-name>

sure, <client-name>, <phone>, <email>

Agent: troubleshoot attempt
instal, comput, program, tri, issu, 

system, file, work, run, see, ...
e.g.: try to install file or run program 

and see the issue goes away

Client: resolved problem
thank, ok, help, great, good, much, 
<agent-name>, ye(s), day, bye, ...

e.g.: great, thanks <agent-name> so 
much for your help, good day, bye

0.24

0.21 0.21

0.15

0.13
0.12

0.12

0.11

0.13

0.08

0.08
0.09

0.08

0.090.08

0.09

0.07

0.08

0.09
0.09

Topic Top Ranked Words

purc
hase microsoft, store, purchas, able, get,

sir, order, site, mr, contact, mac, . . .

brow
ser internet, explor, browser, ie, open,

websit, googl, download, click,
chrome, . . .

back
up file, restor, system, comput, back,

folder, creat, option, dont, delet, . . .

boot comput, boot, mode, option, disc,
safe, recoveri, repair, back, clean,
cd, disk, . . .

upda
te updat, window, servic, instal, pack,

run, comput, download, check,
restart, inform, system, error, fix, . . .

netw
ork connect, internet, printer, comput,

network, pc, print, access, wireless,
hp, cable, adapt, router, speed, . . .

anti-
virus viru, scan, comput, remov, secur,run, system, anti, essenti, infect, de-

fend, softwar, program, protect, an-
tiviru, malwar, . . .

hard
ware driver, devic, drive, dvd, cd, hard-war, issu, model, laptop, plug, soft-

ware, usb, . . .

wind
ows window, upgrad, 8, download, 7, in-

stal, bit, vista, pro, system, . . .

offic
e offic, 2010, word, microsoft, home,

excel, version, 2007, student, docu-
ment, trial, 2013, . . .

outlo
ok outlook, account, email, mail, mi-

crosoft, com, live, password, profil,
contact, creat, server, access, . . .

licen
se key, product, activ, purchas, licens,

valid, verifi, id, disc, pro, grenuin,
. . .

facil
ity window, 8, comput, instal, manufac-

tur, system, oem, 7, pc, hp, . . .

Figure 5: Part of flowchart (left) and topic table (right) on TechSupport dataset, generated by TM-HMMSS
model under settings ofK = 20 topics and T = 20 states. The topic table lists top ranked words in issues
discussed in the chats. Cyan blocks are system actions and yellow blocks are user responses. In every
block, the upper cell shows top ranked words, and the lower cell shows example string patterns of that
state. Transition probability cut-off is 0.05. States and topics are labelled manually.

Agent: conversation opening + identity check
answer, desk, help, <agent-name>, 

welcom, today, may, name, number, ...
e.g.: welcome to answer desk, i'm <agent-

name>, how can i help you, may i have 
your name, case/phone number, account?

Client: acknowledge agent / resolved problem
thank, ok, help, much, good, great, 

<agent-name>, day, appreci, bye, ...
e.g.: ok, thanks, great, <agent-name> 
appreciate your help, good day, bye

Agent: conversation closure
answer, desk, thank, contact, day, chat, 

great, session, com, help, ...
e.g.: thank you for contacting answer desk, 

you are welcome, have a nice day

Agent: acknowledge problem
issu, sorri, call, help, number, suport, 

concern, <client-name>, <phone>, best, ...
e.g.: sorry to hear that, let me help with 

your concern, <client-name>

Client: confirm identity
call, number, phone, case, <time>, would, 
<agent-name>, pleas, <phone>, time, ...
e.g.: <agent-time>, my phone number is 
<phone>. would you pleas call number...

Agent: conversation closure
anyth, els, welcom, help, <client-name>, 
today, assist, question, would, answer, ...

e.g.: you are welcome, anything else today 
i would help/assist you, <client-name>?

Agent: acknowledge identity
give, minut, pleas, check, let, 
thank, moment, 3, one, 5, ...

e.g.: thanks, one moment please, 
give me 3 minutes, let me check

Client: report problem
updat, window, install, <agent-name>, hello, 
error, get, problem, download, message, ...

e.g.: hello, <agent-name>, i get problem/error 
when install/update/download in windows

0.08
0.1

0.08

0.07

0.14

0.05

0.07

0.06

0.05
0.05

0.08

0.06

state 0 0

(0, answer) 0.14307

(0, desk) 0.140908

(0, help) 0.139542

(0, #agentname#) 0.122925

(0, microsoft) 0.121104

(0, welcom) 0.119283

(0, today) 0.0638546

(0, may) 0.0453027

(0, name) 0.0382462

(0, hello) 0.023564

state 0 1

(0, offic) 0.129144

(0, instal) 0.0691015

(0, 2013) 0.0479101

(0, purchas) 0.0395219

(0, 365) 0.0366522

(0, home) 0.0362107

(0, product) 0.0322373

(0, download) 0.0280432

(0, key) 0.0260565

(0, 2010) 0.024732

state 1 0

(1, offic) 0.211557

(1, instal) 0.0920019

(1, 2013) 0.057979

(1, 365) 0.0517066

(1, version) 0.0410626

(1, purchas) 0.028898

(1, home) 0.026237

(1, use) 0.0245264

(1, 2010) 0.0222455

(1, product) 0.0188242

state 1 1

(1, updat) 0.117013

(1, window) 0.0831741

(1, instal) 0.0484751

(1, #agentname#) 0.0456075

(1, hello) 0.0335632

(1, error) 0.0304088

(1, get) 0.0246734

(1, problem) 0.0212322

(1, download) 0.0209454

(1, messag) 0.0195116

state 3 0

(3, give) 0.0975515

(3, minut) 0.0942818

(3, pleas) 0.0906489

(3, check) 0.0884691

(3, let) 0.0703043

(3, thank) 0.0675796

(3, moment) 0.0523213

(3, 3) 0.0485067

(3, one) 0.0308869

(3, 5) 0.0305236

state 3 1

(3, window) 0.129853

(3, 7) 0.0926994

(3, home) 0.074722

(3, bit) 0.0595411

(3, premium) 0.0479556

(3, 64) 0.0463576

(3, vista) 0.0419631

(3, instal) 0.0351717

(3, servic) 0.0323752

(3, pack) 0.0303777

state 4 0

(4, support) 0.0786022

(4, premium) 0.0519191

(4, servic) 0.0504038

(4, #dollaramt#) 0.0501403

(4, issu) 0.0425636

(4, softwar) 0.0376882

(4, warranti) 0.035514

(4, day) 0.0312315

(4, 30) 0.0210854

(4, fix) 0.0206901

state 4 1

(4, pay) 0.0413008

(4, #dollaramt#) 0.0393345

(4, dont) 0.0325617

(4, fix) 0.0310324

(4, support) 0.0275368

(4, much) 0.0231672

(4, ok) 0.0216379

(4, cost) 0.0214194

(4, issu) 0.0192346

(4, money) 0.0192346

state 5 0

(5, thank) 0.313335

(5, #clientname#) 0.149405

(5, inform) 0.0777987

(5, wait) 0.0738004

(5, much) 0.0363618

(5, correct) 0.0243669

(5, patienc) 0.021459

(5, patient) 0.0200051

(5, #email#) 0.0156433

(5, card) 0.0138259

state 6 0

(6, comput) 0.0520198

(6, instal) 0.0475635

(6, system) 0.038489

(6, file) 0.0370306

(6, viru) 0.035248

(6, updat) 0.0345188

(6, program) 0.0290093

(6, run) 0.0215552

(6, tri) 0.0201778

(6, caus) 0.0179091

state 6 1

(6, window) 0.146467

(6, 8) 0.0713756

(6, instal) 0.0647403

(6, 7) 0.0538974

(6, comput) 0.0349627

(6, upgrad) 0.0216923

(6, laptop) 0.0199121

(6, new) 0.0189411

(6, ye) 0.0179701

(6, use) 0.0178082

state 7 0

(7, answer) 0.0739787

(7, microsoft) 0.0701565

(7, desk) 0.0603621

(7, thank) 0.0573362

(7, contact) 0.042764

(7, day) 0.0422066

(7, chat) 0.0359159

(7, great) 0.0321733

(7, session) 0.0280325

(7, com) 0.0226177

state 7 1

(7, call) 0.0779531

(7, number) 0.0643551

(7, phone) 0.0394806

(7, case) 0.0305258

(7, #time#) 0.0232293

(7, would) 0.0222343

(7, #agentname#) 0.0219027

(7, pleas) 0.021571

(7, #phoneno#) 0.0199127

(7, time) 0.0169278

state 8 0

(8, click) 0.105887

(8, right) 0.0329512

(8, pleas) 0.0285344

(8, start) 0.0279375

(8, type) 0.0272213

(8, open) 0.0236401

(8, press) 0.0205365

(8, window) 0.020059

(8, see) 0.0197009

(8, option) 0.0193427

state 8 1

(8, ok) 0.0348863

(8, click) 0.0326788

(8, internet) 0.0309129

(8, screen) 0.0262772

(8, open) 0.0238491

(8, see) 0.0236283

(8, dont) 0.0203172

(8, right) 0.0200964

(8, say) 0.0200964

(8, window) 0.0194342

state 9 1

(9, #email#) 0.244926

(9, #phoneno#) 0.240782

(9, #clientname#) 0.144641

(9, phone) 0.0414562

(9, number) 0.0298531

(9, ye) 0.0277811

(9, email) 0.0273667

(9, name) 0.0219795

(9, 4) 0.0136915

(9, cell) 0.0124484

state 10 0

(10, window) 0.155062

(10, instal) 0.0641206

(10, comput) 0.0618775

(10, 8) 0.0571107

(10, 7) 0.0501943

(10, system) 0.0422498

(10, use) 0.0337444

(10, oper) 0.0298189

(10, version) 0.0250522

(10, manufactur) 0.0186031

state 10 1

(10, updat) 0.0326156

(10, instal) 0.0297734

(10, comput) 0.0230421

(10, problem) 0.0224438

(10, ago) 0.0221446

(10, program) 0.0218454

(10, system) 0.0210975

(10, dont) 0.0209479

(10, restor) 0.0190033

(10, fix) 0.0185545

state 11 0

(11, number) 0.13071

(11, phone) 0.0902297

(11, email) 0.0720301

(11, may) 0.0627649

(11, case) 0.0584632

(11, address) 0.0581323

(11, pleas) 0.0576911

(11, name) 0.05361

(11, chat) 0.030447

(11, disconnect) 0.0212921

state 12 0

(12, issu) 0.0431294

(12, sorri) 0.0419008

(12, call) 0.0310888

(12, help) 0.0286316

(12, number) 0.0264201

(12, support) 0.0243314

(12, concern) 0.0229799

(12, #clientname#) 0.0218741

(12, #phoneno#) 0.0202769

(12, best) 0.0194169

state 12 1

(12, thank) 0.282447

(12, ok) 0.0864091

(12, help) 0.069528

(12, much) 0.0459309

(12, good) 0.0419375

(12, great) 0.0410299

(12, #agentname#) 0.0401223

(12, day) 0.0217892

(12, appreci) 0.0192479

(12, bye) 0.0179773

state 14 0

(14, comput) 0.0877508

(14, access) 0.061482

(14, remot) 0.0601575

(14, ok) 0.0432704

(14, let) 0.0359858

(14, connect) 0.0334472

(14, tri) 0.0309086

(14, issu) 0.0302464

(14, restart) 0.0281493

(14, check) 0.0224099

state 14 1

(14, ok) 0.436864

(14, ye) 0.106903

(14, thank) 0.101863

(14, pleas) 0.0313091

(14, sure) 0.0262695

(14, great) 0.0199037

(14, wait) 0.0191079

(14, oh) 0.0164555

(14, k) 0.015925

(14, let) 0.0148641

state 15 0

(15, #href#) 0.129779

(15, click) 0.118174

(15, link) 0.0862138

(15, pleas) 0.0784769

(15, code) 0.055727

(15, download) 0.0259771

(15, run) 0.0230297

(15, accept) 0.019806

(15, open) 0.0179639

(15, remot) 0.0166745

state 15 1

(15, ok) 0.100091

(15, link) 0.0744436

(15, click) 0.0557658

(15, download) 0.0376455

(15, code) 0.0292823

(15, dont) 0.0281672

(15, copi) 0.0245431

(15, #href#) 0.0242643

(15, page) 0.0237068

(15, past) 0.0237068

state 16 0

(16, anyth) 0.1478

(16, els) 0.146359

(16, welcom) 0.0844204

(16, help) 0.0792348

(16, #clientname#) 0.0754896

(16, today) 0.066847

(16, assist) 0.0518665

(16, question) 0.0233458

(16, would) 0.0193126

(16, answer) 0.0161437

state 19 0

(19, issu) 0.0736645

(19, troubleshoot) 0.0553393

(19, support) 0.0440807

(19, step) 0.0358164

(19, link) 0.0340198

(19, fix) 0.0339001

(19, help) 0.0325826

(19, resolv) 0.0285103

(19, advanc) 0.0240787

(19, option) 0.0230008

0.018599

0.0175358

0.0162186

0.015441

0.0149967

0.0147745

0.0147745

0.0143936

0.0138858

0.0127432

0.0122989

0.0113943

0.0107436

0.0106643

0.00910909

0.00833148

0.00761735

0.0072841

0.00674453

0.0063954

0.00631606

0.00625258

0.00609388

0.00590345

0.00579236

0.00576062

0.00569715

0.00568128

0.00518932

0.00509411

0.0050465

0.0048878

0.00453867

0.00439585

0.00412607

0.00407846

0.00403085

0.00403085

0.00382455

0.00377694
0.00366585

0.0035389

0.0035389

0.0035389

0.00349129

0.00342781

0.00326911

0.00326911

0.00325325

0.00318977

0.0031739

0.00307868

0.00299933

0.00296759

0.00284064

0.00277716

0.00276129

0.00266607

0.00266607

0.0026502

0.00261847

0.00255499

0.00255499

0.00250738

Figure 6: Part of flowchart on Tech-
Support dataset, generated by LM-HMM
model with T = 20 states. Cyan blocks
are system actions and yellow blocks are
user responses. In every block, the upper
cell shows the top ranked words, and the
lower cell shows example word sequences
or string patterns of that state. Transition
probability cut-off is 0.05. States are la-
belled manually. A poorly-inferred state
is highlighted, which seems to conflate
the “acknowledge agent” and “resolve
problem” states, and TM-HMMSS model
has properly disentangled (Figure 5).

the baseline models. For BusTime data, all
models perform relatively well except LM-HMM
which only indicates weak correlations. TM-
HMM out-performs all other models under all set-
tings. This is also true for TechSupport dataset.
LM-HMMS, TM-HMMS and TM-HMMSS mod-
els perform considerably well on BusTime, but
not on TechSupport data. These three models al-

low words to be generated from additional sources
other than states. Although this improves log like-
lihood, it is possible these models encode less in-
formation about the state sequences, at least in
the more diffuse TechSupport data. In summary,
under both quantitative evaluation measures, our
models advance state-of-the-art, however which of
our models is best depends on the application.

43



K10 K20 K30

15
00

0020
00

0025
00

00

15
00

0020
00

0025
00

00

15
00

0020
00

0025
00

00

T10
T20

T30

LM
−H

MM

LM
−H

MM
S

TM
−H

MM

TM
−H

MM
S

TM
−H

MM
SS

LM
−H

MM

LM
−H

MM
S

TM
−H

MM

TM
−H

MM
S

TM
−H

MM
SS

LM
−H

MM

LM
−H

MM
S

TM
−H

MM

TM
−H

MM
S

TM
−H

MM
SS

model

ne
ga

tiv
e 

lo
g 

lik
el

ih
oo

d

K10 K20 K30

6e
+0

57e
+0

58e
+0

5

6e
+0

57e
+0

58e
+0

5

6e
+0

57e
+0

58e
+0

5

T10
T20

T30

LM
−H

MM

LM
−H

MM
S

TM
−H

MM

TM
−H

MM
S

TM
−H

MM
SS

LM
−H

MM

LM
−H

MM
S

TM
−H

MM

TM
−H

MM
S

TM
−H

MM
SS

LM
−H

MM

LM
−H

MM
S

TM
−H

MM

TM
−H

MM
S

TM
−H

MM
SS

model

ne
ga

tiv
e 

lo
g 

lik
el

ih
oo

d

Figure 7: Negative log likelihood on BusTime (upper) and TechSupport (lower) datasets (smaller is better)
under different settings of topics K and states T .

K10 K20 K30

0.
0

0.
5

1.
0

0.
0

0.
5

1.
0

0.
0

0.
5

1.
0

T
10

T
20

T
30

0 25 50 75 100 0 25 50 75 100 0 25 50 75 100
# of random permutations

av
er

ag
e 

ke
nd

al
l's

 ta
u

model LM−HMM LM−HMMS TM−HMM TM−HMMS TM−HMMSS

K10 K20 K30

0.
0

0.
5

1.
0

0.
0

0.
5

1.
0

0.
0

0.
5

1.
0

T
10

T
20

T
30

0 25 50 75 100 0 25 50 75 100 0 25 50 75 100
# of random permutations

av
er

ag
e 

ke
nd

al
l's

 ta
u

model LM−HMM LM−HMMS TM−HMM TM−HMMS TM−HMMSS

Figure 8: Average Kendall’s τ measure on BusTime (upper) and TechSupport (lower) datasets (larger is
better) against number of random permutations, under various settings of topics K and states T .

5 Conclusion and Future Work

We have presented three new unsupervised mod-
els to discover latent structures in task-oriented
dialogues. We evaluated on two very different
corpora—logs from spoken, human-computer dia-
logues about bus time, and logs of textual, human-
human dialogues about technical support. We
have shown our models yield superior perfor-
mance both qualitatively and quantitatively.

One possible avenue for future work is scala-
bility. Parallelization (Asuncion et al., 2012) or
online learning (Doucet et al., 2001) could signif-

icantly speed up inference. In addition to MCMC,
another class of inference method is variational
Bayesian analysis (Blei et al., 2003; Beal, 2003),
which is inherently easier to distribute (Zhai et al.,
2012) and online update (Hoffman et al., 2010).

Acknowledgments

We would like to thank anonymous reviewers and
Jordan Boyd-Graber for their valuable comments.
We are also grateful to Alan Ritter and Bill Dolan
for their helpful discussions; and Kai (Anthony)
Lui for providing TechSupport dataset.

44



References
Arthur Asuncion, Padhraic Smyth, Max Welling,

David Newman, Ian Porteous, and Scott Triglia,
2012. Distributed Gibbs sampling for latent vari-
able models.

Satanjeev Banerjee and Alexander I Rudnicky. 2006.
A texttiling based approach to topic boundary detec-
tion in meetings. In INTERSPEECH.

Srinivas Bangalore, Giuseppe Di Fabbrizio, and
Amanda Stent. 2006. Learning the structure of task-
driven human-human dialogs. In ACL, Stroudsburg,
PA, USA.

Regina Barzilay and Lillian Lee. 2004. Catching the
drift: Probabilistic content models, with applications
to generation and summarization. In NAACL, pages
113–120.

Matthew J. Beal. 2003. Variational Algorithms for Ap-
proximate Bayesian Inference. Ph.D. thesis.

Alan W Black, Susanne Burger, Alistair Conkie,
Helen Hastie, Simon Keizer, Nicolas Merigaud,
Gabriel Parent, Gabriel Schubiner, Blaise Thomson,
D. Williams, Kai Yu, Steve Young, and Maxine Es-
kenazi. 2010. Spoken dialog challenge 2010: Com-
parison of live and control test results. In SIGDIAL.

David M. Blei, Andrew Ng, and Michael Jordan. 2003.
Latent Dirichlet allocation. JMLR.

Ananlada Chotimongkol. 2008. Learning the Struc-
ture of Task-oriented Conversations from the Corpus
of In-domain Dialogs. Ph.D. thesis.

Nigel Crook, Ramn Granell, and Stephen G. Pulman.
2009. Unsupervised classification of dialogue acts
using a dirichlet process mixture model. In SIG-
DIAL.

Hal Daumé III and Daniel Marcu. 2006. Bayesian
query-focused summarization. In ACL-44: Pro-
ceedings of the 21st International Conference on
Computational Linguistics and the 44th annual
meeting of the Association for Computational Lin-
guistics, pages 305–312, Morristown, NJ, USA. As-
sociation for Computational Linguistics.

David DeVault, Kallirroi Georgila, Ron Artstein, Fab-
rizio Morbini, David Traum, Stefan Scherer, Albert
Rizzo, and Louis-Philippe Morency. 2013. Verbal
indicators of psychological distress in interactive di-
alogue with a virtual human. In SIGDIAL.

Arnaud Doucet, Nando De Freitas, and Neil Gordon,
editors. 2001. Sequential Monte Carlo methods in
practice. Springer Texts in Statistics.

Michel Galley, Kathleen McKeown, Eric Fosler-
Lussier, and Hongyan Jing. 2003. Discourse seg-
mentation of multi-party conversation. In ACL.

Sharon Goldwater and Thomas L. Griffiths. 2007.
A fully Bayesian approach to unsupervised part-of-
speech tagging. In ACL.

Thomas L. Griffiths and Mark Steyvers. 2004. Finding
scientific topics. PNAS, 101(Suppl 1):5228–5235.

James Henderson and Oliver Lemon. 2008. Mixture
model POMDPs for efficient handling of uncertainty
in dialogue management. In ACL.

Matthew Hoffman, David M. Blei, and Francis Bach.
2010. Online learning for latent Dirichlet allocation.
In NIPS.

Pei-yun Hsueh, Johanna D. Moore, and Steve Renals.
2006. Automatic segmentation of multiparty dia-
logue. In EACL.

Lluı́s F. Hurtado, Joaquin Planells, Encarna Segarra,
Emilio Sanchis, and David Griol. 2010. A stochas-
tic finite-state transducer approach to spoken dialog
management. In INTERSPEECH.

Dan Jurafsky, Elizabeth Shriberg, and Debra Bi-
asca. 1997. Switchboard SWBD-DAMSL shallow-
discourse-function annotation coders manual. Insti-
tute of Cognitive Science Technical Report, pages
97–02.

Maurice G. Kendall. 1938. A new measure of rank
correlation. Biometrika Trust.

Staffan Larsson and David R. Traum. 2000. Informa-
tion state and dialogue management in the TRINDI
dialogue move engine toolkit. Natural Language
Engineering, 5(3/4):323–340.

Esther Levin, Roberto Pieraccini, and Wieland Eckert.
2000. A stochastic model of human-machine inter-
action for learning dialogue strategies. IEEE Trans
on Speech and Audio Processing, 8(1):11–23.

Jingjing Liu, Stephanie Seneff, and Victor Zue. 2010.
Dialogue-oriented review summary generation for
spoken dialogue recommendation systems. In
NAACL.

David Mimno, Hanna Wallach, Jason Naradowsky,
David Smith, and Andrew McCallum. 2009.
Polylingual topic models. In EMNLP.

Gabriel Murray, Steve Renals, and Jean Carletta. 2005.
Extractive summarization of meeting recordings. In
European Conference on Speech Communication
and Technology.

Radford M. Neal. 2000. Markov chain sampling meth-
ods for Dirichlet process mixture models. Journal of
Computational and Graphical Statistics, 9(2):249–
265.

Radford M. Neal. 2003. Slice sampling. Annals of
Statistics, 31:705–767.

45



Matthew Purver, Konrad Körding, Thomas L. Griffiths,
and Joshua Tenenbaum. 2006. Unsupervised topic
modelling for multi-party spoken discourse. In ACL.

Verena Rieser and Oliver Lemon. 2010. Natural lan-
guage generation as planning under uncertainty for
spoken dialogue systems. In EMNLP.

Alan Ritter, Colin Cherry, and Bill Dolan. 2010. Un-
supervised modeling of twitter conversations. In
NAACL.

Satinder Singh, Diane Litman, Michael Kearns, and
Marilyn Walker. 2002. Optimizing dialogue man-
agement with reinforcement learning: Experiments
with the NJFun system. Journal of Artificial Intelli-
gence Research.

Andreas Stolcke, Noah Coccaro, Rebecca Bates, Paul
Taylor, Carol Van Ess-Dykema, Klaus Ries, Eliza-
beth Shriberg, Daniel Jurafsky, Rachel Martin, and
Marie Meteer. 2000. Dialogue act modeling for
automatic tagging and recognition of conversational
speech. Computational Linguistics, September.

David R Traum and Staffan Larsson. 2003. The in-
formation state approach to dialogue management.
In Current and new directions in discourse and dia-
logue, pages 325–353.

Hanna M. Wallach, Iain Murray, Ruslan Salakhutdinov,
and David Mimno. 2009. Evaluation methods for
topic models. In ICML.

Hanna M. Wallach. 2008. Structured Topic Models for
Language. Ph.D. thesis, University of Cambridge.

Jason D. Williams and Suhrid Balakrishnan. 2009. Es-
timating probability of correctness for ASR N-best
lists. In SIGDIAL.

Jason D. Williams. 2012. Challenges and opportuni-
ties for state tracking in statistical spoken dialog sys-
tems: Results from two public deployments. Jour-
nal of Selected Topics in Signal Processing.

Tae Yano, William W. Cohen, and Noah A. Smith.
2009. Predicting response to political blog posts
with topic models. In NAACL, pages 477–485,
Stroudsburg, PA, USA. ACL.

Steve Young. 2006. Using POMDPs for dialog man-
agement. In Proceedings of the 1st IEEE/ACL Work-
shop on Spoken Language Technologies (SLT06).

Ke Zhai, Jordan Boyd-Graber, Nima Asadi, and Mo-
hamad Alkhouja. 2012. Mr. LDA: A flexible large
scale topic modeling package using variational in-
ference in mapreduce. In WWW.

46


