










































Computing Weakest Readings


Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 30–39,
Uppsala, Sweden, 11-16 July 2010. c©2010 Association for Computational Linguistics

Computing weakest readings

Alexander Koller
Cluster of Excellence
Saarland University

koller@mmci.uni-saarland.de

Stefan Thater
Dept. of Computational Linguistics

Saarland University
stth@coli.uni-saarland.de

Abstract

We present an efficient algorithm for com-
puting the weakest readings of semantically
ambiguous sentences. A corpus-based eval-
uation with a large-scale grammar shows
that our algorithm reduces over 80% of sen-
tences to one or two readings, in negligible
runtime, and thus makes it possible to work
with semantic representations derived by
deep large-scale grammars.

1 Introduction

Over the past few years, there has been consid-
erable progress in the ability of manually created
large-scale grammars, such as the English Resource
Grammar (ERG, Copestake and Flickinger (2000))
or the ParGram grammars (Butt et al., 2002), to
parse wide-coverage text and assign it deep seman-
tic representations. While applications should ben-
efit from these very precise semantic representa-
tions, their usefulness is limited by the presence
of semantic ambiguity: On the Rondane Treebank
(Oepen et al., 2002), the ERG computes an aver-
age of several million semantic representations for
each sentence, even when the syntactic analysis is
fixed. The problem of appropriately selecting one
of them to work with would ideally be solved by
statistical methods (Higgins and Sadock, 2003) or
knowledge-based inferences. However, no such
approach has been worked out in sufficient detail to
support the disambiguation of treebank sentences.

As an alternative, Bos (2008) proposes to com-
pute the weakest reading of each sentence and then
use it instead of the “true” reading of the sentence.
This is based on the observation that the readings
of a semantically ambiguous sentence are partially
ordered with respect to logical entailment, and the
weakest readings – the minimal (least informative)
readings with respect to this order – only express
“safe” information that is common to all other read-

ings as well. However, when a sentence has mil-
lions of readings, finding the weakest reading is a
hard problem. It is of course completely infeasible
to compute all readings and compare all pairs for
entailment; but even the best known algorithm in
the literature (Gabsdil and Striegnitz, 1999) is only
an optimization of this basic strategy, and would
take months to compute the weakest readings for
the sentences in the Rondane Treebank.

In this paper, we propose a new, efficient ap-
proach to the problem of computing weakest read-
ings. We follow an underspecification approach
to managing ambiguity: Rather than deriving all
semantic representations from the syntactic analy-
sis, we work with a single, compact underspecified
semantic representation, from which the semantic
representations can then be extracted by need. We
then approximate entailment with a rewrite sys-
tem that rewrites readings into logically weaker
readings; the weakest readings are exactly those
readings that cannot be rewritten into some other
reading any more (the relative normal forms). We
present an algorithm that computes the relative nor-
mal forms, and evaluate it on the underspecified de-
scriptions that the ERG derives on a 624-sentence
subcorpus of the Rondane Treebank. While the
mean number of scope readings in the subcorpus
is in the millions, our system computes on average
4.5 weakest readings for each sentence, in less than
twenty milliseconds; over 80% of all sentences are
reduced to at most two weakest readings. In other
words, we make it feasible for the first time to build
an application that uses the individual (weakest)
semantic representations computed by the ERG,
both in terms of the remaining ambiguity and in
terms of performance. Our technique is not lim-
ited to the ERG, but should be applicable to other
underspecification-based grammars as well.

Technically, we use underspecified descriptions
that are regular tree grammars derived from dom-
inance graphs (Althaus et al., 2003; Koller et al.,

30



2008). We compute the weakest readings by in-
tersecting these grammars with other grammars
representing the rewrite rules. This approach can
be used much more generally than just for the com-
putation of weakest readings; we illustrate this by
showing how a more general version of the redun-
dancy elimination algorithm by Koller et al. (2008)
can be seen as a special case of our construction.
Thus our system can serve as a general framework
for removing unintended readings from an under-
specified representation.

The paper is structured as follows. Section 2
starts by reviewing related work. We recall domi-
nance graphs, regular tree grammars, and the basic
ideas of underspecification in Section 3, before we
show how to compute weakest readings (Section 4)
and logical equivalences (Section 5). In Section 6,
we define a weakening rewrite system for the ERG
and evaluate it on the Rondane Treebank. Section 7
concludes and points to future work.

2 Related work

The idea of deriving a single approximative seman-
tic representation for ambiguous sentences goes
back to Hobbs (1983); however, Hobbs only works
his algorithm out for a restricted class of quantifiers,
and his representations can be weaker than our
weakest readings. Rules that weaken one reading
into another were popular in the 1990s underspeci-
fication literature (Reyle, 1995; Monz and de Rijke,
2001; van Deemter, 1996) because they simplify
logical reasoning with underspecified representa-
tions. From a linguistic perspective, Kempson and
Cormack (1981) even go so far as to claim that
the weakest reading should be taken as the “basic”
reading of a sentence, and the other readings only
seen as pragmatically licensed special cases.

The work presented here is related to other ap-
proaches that reduce the set of readings of an un-
derspecified semantic representation (USR). Koller
and Niehren (2000) showed how to strengthen
a dominance constraint using information about
anaphoric accessibility; later, Koller et al. (2008)
presented and evaluated an algorithm for redun-
dancy elimination, which removes readings from
an USR based on logical equivalence. Our system
generalizes the latter approach and applies it to a
new inference problem (weakest readings) which
they could not solve.

This paper builds closely upon Koller and Thater
(2010), which lays the formal groundwork for the

∀x

sampley

seex,y

∃y

repr-ofx,z

∃z

compz

24 3

5 6 7

8

¬1

Figure 1: A dominance graph describing the five
readings of the sentence “it is not the case that
every representative of a company saw a sample.”

work presented here. Here we go beyond that paper
by applying a concrete implementation of our RTG
construction for weakest readings to a real-world
grammar, evaluating the system on practical inputs,
and combining weakest readings with redundancy
elimination.

3 Underspecification

This section briefly reviews two formalisms for
specifying sets of trees: dominance graphs and
regular tree grammars. Both of these formalisms
can be used to model scope ambiguities compactly
by regarding the semantic representations of a sen-
tence as trees. Some example trees are shown in
Fig. 2. These trees can be read as simplified for-
mulas of predicate logic, or as formulas involv-
ing generalized quantifiers (Barwise and Cooper,
1981). Formally, we assume a ranked signature
Σ of tree constructors { f ,g,a, . . .}, each of which
is equipped with an arity ar( f ) ≥ 0. We take a
(finite constructor) tree t as a finite tree in which
each node is labelled with a symbol of Σ, and the
number of children of the node is exactly the arity
of this symbol. For instance, the signature of the
trees in Fig. 1 is {∀x|2,∃y|2,compz|0, . . .}. Finite
constructor trees can be seen as ground terms over
Σ that respect the arities. We write T (Σ) for the
finite constructor trees over Σ.

3.1 Dominance graphs
A (labelled) dominance graph D (Althaus et al.,
2003) is a directed graph that consists of a col-
lection of trees called fragments, plus dominance
edges relating nodes in different fragments. We dis-
tinguish the roots WD of the fragments from their
holes, which are the unlabelled leaves. We write
LD : WD→ Σ for the labeling function of D.

The basic idea behind using dominance graphs
to model scope underspecification is to specify

31



(a) (b)

∃y

∀x

repr-ofx,z

compz

sampley

seex,y

¬

repr-ofx,zcompz

seex,y

sampley
∃z

¬
∃y

∀x

∃z

[+]

[-]

[-] [-]

[-] [-]

[-]

[-]

[+]

[+]

[-] [-]

[-][+]

[+] [+]

(c)

compz

repr-ofx,z seex,y

sampley

¬

∃y

∀x

∃z

[+]

[-]

[-] [-]

[-]

[-]

[-]

[+]

(e)

sampley seex,yrepr-ofx,zcompz

¬

∃y

∀x

∃z

[+]

[-]

[+] [-]

[-][-][+][+]

(d)

compz
repr-ofx,z 

seex,y sampley

¬

∃y

∀x

∃z

[+]

[-]

[-] [-]

[-]

[-][-]

[+]

Figure 2: The five configurations of the dominance graph in Fig. 1.

the “semantic material” common to all readings
as fragments, plus dominance relations between
these fragments. An example dominance graph
D is shown in Fig. 1. It represents the five read-
ings of the sentence “it is not the case that every
representative of a company saw a sample.”

Each reading is encoded as a (labeled) configura-
tion of the dominance graph, which can be obtained
by “plugging” the tree fragments into each other,
in a way that respects the dominance edges: The
source node of each dominance edge must dom-
inate (be an ancestor of) the target node in each
configuration. The trees in Fig. 2 are the five la-
beled configurations of the example graph.

3.2 Regular tree grammars

Regular tree grammars (RTGs) are a general gram-
mar formalism for describing languages of trees
(Comon et al., 2007). An RTG is a 4-tuple G =
(S,N,Σ,P), where N and Σ are nonterminal and ter-
minal alphabets, S ∈ N is the start symbol, and
P is a finite set of production rules. Unlike in
context-free string grammars (which look super-
ficially the same), the terminal symbols are tree
constructors from Σ. The production rules are of
the form A→ t, where A is a nonterminal and t is a
tree from T (Σ∪N); nonterminals count as having
arity zero, i.e. they must label leaves. A derivation
starts with a tree containing a single node labeled
with S. Then in each step of the derivation, some
leaf u which is labelled with a nonterminal A is
expanded with a rule A→ t; this results in a new
tree in which u has been replaced by t, and the
derivation proceeds with this new tree. The lan-
guage L(G) generated by the grammar is the set of
all trees in T (Σ) that can be derived in this way.

Fig. 3 shows an RTG as an example. This gram-
mar uses sets of root names from D as nonterminal
symbols, and generates exactly the five configura-
tions of the graph in Fig. 1.

The languages that can be accepted by regular
tree grammars are called regular tree languages

{1,2,3,4,5,6,7,8}→ ¬({2,3,4,5,6,7,8})
{2,3,4,5,6,7,8}→ ∀x({4,5,6},{3,7,8})
{2,3,4,5,6,7,8}→ ∃y({7},{2,4,5,6,8})
{2,3,4,5,6,7,8}→ ∃z({5},{2,3,6,7,8})
{2,4,5,6,8}→ ∀x({4,5,6},{8})

| ∃z({5},{2,6,8})
{2,3,6,7,8}→ ∀x({6},{3,7,8})

| ∃y({7},{2,6,8})
{2,6,8}→ ∀x({6},{8})
{3,7,8}→ ∃y({7},{8})
{4,5,6}→ ∃z({5},{6})

{5}→ compz {7}→ sampley
{6}→ repr-ofx,z {8}→ seex,y

Figure 3: A regular tree grammar that generates
the five trees in Fig. 2.

(RTLs), and regular tree grammars are equivalent
to finite tree automata, which are defined essen-
tially like the well-known finite string automata,
except that they assign states to the nodes in a tree
rather than the positions in a string. Regular tree
languages enjoy many of the closure properties of
regular string languages. In particular, we will later
exploit that RTLs are closed under intersection and
complement.

3.3 Dominance graphs as RTGs

An important class of dominance graphs are hy-
pernormally connected (hnc) dominance graphs
(Koller et al., 2003). The precise definition of hnc
graphs is not important here, but note that virtually
all underspecified descriptions that are produced
by current grammars are hypernormally connected
(Flickinger et al., 2005), and we will restrict our-
selves to hnc graphs for the rest of the paper.

Every hypernormally connected dominance
graph D can be automatically translated into an
equivalent RTG GD that generates exactly the same
configurations (Koller et al., 2008); the RTG in
Fig. 3 is an example. The nonterminals of GD are

32



always hnc subgraphs of D. In the worst case, GD
can be exponentially bigger than D, but in practice
it turns out that the grammar size remains manage-
able: even the RTG for the most ambiguous sen-
tence in the Rondane Treebank, which has about
4.5× 1012 scope readings, has only about 75 000
rules and can be computed in a few seconds.

4 Computing weakest readings

Now we are ready to talk about computing the
weakest readings of a hypernormally connected
dominance graph. We will first explain how we ap-
proximate logical weakening with rewrite systems.
We will then discuss how weakest readings can be
computed efficiently as the relative normal forms
of these rewrite systems.

4.1 Weakening rewrite systems

The different readings of a sentence with a scope
ambiguity are not a random collection of formulas;
they are partially ordered with respect to logical
entailment, and are structurally related in a way
that allows us to model this entailment relation
with simpler technical means.

To illustrate this, consider the five configurations
in Fig. 2. The formula represented by (d) logically
entails (c); we say that (c) is a weaker reading than
(d) because it is satisfied by more models. Similar
entailment relations hold between (d) and (e), (e)
and (b), and so on (see also Fig. 5). We can define
the weakest readings of the dominance graph as
the minimal elements of the entailment order; in
the example, these are (b) and (c). Weakest read-
ings capture “safe” information in that whichever
reading of the sentence the speaker had in mind,
any model of this reading also satisfies at least one
weakest reading; in the absence of convincing dis-
ambiguation methods, they can therefore serve as
a practical approximation of the intended meaning
of the sentence.

A naive algorithm for computing weakest read-
ings would explicitly compute the entailment order,
by running a theorem prover on each pair of config-
urations, and then pick out the minimal elements.
But this algorithm is quadratic in the number of
configurations, and therefore impractically slow
for real-life sentences.

Here we develop a fast algorithm for this prob-
lem. The fundamental insight we exploit is that
entailment among the configurations of a domi-
nance graph can be approximated with rewriting

rules (Baader and Nipkow, 1999). Consider the re-
lation between (d) and (c). We can explain that (d)
entails (c) by observing that (c) can be built from
(d) by exchanging the positions of the adjacent
quantifiers ∀x and ∃y; more precisely, by applying
the following rewrite rule:

[−] ∀x(Q,∃y(P,R))→∃y(P,∀x(Q,R)) (1)

The body of the rule specifies that an occurrence of
∀x which is the direct parent of an occurrence of ∃y
may change positions with it; the subformulas P,
Q, and R must be copied appropriately. The annota-
tion [−] specifies that we must only apply the rule
to subformulas in negative logical polarity: If the
quantifiers in (d) were not in the scope of a nega-
tion, then applying the rule would actually make
the formula stronger. We say that the rule (1) is
logically sound because applying it to a subformula
with the correct polarity of some configuration t
always makes the result t ′ logically weaker than t.

We formalize these rewrite systems as follows.
We assume a finite annotation alphabet Ann with a
special starting annotation a0 ∈ Ann; in the exam-
ple, we had Ann = {+,−} and a0 = +. We also
assume an annotator function ann : Ann×Σ×N→
Ann. The function ann can be used to traverse a
tree top-down and compute the annotation of each
node from the annotation of its parent: Its first
argument is the annotation and its second argu-
ment the node label of the parent, and the third
argument is the position of the child among the par-
ent’s children. In our example, the annotator ann
models logical polarity by mapping, for instance,
ann(+,∃z,1) = ann(+,∃z,2) = ann(+,∃y,2) = +,
ann(−,∃z,1) = ann(−,∃z,2) = ann(+,∀x,1) =−,
etc. We have labelled each node of the configura-
tions in Fig. 1 with the annotations that are com-
puted in this way.

Now we can define an annotated rewrite system
R to be a finite set of pairs (a,r) where a is an anno-
tation and r is an ordinary rewrite rule. The rule (1)
above is an example of an annotated rewrite rule
with a =−. A rewrite rule (a,r) can be applied at
the node u of a tree t if ann assigns the annotation a
to u and r is applicable at u as usual. The rule then
rewrites t as described above. In other words, an-
notated rewrite systems are rewrite systems where
rule applications are restricted to subtrees with spe-
cific annotations. We write t→R t ′ if some rule of
R can be applied at a node of t, and the result of
rewriting is t ′. The rewrite system R is called linear

33



if every variable that occurs on the left-hand side
of a rule occurs on its right-hand side exactly once.

4.2 Relative normal forms
The rewrite steps of a sound weakening rewrite sys-
tem are related to the entailment order: Because ev-
ery rewrite step transforms a reading into a weaker
reading, an actual weakest readings must be such
that there is no other configuration into which it
can be rewritten. The converse is not always true,
i.e. there can be non-rewritable configurations that
are not weakest readings, but we will see in Sec-
tion 6 that this approximation is good enough for
practical use. So one way to solve the problem of
computing weakest readings is to find readings that
cannot be rewritten further.

One class of configurations that “cannot be
rewritten” with a rewrite system R is the set of nor-
mal forms of R, i.e. those configurations to which
no rule in R can be applied. In our example, (b)
and (c) are indeed normal forms with respect to
a rewrite system that consists only of the rule (1).
However, this is not exactly what we need here.
Consider a rewrite system that also contains the fol-
lowing annotated rewrite rule, which is also sound
for logical entailment:

[+] ¬(∃z(P,Q))→∃z(P,¬(Q)), (2)

This rule would allow us to rewrite
the configuration (c) into the tree
∃z(compz,¬(∃y(sampley,∀x(repr−ofx,z,seex,y)))).
But this is no longer a configuration of the graph.
If we were to equate weakest readings with normal
forms, we would erroneously classify (c) as not
being a weakest reading. The correct concept
for characterizing weakest readings in terms of
rewriting is that of a relative normal form. We
define a configuration t of a dominance graph D to
be a R-relative normal form of (the configurations
of) D iff there is no other configuration t ′ of D such
that t→R t ′. These are the configurations that can’t
be weakened further without obtaining a tree that
is no longer a configuration of D. In other words,
if R approximates entailment, then the R-relative
normal forms approximate the weakest readings.

4.3 Computing relative normal forms
We now show how the relative normal forms of a
dominance graph can be computed efficiently. For
lack of space, we only sketch the construction and
omit all proofs. Details can be found in Koller and
Thater (2010).

The key idea of the construction is to repre-
sent the relation →R in terms of a context tree
transducer M, and characterize the relative nor-
mal forms of a tree language L in terms of the
pre-image of L under M. Like ordinary regular
tree transducers (Comon et al., 2007), context tree
transducers read an input tree, assigning states to
the nodes, while emitting an output tree. But while
ordinary transducers read the input tree symbol by
symbol, a context tree transducer can read multiple
symbols at once. In this way, they are equivalent to
the extended left-hand side transducers of Graehl
et al. (2008).

We will now define context tree transducers. Let
Σ be a ranked signature, and let Xm be a set of m
variables. We write Con(m)(Σ) for the contexts with
m holes, i.e. those trees in T (Σ∪Xm) in which each
element of Xm occurs exactly once, and always
as a leaf. If C ∈ Con(m)(Σ), then C[t1, . . . , tm] =
C[t1/x1, . . . , tm/xm], where x1, . . . ,xm are the vari-
ables from left to right.

A (top-down) context tree transducer from Σ to ∆
is a 5-tuple M = (Q,Σ,∆,q0,δ ). Σ and ∆ are ranked
signatures, Q is a finite set of states, and q0 ∈ Q is
the start state. δ is a finite set of transition rules of
the form q(C[x1, . . . ,xn])→D[q1(xi1), . . . ,qm(xim)],
where C ∈ Con(n)(Σ) and D ∈ Con(m)(∆).

If t ∈ T (Σ∪∆∪Q), then we say that M derives
t ′ in one step from t, t →M t ′, if t is of the form
C′[q(C[t1, . . . , tn])] for some C′ ∈ Con(1)(Σ), t ′ is
of the form C′[D[q1(ti1), . . . ,qm(tim)]], and there is
a rule q(C[x1, . . . ,xn])→ D[q1(xi1), . . . ,qm(xim)] in
δ . The derivation relation →∗M is the reflexive,
transitive closure of→M. The translation relation
τM of M is

τM = {(t, t ′) | t ∈T (Σ) and t ′ ∈T (∆) and q0(t)→∗ t ′}.

For each linear annotated rewrite system R, we
can now build a context tree transducer MR such
that t →R t ′ iff (t, t ′) ∈ τMR . The idea is that MR
traverses t from the root to the leaves, keeping
track of the current annotation in its state. MR
can nondeterministically choose to either copy the
current symbol to the output tree unchanged, or to
apply a rewrite rule from R. The rules are built in
such a way that in each run, exactly one rewrite
rule must be applied.

We achieve this as follows. MR takes as its
states the set {q̄}∪{qa | a ∈ Ann} and as its start
state the state qa0 . If MR reads a node u in state
qa, this means that the annotator assigns annota-
tion a to u and MR will rewrite a subtree at or

34



below u. If MR reads u in state q̄, this means
that MR will copy the subtree below u unchanged
because the rewriting has taken place elsewhere.
Thus MR has three types of rewrite rules. First,
for any f ∈ Σ, we have a rule q̄( f (x1, . . . ,xn))→
f (q̄(x1), . . . , q̄(xn)). Second, for any f and
1 ≤ i ≤ n, we have a rule qa( f (x1, . . . ,xn)) →
f (q̄(x1), . . . ,qann(a, f ,i)(xi), . . . , q̄(xn)), which non-
deterministically chooses under which child the
rewriting should take place, and assigns it the
correct annotation. Finally, we have a rule
qa(C[x1, . . . ,xn])→ C′[q̄(xi1), . . . , q̄(xin)] for every
rewrite rule C[x1, . . . ,xn]→C′[xi1 , . . . ,xin ] with an-
notation a in R.

Now let’s put the different parts together. We
know that for each hnc dominance graph D, there is
a regular tree grammar GD such that L(GD) is the
set of configurations of D. Furthermore, the pre-
image τ−1M (L) = {t | exists t ′ ∈ L with (t, t ′) ∈ τM}
of a regular tree language L is also regular (Koller
and Thater, 2010) if M is linear, and regular tree
languages are closed under intersection and com-
plement (Comon et al., 2007). So we can compute
another RTG G′ such that

L(G′) = L(GD)∩ τ−1MR (L(GD)).

L(G′) consists of the members of L(GD) which
cannot be rewritten by MR into members of L(GD);
that is, L(G′) is exactly the set of R-relative normal
forms of D. In general, the complement construc-
tion requires exponential time in the size of MR and
GD. However, it can be shown that if the rules in
R have at most depth two and GD is deterministic,
then the entire above construction can be computed
in time O(|GD| · |R|) (Koller and Thater, 2010).

In other words, we have shown how to compute
the weakest readings of a hypernormally connected
dominance graph D, as approximated by a weaken-
ing rewrite system R, in time linear in the size of
GD and linear in the size of R. This is a dramatic im-
provement over the best previous algorithm, which
was quadratic in |conf(D)|.

4.4 An example
Consider an annotated rewrite system that contains
rule (1) plus the following rewrite rule:

[−] ∃z(P,∀x(Q,R))→∀x(∃z(P,Q),R) (3)

This rewrite system translates into a top-down
context tree transducer MR with the following tran-
sition rules, omitting most rules of the first two

{1,2,3,4,5,6,7,8}F →¬({2,3,4,5,6,7,8}F )
{2,3,4,5,6,7,8}F →∃y({7}{q̄},{2,4,5,6,8}F )

| ∃z({5}{q̄},{2,3,6,7,8}F )
{2,3,6,7,8}F →∃y({7}{q̄},∀x({6}{q̄},{8}{q̄}))
{2,4,5,6,8}F →∀x({4,5,6}{q̄},{8}{q̄})
{4,5,6}{q̄}→∃z({5}{q̄},{6}{q̄})
{5}{q̄}→ compz {6}{q̄}→ repr-ofx,z
{7}{q̄}→ sampley {8}{q̄}→ seex,y

Figure 4: RTG for the weakest readings of Fig. 1.

types for lack of space.

q−(∀x(x1,∃y(x2,x3)))→∃y(q̄(x2),∀x(q̄(x1), q̄(x3)))
q−(∃y(x1,∀x(x2,x3)))→∀x(∃y(q̄(x1), q̄(x2)), q̄(x3))

q̄(¬(x1))→¬(q̄(x1))
q+(¬(x1))→¬(q−(x1))

q̄(∀x(x1,x2))→∀x(q̄(x1), q̄(x2))
q+(∀x(x1,x2))→∀x(q̄(x1),q+(x2))
q+(∀x(x1,x2))→∀x(q−(x1), q̄(x2)) . . .

The grammar G′ for the relative normal forms
is shown in Fig. 4 (omitting rules that involve un-
productive nonterminals). We obtain it by starting
with the example grammar GD in Fig. 3; then com-
puting a deterministic RTG GR for τ−1MR (L(GD));
and then intersecting the complement of GR with
GD. The nonterminals of G′ are subgraphs of D,
marked either with a set of states of MR or the sym-
bol F , indicating that GR had no production rule
for a given left-hand side. The start symbol of G′

is marked with F because G′ should only gener-
ate trees that GR cannot generate. As expected, G′

generates precisely two trees, namely (b) and (c).

5 Redundancy elimination, revisited

The construction we just carried out – characterize
the configurations we find interesting as the rela-
tive normal forms of an annotated rewrite system
R, translate it into a transducer MR, and intersect
conf(D) with the complement of the pre-image un-
der MR – is more generally useful than just for the
computation of weakest readings. We illustrate this
on the problem of redundancy elimination (Vestre,
1991; Chaves, 2003; Koller et al., 2008) by show-
ing how a variant of the algorithm of Koller et al.
(2008) falls out of our technique as a special case.

Redundancy elimination is the problem of com-
puting, from a dominance graph D, another domi-
nance graph D′ such that conf(D′)⊆ conf(D) and

35



every formula in conf(D) is logically equivalent
to some formula in conf(D′). We can approximate
logical equivalence using a finite system of equa-
tions such as

∃y(P,∃z(Q,R)) = ∃z(Q,∃y(P,R)), (4)

indicating that ∃y and ∃z can be permuted without
changing the models of the formula.

Following the approach of Section 4, we can
solve the redundancy elimination problem by trans-
forming the equation system into a rewrite system
R such that t→R t ′ implies that t and t ′ are equiv-
alent. To this end, we assume an arbitrary linear
order < on Σ, and orient all equations into rewrite
rules that respect this order. If we assume ∃y < ∃z,
the example rule (4) translates into the annotated
rewrite rules

[a] ∃z(P,∃y(Q,R))→∃y(Q,∃z(P,R)) (5)

for all annotations a ∈ Ann; logical equivalence
is not sensitive to the annotation. Finally, we can
compute the relative normal forms of conf(D) un-
der this rewrite system as above. The result will be
an RTG G′ describing a subset of conf(D). Every
tree t in conf(D) that is not in L(G′) is equivalent
to some tree t ′ in L(G′), because if t could not be
rewritten into such a t ′, then t would be in rela-
tive normal form. That is, the algorithm solves the
redundancy elimination problem. Furthermore, if
the oriented rewrite system is confluent (Baader
and Nipkow, 1999), no two trees in L(G′) will be
equivalent to each other, i.e. we achieve complete
reduction in the sense of Koller et al. (2008).

This solution shares much with that of Koller et
al. (2008), in that we perform redundancy elimina-
tion by intersecting tree grammars. However, the
construction we present here is much more general:
The algorithmic foundation for redundancy elim-
ination is now exactly the same as that for weak-
est readings, we only have to use an equivalence-
preserving rewrite system instead of a weakening
one. This new formal clarity also simplifies the
specification of certain equations, as we will see in
Section 6.

In addition, we can now combine the weakening
rules (1), (3), and (5) into a single rewrite system,
and then construct a tree grammar for the relative
normal forms of the combined system. This algo-
rithm performs redundancy elimination and com-
putes weakest readings at the same time, and in our
example retains only a single configuration, namely

(5)
(e) ¬∀x(∃z,∃y) (a) ¬∃y∃z∀x(3)(1)

(1)

(b) ¬∃y∀x∃z

(c) ¬∃z∃y∀x(d) ¬∃z∀x∃y
(3)

Figure 5: Structure of the configuration set of Fig. 1
in terms of rewriting.

(b); the configuration (c) is rejected because it can
be rewritten to (a) with (5). The graph in Fig. 5 il-
lustrates how the equivalence and weakening rules
conspire to exclude all other configurations.

6 Evaluation

In this section, we evaluate the effectiveness and
efficiency of our weakest readings algorithm on
a treebank. We compute RTGs for all sentences
in the treebank and measure how many weakest
readings remain after the intersection, and how
much time this computation takes.

Resources. For our experiment, we use the Ron-
dane treebank (version of January 2006), a “Red-
woods style” (Oepen et al., 2002) treebank con-
taining underspecified representations (USRs) in
the MRS formalism (Copestake et al., 2005) for
sentences from the tourism domain.

Our implementation of the relative normal forms
algorithm is based on Utool (Koller and Thater,
2005), which (among other things) can translate a
large class of MRS descriptions into hypernormally
connected dominance graphs and further into RTGs
as in Section 3. The implementation exploits cer-
tain properties of RTGs computed from dominance
graphs to maximize efficiency. We will make this
implementation publically available as part of the
next Utool release.

We use Utool to automatically translate the 999
MRS descriptions for which this is possible into
RTGs. To simplify the specification of the rewrite
systems, we restrict ourselves to the subcorpus in
which all scope-taking operators (labels with arity
> 0) occur at least ten times. This subset contains
624 dominance graphs. We refer to this subset as
“RON10.”

Signature and annotations. For each domi-
nance graph D that we obtain by converting an
MRS description, we take GD as a grammar over
the signature Σ = { fu | u ∈WD, f = LD(u)}. That
is, we distinguish possible different occurrences
of the same symbol in D by marking each occur-

36



rence with the name of the node. This makes GD a
deterministic grammar.

We then specify an annotator over Σ that assigns
polarities for the weakening rewrite system. We
distinguish three polarities: + for positive occur-
rences, − for negative occurrences (as in predicate
logic), and ⊥ for contexts in which a weakening
rule neither weakens or strengthens the entire for-
mula. The starting annotation is +.

Finally, we need to decide upon each scope-
taking operator’s effects on these annotations. To
this end, we build upon Barwise and Cooper’s
(1981) classification of the monotonicity prop-
erties of determiners. A determiner is upward
(downward) monotonic if making the denotation of
the determiner’s argument bigger (smaller) makes
the sentence logically weaker. For instance, ev-
ery is downward monotonic in its first argument
and upward monotonic in its second argument,
i.e. every girl kissed a boy entails every blond
girl kissed someone. Thus ann(everyu,a,1) =−a
and ann(everyu,a,2) = a (where u is a node name
as above). There are also determiners with non-
monotonic argument positions, which assign the
annotation ⊥ to this argument. Negation reverses
positive and negative polarity, and all other non-
quantifiers simply pass on their annotation to the
arguments.

Weakest readings. We use the following weak-
ening rewrite system for our experiment, where
i ∈ {1,2}:

1. [+] (E/i,D/1), (D/2,D/1)

2. [+] (E/i,P/1), (D/2,P/1)

3. [+] (E/i,A/2), (D/1,A/2)

4. [+] (A/2,N/1)

5. [+] (N/1,E/i), (N/1,D/2)

6. [+] (E/i,M/1), (D/1,M/1)

Here the symbols E, D, etc. stand for classes
of labels in Σ, and a rule schema [a] (C/i,C′/k) is
to be read as shorthand for a set of rewrite rules
which rearrange a tree where the i-th child of a
symbol from C is a symbol from C′ into a tree
where the symbol from C becomes the k-th child
of the symbol from C′. For example, because we
have allu ∈ A and notv ∈ N, Schema 4 licenses the
following annotated rewrite rule:

[+] allu(P,notv(Q))→ notv(allu(P,Q)).

We write E and D for existential and definite
determiners. P stands for proper names and pro-
nouns, A stands for universal determiners like all
and each, N for the negation not, and M for modal
operators like can or would. M also includes in-
tensional verbs like have to and want. Notice that
while the reverse rules are applicable in negative
polarities, no rules are applicable in polarity ⊥.

Rule schema 1 states, for instance, that the spe-
cific (wide-scope) reading of the indefinite in the
president of a company is logically stronger than
the reading in which a company is within the re-
striction of the definite determiner. The schema is
intuitively plausible, and it can also be proved to be
logically sound if we make the standard assumption
that the definite determiner the means “exactly one”
(Montague, 1974). A similar argument applies to
rule schema 2.

Rule schema 3 encodes the classical entailment
(1). Schema 4 is similar to the rule (2). Notice
that it is not, strictly speaking, logically sound;
however, because strong determiners like all or
every carry a presupposition that their restrictions
have a non-empty denotation (Lasersohn, 1993),
the schema becomes sound for all instances that
can be expressed in natural language. Similar ar-
guments apply to rule schemas 5 and 6, which are
potentially unsound for subtle reasons involving
the logical interpretation of intensional expressions.
However, these cases of unsoundness did not occur
in our test corpus.

Redundancy elimination. In addition, we as-
sume the following equation system for redundancy
elimination for i, j ∈ {1,2} and k ∈ N (again writ-
ten in an analogous shorthand as above):

7. E/i = E/ j
8. D/1 = E/i, E/i = D/1
9. D/1 = D/1

10. Σ/k = P/2

These rule schemata state that permuting exis-
tential determiners with each other is an equiva-
lence transformation, and so is permuting definite
determiners with existential and definite determin-
ers if one determiner is the second argument (in
the scope) of a definite. Schema 10 states that
proper names and pronouns, which the ERG ana-
lyzes as scope-bearing operators, can permute with
any other label.

We orient these equalities into rewrite rules by
ordering symbols in P before symbols that are not

37



All KRT08 RE RE+WR

#conf = 1 8.5% 23.4% 34.9% 66.7%
#conf≤ 2 20.5% 40.9% 57.9% 80.6%

avg(#conf) 3.2M 7603.1 119.0 4.5
med(#conf) 25 4 2 1

runtime 8.1s 9.4s 8.7s 9.1s

Figure 6: Analysis of the numbers of configurations
in RON10.

in P, and otherwise ordering a symbol fu before a
symbol gv if u < v by comparison of the (arbitrary)
node names.

Results. We used these rewrite systems to com-
pute, for each USR in RON10, the number of all
configurations, the number of configurations that
remain after redundancy elimination, and the num-
ber of weakest readings (i.e., the relative normal
forms of the combined equivalence and weakening
rewrite systems). The results are summarized in
Fig. 6. By computing weakest readings (WR), we
reduce the ambiguity of over 80% of all sentences
to one or two readings; this is a clear improvement
even over the results of the redundancy elimina-
tion (RE). Computing weakest readings reduces
the mean number of readings from several million
to 4.5, and improves over the RE results by a factor
of 30. Notice that the RE algorithm from Section 5
is itself an improvement over Koller et al.’s (2008)
system (“KRT08” in the table), which could not
process the rule schema 10.

Finally, computing the weakest readings takes
only a tiny amount of extra runtime compared to
the RE elimination or even the computation of the
RTGs (reported as the runtime for “All”).1 This re-
mains true on the entire Rondane corpus (although
the reduction factor is lower because we have no
rules for the rare scope-bearers): RE+WR compu-
tation takes 32 seconds, compared to 30 seconds
for RE. In other words, our algorithm brings the
semantic ambiguity in the Rondane Treebank down
to practically useful levels at a mean runtime in-
vestment of a few milliseconds per sentence.

It is interesting to note how the different rule
schemas contribute to this reduction. While the
instances of Schemata 1 and 2 are applicable in 340
sentences, the other schemas 3–6 together are only

1Runtimes were measured on an Intel Core 2 Duo CPU
at 2.8 GHz, under MacOS X 10.5.6 and Apple Java 1.5.0_16,
after allowing the JVM to just-in-time compile the bytecode.

applicable in 44 sentences. Nevertheless, where
these rules do apply, they have a noticeable effect:
Without them, the mean number of configurations
in RON10 after RE+WR increases to 12.5.

7 Conclusion

In this paper, we have shown how to compute the
weakest readings of a dominance graph, charac-
terized by an annotated rewrite system. Evaluat-
ing our algorithm on a subcorpus of the Rondane
Treebank, we reduced the mean number of config-
urations of a sentence from several million to 4.5,
in negligible runtime. Our algorithm can be ap-
plied to other problems in which an underspecified
representation is to be disambiguated, as long as
the remaining readings can be characterized as the
relative normal forms of a linear annotated rewrite
system. We illustrated this for the case of redun-
dancy elimination.

The algorithm presented here makes it possible,
for the first time, to derive a single meaningful se-
mantic representation from the syntactic analysis
of a deep grammar on a large scale. In the future,
it will be interesting to explore how these semantic
representations can be used in applications. For in-
stance, it seems straightforward to adapt MacCart-
ney and Manning’s (2008) “natural logic”-based
Textual Entailment system, because our annotator
already computes the polarities needed for their
monotonicity inferences. We could then perform
such inferences on (cleaner) semantic representa-
tions, rather than strings (as they do).

On the other hand, it may be possible to re-
duce the set of readings even further. We retain
more readings than necessary in many treebank sen-
tences because the combined weakening and equiv-
alence rewrite system is not confluent, and there-
fore may not recognize a logical relation between
two configurations. The rewrite system could be
made more powerful by running the Knuth-Bendix
completion algorithm (Knuth and Bendix, 1970).
Exploring the practical tradeoff between the further
reduction in the number of remaining configura-
tions and the increase in complexity of the rewrite
system and the RTG would be worthwhile.

Acknowledgments. We are indebted to Joachim
Niehren, who pointed out a crucial simplification
in the algorithm to us. We also thank our reviewers
for their constructive comments.

38



References
E. Althaus, D. Duchier, A. Koller, K. Mehlhorn,

J. Niehren, and S. Thiel. 2003. An efficient graph
algorithm for dominance constraints. Journal of Al-
gorithms, 48:194–219.

F. Baader and T. Nipkow. 1999. Term rewriting and all
that. Cambridge University Press.

J. Barwise and R. Cooper. 1981. Generalized quanti-
fiers and natural language. Linguistics and Philoso-
phy, 4:159–219.

J. Bos. 2008. Let’s not argue about semantics. In
Proceedings of the 6th international conference on
Language Resources and Evaluation (LREC 2008).

M. Butt, H. Dyvik, T. Holloway King, H. Masuichi,
and C. Rohrer. 2002. The parallel grammar
project. In Proceedings of COLING-2002 Workshop
on Grammar Engineering and Evaluation.

R. P. Chaves. 2003. Non-redundant scope disambigua-
tion in underspecified semantics. In Proceedings of
the 8th ESSLLI Student Session.

H. Comon, M. Dauchet, R. Gilleron, C. Löding,
F. Jacquemard, D. Lugiez, S. Tison, and M. Tom-
masi. 2007. Tree automata techniques and appli-
cations. Available on: http://www.grappa.
univ-lille3.fr/tata.

A. Copestake and D. Flickinger. 2000. An open-
source grammar development environment and
broad-coverage english grammar using HPSG. In
Proceedings of the 2nd International Conference on
Language Resources and Evaluation (LREC).

A. Copestake, D. Flickinger, C. Pollard, and I. Sag.
2005. Minimal recursion semantics: An introduc-
tion. Journal of Language and Computation.

D. Flickinger, A. Koller, and S. Thater. 2005. A new
well-formedness criterion for semantics debugging.
In Proceedings of the 12th International Conference
on HPSG, Lisbon.

M. Gabsdil and K. Striegnitz. 1999. Classifying scope
ambiguities. In Proceedings of the First Intl. Work-
shop on Inference in Computational Semantics.

J. Graehl, K. Knight, and J. May. 2008. Training tree
transducers. Computational Linguistics, 34(3):391–
427.

D. Higgins and J. Sadock. 2003. A machine learning
approach to modeling scope preferences. Computa-
tional Linguistics, 29(1).

J. Hobbs. 1983. An improper treatment of quantifi-
cation in ordinary English. In Proceedings of the
21st Annual Meeting of the Association for Compu-
tational Linguistics (ACL’83).

R. Kempson and A. Cormack. 1981. Ambiguity and
quantification. Linguistics and Philosophy, 4:259–
309.

D. Knuth and P. Bendix. 1970. Simple word problems
in universal algebras. In J. Leech, editor, Computa-
tional Problems in Abstract Algebra, pages 263–297.
Pergamon Press, Oxford.

A. Koller and J. Niehren. 2000. On underspecified
processing of dynamic semantics. In Proceedings of
the 18th International Conference on Computational
Linguistics (COLING-2000).

A. Koller and S. Thater. 2005. Efficient solving and ex-
ploration of scope ambiguities. In ACL-05 Demon-
stration Notes, Ann Arbor.

A. Koller and S. Thater. 2010. Computing relative nor-
mal forms in regular tree languages. In Proceedings
of the 21st International Conference on Rewriting
Techniques and Applications (RTA).

A. Koller, J. Niehren, and S. Thater. 2003. Bridg-
ing the gap between underspecification formalisms:
Hole semantics as dominance constraints. In Pro-
ceedings of the 10th EACL.

A. Koller, M. Regneri, and S. Thater. 2008. Regular
tree grammars as a formalism for scope underspeci-
fication. In Proceedings of ACL-08: HLT.

P. Lasersohn. 1993. Existence presuppositions and
background knowledge. Journal of Semantics,
10:113–122.

B. MacCartney and C. Manning. 2008. Modeling
semantic containment and exclusion in natural lan-
guage inference. In Proceedings of the 22nd Inter-
national Conference on Computational Linguistics
(COLING).

R. Montague. 1974. The proper treatment of quantifi-
cation in ordinary English. In R. Thomason, editor,
Formal Philosophy. Selected Papers of Richard Mon-
tague. Yale University Press, New Haven.

C. Monz and M. de Rijke. 2001. Deductions with
meaning. In Michael Moortgat, editor, Logical As-
pects of Computational Linguistics, Third Interna-
tional Conference (LACL’98), volume 2014 of LNAI.
Springer-Verlag, Berlin/Heidelberg.

S. Oepen, K. Toutanova, S. Shieber, C. Manning,
D. Flickinger, and T. Brants. 2002. The LinGO
Redwoods treebank: Motivation and preliminary
applications. In Proceedings of the 19th Inter-
national Conference on Computational Linguistics
(COLING).

Uwe Reyle. 1995. On reasoning with ambiguities. In
Proceedings of the 7th Conference of the European
Chapter of the Association for Computational Lin-
guistics (EACL’95).

K. van Deemter. 1996. Towards a logic of ambiguous
expressions. In Semantic Ambiguity and Underspec-
ification. CSLI Publications, Stanford.

E. Vestre. 1991. An algorithm for generating non-
redundant quantifier scopings. In Proc. of EACL,
Berlin.

39


