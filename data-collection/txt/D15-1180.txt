



















































Molding CNNs for text: non-linear, non-consecutive convolutions


Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, pages 1565–1575,
Lisbon, Portugal, 17-21 September 2015. c©2015 Association for Computational Linguistics.

Molding CNNs for text: non-linear, non-consecutive convolutions

Tao Lei, Regina Barzilay, and Tommi Jaakkola
Computer Science and Artificial Intelligence Laboratory

Massachusetts Institute of Technology
{taolei, regina, tommi}@csail.mit.edu

Abstract

The success of deep learning often de-
rives from well-chosen operational build-
ing blocks. In this work, we revise the
temporal convolution operation in CNNs
to better adapt it to text processing. In-
stead of concatenating word representa-
tions, we appeal to tensor algebra and use
low-rank n-gram tensors to directly exploit
interactions between words already at the
convolution stage. Moreover, we extend
the n-gram convolution to non-consecutive
words to recognize patterns with interven-
ing words. Through a combination of low-
rank tensors, and pattern weighting, we
can efficiently evaluate the resulting con-
volution operation via dynamic program-
ming. We test the resulting architecture on
standard sentiment classification and news
categorization tasks. Our model achieves
state-of-the-art performance both in terms
of accuracy and training speed. For in-
stance, we obtain 51.2% accuracy on the
fine-grained sentiment classification task.1

1 Introduction

Deep learning methods and convolutional neural
networks (CNNs) among them have become de
facto top performing techniques across a range
of NLP tasks such as sentiment classification,
question-answering, and semantic parsing. As
methods, they require only limited domain knowl-
edge to reach respectable performance with in-
creasing data and computation, yet permit easy
architectural and operational variations so as to
fine tune them to specific applications to reach top
performance. Indeed, their success is often con-
tingent on specific architectural and operational
choices.

1Our code and data are available at https://github.
com/taolei87/text_convnet

CNNs for text applications make use of tem-
poral convolution operators or filters. Similar
to image processing, they are applied at multi-
ple resolutions, interspersed with non-linearities
and pooling. The convolution operation itself is
a linear mapping over “n-gram vectors” obtained
by concatenating consecutive word (or character)
representations. We argue that this basic build-
ing block can be improved in two important re-
spects. First, the power of n-grams derives pre-
cisely from multi-way interactions and these are
clearly missed (initially) with linear operations on
stacked n-gram vectors. Non-linear interactions
within a local context have been shown to improve
empirical performance in various tasks (Mitchell
and Lapata, 2008; Kartsaklis et al., 2012; Socher
et al., 2013). Second, many useful patterns are
expressed as non-consecutive phrases, such as se-
mantically close multi-word expressions (e.g.,“not
that good”, “not nearly as good”). In typical
CNNs, such expressions would have to come to-
gether and emerge as useful patterns after several
layers of processing.

We propose to use a feature mapping operation
based on tensor products instead of linear opera-
tions on stacked vectors. This enables us to di-
rectly tap into non-linear interactions between ad-
jacent word feature vectors (Socher et al., 2013;
Lei et al., 2014). To offset the accompanying
parametric explosion we maintain a low-rank rep-
resentation of the tensor parameters. Moreover,
we show that this feature mapping can be applied
to all possible non-consecutive n-grams in the se-
quence with an exponentially decaying weight de-
pending on the length of the span. Owing to the
low rank representation of the tensor, this oper-
ation can be performed efficiently in linear time
with respect to the sequence length via dynamic
programming. Similar to traditional convolution
operations, our non-linear feature mapping can be
applied successively at multiple levels.

1565



We evaluate the proposed architecture in the
context of sentence sentiment classification and
news categorization. On the Stanford Sentiment
Treebank dataset, our model obtains state-of-the-
art performance among a variety of neural net-
works in terms of both accuracy and training
cost. Our model achieves 51.2% accuracy on fine-
grained classification and 88.6% on binary clas-
sification, outperforming the best published num-
bers obtained by a deep recursive model (Tai et al.,
2015) and a convolutional model (Kim, 2014). On
the Chinese news categorization task, our model
achieves 80.0% accuracy, while the closest base-
line achieves 79.2%.

2 Related Work

Deep neural networks have recently brought about
significant advancements in various natural lan-
guage processing tasks, such as language model-
ing (Bengio et al., 2003; Mikolov et al., 2010),
sentiment analysis (Socher et al., 2013; Iyyer
et al., 2015; Le and Zuidema, 2015), syntactic
parsing (Collobert and Weston, 2008; Socher et
al., 2011a; Chen and Manning, 2014) and ma-
chine translation (Bahdanau et al., 2014; Devlin
et al., 2014; Sutskever et al., 2014). Models
applied in these tasks exhibit significant archi-
tectural differences, ranging from recurrent neu-
ral networks (Mikolov et al., 2010; Kalchbrenner
and Blunsom, 2013) to recursive models (Pollack,
1990; Küchler and Goller, 1996), and including
convolutional neural nets (Collobert and Weston,
2008; Collobert et al., 2011; Yih et al., 2014; Shen
et al., 2014; Kalchbrenner et al., 2014; Zhang and
LeCun, 2015).

Our model most closely relates to the latter.
Since these models have originally been developed
for computer vision (LeCun et al., 1998), their
application to NLP tasks introduced a number of
modifications. For instance, Collobert et al. (2011)
use the max-over-time pooling operation to aggre-
gate the features over the input sequence. This
variant has been successfully applied to seman-
tic parsing (Yih et al., 2014) and information re-
trieval (Shen et al., 2014; Gao et al., 2014). Kalch-
brenner et al. (2014) instead propose (dynamic)
k-max pooling operation for modeling sentences.
In addition, Kim (2014) combines CNNs of dif-
ferent filter widths and either static or fine-tuned
word vectors. In contrast to the traditional CNN
models, our method considers non-consecutive n-

grams thereby expanding the representation ca-
pacity of the model. Moreover, our model cap-
tures non-linear interactions within n-gram snip-
pets through the use of tensors, moving beyond
direct linear projection operator used in standard
CNNs. As our experiments demonstrate these ad-
vancements result in improved performance.

3 Background

Let x ∈ RL×d be the input sequence such as a
document or sentence. Here L is the length of the
sequence and each xi ∈ Rd is a vector represent-
ing the ith word. The (consecutive) n-gram vector
ending at position j is obtained by simply concate-
nating the corresponding word vectors

vj = [xj−n+1; xj−n+2; · · · ; xj ]

Out-of-index words are simply set to all zeros.
The traditional convolution operator is parame-

terized by filter matrix m ∈ Rnd×h which can be
thought of as n smaller filter matrices applied to
each xi in vector vj . The operator maps each n-
gram vector vj in the input sequence to m>vj ∈
Rh so that the input sequence x is transformed into
a sequence of feature representations,[

m>v1, · · · ,m>vL
]
∈ RL×h

The resulting feature values are often passed
through non-linearities such as the hyper-tangent
(element-wise) as well as aggregated or reduced
by “sum-over” or “max-pooling” operations for
later (similar stages) of processing.

The overall architecture can be easily modified
by replacing the basic n-gram vectors and the con-
volution operation with other feature mappings.
Indeed, we appeal to tensor algebra to introduce a
non-linear feature mapping that operates on non-
consecutive n-grams.

4 Model

N-gram tensor Typical n−gram feature map-
pings where concatenated word vectors are
mapped linearly to feature coordinates may be in-
sufficient to directly capture relevant information
in the n−gram. As a remedy, we replace concate-
nation with a tensor product. Consider a 3-gram
(x1,x2,x3) and the corresponding tensor product
x1 ⊗ x2 ⊗ x3. The tensor product is a 3-way ar-
ray of coordinate interactions such that each ijk

1566



entry of the tensor is given by the product of the
corresponding coordinates of the word vectors

(x1 ⊗ x2 ⊗ x3)ijk = x1i · x2j · x3k
Here ⊗ denotes the tensor product operator. The
tensor product of a 2-gram analogously gives a
two-way array or matrix x1⊗x2 ∈ Rd×d. The n-
gram tensor can be seen as a direct generalization
of the typical concatenated vector2.

Tensor-based feature mapping Since each n-
gram in the sequence is now expanded into a
high-dimensional tensor using tensor products, the
set of filters are analogously maintained as high-
order tensors. In other words, our filters are linear
mappings over the higher dimensional interaction
terms rather than the original word coordinates.

Consider again mapping a 3-gram (x1,x2,x3)
into a feature representation. Each filter is a 3-way
tensor with dimensions d× d× d. The set of h fil-
ters, denoted as T , is a 4-way tensor of dimension
d × d × d × h, where each d3 slice of T repre-
sents a single filter and h is the number of such
filters, i.e., the feature dimension. The resulting
h−dimensional feature representation z ∈ Rh for
the 3-gram (x1,x2,x3) is obtained by multiplying
the filter T and the 3-gram tensor as follows. The
lth coordinate of z is given by

zl =
∑
ijk

Tijkl · (x1 ⊗ x2 ⊗ x3)ijk

=
∑
ijk

Tijkl · x1i · x2j · x3k (1)

The formula is equivalent to summing over all
the third-order polynomial interaction terms where
tensor T stores the coefficients.

Directly maintaining the filters as full tensors
leads to parametric explosion. Indeed, the size of
the tensor T (i.e. h× dn) would be too large even
for typical low-dimensional word vectors where,
e.g., d = 300. To this end, we assume a low-rank
factorization of the tensor T, represented in the
Kruskal form. Specifically, T is decomposed into
a sum of h rank-1 tensors

T =
h∑

i=1

Pi ⊗Qi ⊗Ri ⊗Oi

2To see this, consider word vectors with a “bias” term
xi

′ = [xi; 1]. The tensor product of n such vectors includes
the concatenated vector as a subset of tensor entries but, in
addition, contains all up to nth-order interaction terms.

where P,Q,R ∈ Rh×d and O ∈ Rh×h are four
smaller parameter matrices. Pi (similarly Qi, Ri
and Oi) denotes the ith row of the matrix. Note
that, for simplicity, we have assumed that the num-
ber of rank-1 components in the decomposition
is equal to the feature dimension h. Plugging
the low-rank factorization into Eq.(1), the feature-
mapping can be rewritten in a vector form as

z = O> (Px1 �Qx2 �Rx3) (2)
where � is the element-wise product such that,
e.g., (a � b)k = ak × bk for a, b ∈ Rm. Note
that while Px1 (similarly Qx2 and Rx3) is a lin-
ear mapping from each word x1 (similarly x2 and
x3) into a h-dimensional feature space, higher or-
der terms arise from the element-wise products.

Non-consecutive n-gram features Traditional
convolution uses consecutive n-grams in the fea-
ture map. Non-consecutive n-grams may nev-
ertheless be helpful since phrases such as “not
good”, “not so good” and “not nearly as good” ex-
press similar sentiments but involve variable spac-
ings between the key words. Variable spacings are
not effectively captured by fixed n-grams.

We apply the feature-mapping in a weighted
manner to all n-grams thereby gaining access to
patterns such as “not ... good”. Let z[i, j, k] ∈ Rh
denote the feature representation corresponding to
a 3-gram (xi,xj ,xk) of words in positions i, j,
and k along the sequence. This vector is calcu-
lated analogously to Eq.(2),

z[i, j, k] = O> (Pxi �Qxj �Rxk)
We will aggregate these vectors into an
h−dimensional feature representation at each
position in the sequence. The idea is similar to
neural bag-of-words models where the feature
representation for a document or sentence is
obtained by averaging (or summing) of all the
word vectors. In our case, we define the aggregate
representation z3[k] in position k as the weighted
sum of all 3-gram feature representations ending
at position k, i.e.,

z3[k] =
∑

i<j<k

z[i, j, k] · λ(k−j−1)+(j−i−1)

=
∑

i<j<k

z[i, j, k] · λk−i−2 (3)

where λ ∈ [0, 1) is a decay factor that down-
weights 3-grams with longer spans (i.e., 3-grams

1567



that skip more in-between words). As λ → 0
all non-consecutive 3-grams are omitted, z3[k] =
z[k − 2, k − 1, k], and the model acts like a
traditional model with only consecutive n-grams.
When λ > 0, however, z3[k] is a weighted aver-
age of many 3-grams with variable spans.

Aggregating features via dynamic program-
ming Directly calculating z3[·] according to
Eq.(3) by enumerating all 3-grams would require
O(L3) feature-mapping operations. We can, how-
ever, evaluate the features more efficiently by re-
lying on the associative and distributive properties
of the feature operation in Eq.(2).

Let f3[k] be a dynamic programming table rep-
resenting the sum of 3-gram feature representa-
tions before multiplying with matrix O. That is,
z3[k] = O>f3[k] or, equivalently,

f3[k] =
∑

i<j<k

λk−i−2 · (Pxi �Qxj �Rxk)

We can analogously define f1[i] and f2[j] for 1-
grams and 2-grams,

f1[i] = Pxi

f2[j] =
∑
i<j

λj−i−1 · (Pxi �Qxj)

These dynamic programming tables can be calcu-
lated recursively according to the following for-
mulas:

f1[i] = Pxi
s1[i] = λ · s1[i− 1] + f1[i]

f2[j] = s1[j − 1]�Qxj
s2[j] = λ · s2[j − 1] + f2[j]

f3[k] = s2[k − 1]�Rxk

z[k] = O> (f1[k] + f2[k] + f3[k])

where s1[·] and s2[·] are two auxiliary tables. The
resulting z[·] is the sum of 1, 2, and 3-gram fea-
tures. We found that aggregating the 1,2 and 3-
gram features in this manner works better than us-
ing 3-gram features alone. Overall, the n-gram
feature aggregation can be performed in O(Ln)
matrix multiplication/addition operations, and re-
mains linear in the sequence length.

The overall architecture The dynamic pro-
gramming algorithm described above maps the
original input sequence to a sequence of feature
representations z = z[1 : L] ∈ RL×h. As in
standard convolutional architectures, the resulting
sequence can be used in multiple ways. One can
directly aggregate it to a classifier or expose it to
non-linear element-wise transformations and use
it as an input to another sequence-to-sequence fea-
ture mapping.

The simplest strategy (adopted in neural bag-
of-words models) would be to average the fea-
ture representations and pass the resulting aver-
aged vector directly to a softmax output unit

z̄ =
1
L

L∑
i=1

z[i]

ỹ = softmax
(
W>z̄

)
Our architecture, as illustrated in Figure 1, in-
cludes two additional refinements. First, we add
a non-linear activation function after each feature
representation, i.e. z′ = ReLU (z + b), where b
is a bias vector and ReLU is the rectified linear
unit function. Second, we stack multiple tensor-
based feature mapping layers. That is, the input
sequence x is first processed into a feature se-
quence and passed through the non-linear trans-
formation to obtain z(1). The resulting feature
sequence z(1) is then analogously processed by
another layer, parameterized by a different set of
feature-mapping matrices P, · · · ,O, to obtain a
higher-level feature sequence z(2), and so on. The
output feature representations of all these layers
are averaged within each layer and concatenated
as shown in Figure 1. The final prediction is there-
fore obtained on the basis of features across the
levels.

5 Learning the Model

Following standard practices, we train our model
by minimizing the cross-entropy error on a given
training set. For a single training sequence x and
the corresponding gold label y ∈ [0, 1]m, the error
is defined as,

loss (x, y) =
m∑

l=1

yl log (ỹl)

where m is the number of possible output label.
The set of model parameters (e.g. P, · · · ,O

in each layer) are updated via stochastic gradient

1568



The$
movie$
was$

fantas/c$

!$

softmax(output

input(x feature*maps

low.level(features high.level(features

…

…
average*and*
concatenate$

Figure 1: Illustration of the model architecture. The input is represented as a matrix where each row is a
d-dimensional word vector. Several feature map layers (as described in Section 4) are stacked, mapping
the input into different levels of feature representations. The features are averaged within each layer and
then concatenated. Finally a softmax layer is applied to obtain the prediction output.

descent using AdaGrad algorithm (Duchi et al.,
2011).

Initialization We initialize matrices P,Q,R
from uniform distribution

[
−√3/d,√3/d] and

similarly O ∼ U
[
−√3/h,√3/h]. In this way,

each row of the matrices is an unit vector in expec-
tation, and each rank-1 filter slice has unit variance
as well,

E
[‖Pi ⊗Qi ⊗Ri ⊗Oi‖2] = 1

In addition, the parameter matrix W in the soft-
max output layer is initialized as zeros, and the
bias vectors b for ReLU activation units are ini-
tialized to a small positive constant 0.01.

Regularization We apply two common tech-
niques to avoid overfitting during training. First,
we add L2 regularization to all parameter values
with the same regularization weight. In addition,
we randomly dropout (Hinton et al., 2012) units
on the output feature representations z(i) at each
level.

6 Experimental Setup

Datasets We evaluate our model on sentence
sentiment classification task and news categoriza-
tion task. For sentiment classification, we use the
Stanford Sentiment Treebank benchmark (Socher
et al., 2013). The dataset consists of 11855
parsed English sentences annotated at both the
root (i.e. sentence) level and the phrase level us-
ing 5-class fine-grained labels. We use the stan-

dard 8544/1101/2210 split for training, develop-
ment and testing respectively. Following previ-
ous work, we also evaluate our model on the bi-
nary classification variant of this benchmark, ig-
noring all neutral sentences. The binary version
has 6920/872/1821 sentences for training, devel-
opment and testing.

For the news categorization task, we evaluate on
Sogou Chinese news corpora.3 The dataset con-
tains 10 different news categories in total, includ-
ing Finance, Sports, Technology and Automobile
etc. We use 79520 documents for training, 9940
for development and 9940 for testing. To obtain
Chinese word boundaries, we use LTP-Cloud4, an
open-source Chinese NLP platform.

Baselines We implement the standard SVM
method and the neural bag-of-words model
NBoW as baseline methods in both tasks. To as-
sess the proposed tensor-based feature map, we
also implement a convolutional neural network
model CNN by replacing our filter with traditional
linear filter. The rest of the framework (such as
feature averaging and concatenation) remains the
same.

In addition, we compare our model with a wide
range of top-performing models on the sentence
sentiment classification task. Most of these mod-
els fall into either the category of recursive neural
networks (RNNs) or the category of convolutional
neural networks (CNNs). The recursive neural

3http://www.sogou.com/labs/dl/c.html
4http://www.ltp-cloud.com/intro/en/
https://github.com/HIT-SCIR/ltp

1569



Model Fine-grained Binary Time (in seconds)
Dev Test Dev Test per epoch per 10k samples

RNN 43.2 82.4 - -
RNTN 45.7 85.4 1657 1939
DRNN 49.8 86.8 431 504
RLSTM 51.0 88.0 140 164
DCNN 48.5 86.9 - -
CNN-MC 47.4 88.1 2452 156
CNN 48.8 47.2 85.7 86.2 32 37
PVEC 48.7 87.8 - -
DAN 48.2 86.8 73 5
SVM 40.1 38.3 78.6 81.3 - -
NBoW 45.1 44.5 80.7 82.0 1 1
Ours 49.5 50.6 87.0 87.0 28 33

+ phrase labels 53.4 51.2 88.9 88.6 445 28

Table 1: Comparison between our model and other baseline methods on Stanford Sentiment Treebank.
The top block lists recursive neural network models, the second block are convolutional network mod-
els and the third block contains other baseline methods, including the paragraph-vector model (Le and
Mikolov, 2014), the deep averaging network model (Iyyer et al., 2015) and our implementation of neural
bag-of-words. The training time of baseline methods is taken from (Iyyer et al., 2015) or directly from
the authors. For our implementations, timings were performed on a single core of a 2.6GHz Intel i7
processor.

network baselines include standard RNN (Socher
et al., 2011b), RNTN with a small core tensor in
the composition function (Socher et al., 2013), the
deep recursive model DRNN (Irsoy and Cardie,
2014) and the most recent recursive model using
long-short-term-memory units RLSTM (Tai et al.,
2015). These recursive models assume the in-
put sentences are represented as parse trees. As
a benefit, they can readily utilize annotations at
the phrase level. In contrast, convolutional neu-
ral networks are trained on sequence-level, taking
the original sequence and its label as training in-
put. Such convolutional baselines include the dy-
namic CNN with k-max pooling DCNN (Kalch-
brenner et al., 2014) and the convolutional model
with multi-channel CNN-MC by Kim (2014). To
leverage the phrase-level annotations in the Stan-
ford Sentiment Treebank, all phrases and the cor-
responding labels are added as separate instances
when training the sequence models. We follow
this strategy and report results with and without
phrase annotations.

Word vectors The word vectors are pre-trained
on much larger unannotated corpora to achieve
better generalization given limited amount of
training data (Turian et al., 2010). In particu-
lar, for the English sentiment classification task,

we use the publicly available 300-dimensional
GloVe word vectors trained on the Common Crawl
with 840B tokens (Pennington et al., 2014). This
choice of word vectors follows most recent work,
such as DAN (Iyyer et al., 2015) and RLSTM (Tai
et al., 2015). For Chinese news categorization,
there is no widely-used publicly available word
vectors. Therefore, we run word2vec (Mikolov
et al., 2013) to train 200-dimensional word vec-
tors on the 1.6 million Chinese news articles. Both
word vectors are normalized to unit norm (i.e.
‖w‖22 = 1) and are fixed in the experiments with-
out fine-tuning.

Hyperparameter setting We perform an exten-
sive search on the hyperparameters of our full
model, our implementation of the CNN model
(with linear filters), and the SVM baseline. For
our model and the CNN model, the initial learn-
ing rate of AdaGrad is fixed to 0.01 for sentiment
classification and 0.1 for news categorization, and
the L2 regularization weight is fixed to 1e − 5
and 1e−6 respectively based on preliminary runs.
The rest of the hyperparameters are randomly cho-
sen as follows: number of feature-mapping lay-
ers ∈ {1, 2, 3}, n-gram order n ∈ {2, 3}, hidden
feature dimension h ∈ {50, 100, 200}, dropout
probability ∈ {0.0, 0.1, 0.3, 0.5}, and length de-

1570



cay λ ∈ {0.0, 0.3, 0.5}. We run each config-
uration 3 times to explore different random ini-
tializations. For the SVM baseline, we tune L2
regularization weight C ∈ {0.01, 0.1, 1.0, 10.0},
word cut-off frequency ∈ {1, 2, 3, 5} (i.e. pruning
words appearing less than this times) and n-gram
feature order n ∈ {1, 2, 3}.
Implementation details The source code is
implemented in Python using the Theano li-
brary (Bergstra et al., 2010), a flexible lin-
ear algebra compiler that can optimize user-
specified computations (models) with efficient
automatic low-level implementations, including
(back-propagated) gradient calculation.

7 Results

7.1 Overall Performance
Table 1 presents the performance of our model
and other baseline methods on Stanford Sentiment
Treebank benchmark. Our full model obtains the
highest accuracy on both the development and test
sets. Specifically, it achieves 51.2% and 88.6%
test accuracies on fine-grained and binary tasks re-
spectively5. As shown in Table 2, our model per-
formance is relatively stable – it remains high ac-
curacies with around 0.5% standard deviation un-
der different initializations and dropout rates.

Our full model is also several times faster than
other top-performing models. For example, the
convolutional model with multi-channel (CNN-
MC) runs over 2400 seconds per training epoch.
In contrast, our full model (with 3 feature layers)
runs on average 28 seconds with only root labels
and on average 445 seconds with all labels.

Our results also show that the CNN model,
where our feature map is replaced with traditional
linear map, performs worse than our full model.
This observation confirms the importance of the
proposed non-linear, tensor-based feature map-
ping. The CNN model also lags behind the DCNN
and CNN-MC baselines, since the latter two pro-
pose several advancements over standard CNN.

Table 3 reports the results of SVM, NBoW and
our model on the news categorization task. Since
the dataset is much larger compared to the senti-
ment dataset (80K documents vs. 8.5K sentences),
the SVM method is a competitive baseline. It
achieves 78.5% accuracy compared to 74.4% and

5Best hyperparameter configuration based on dev accu-
racy: 3 layers, 3-gram tensors (n=3), feature dimension d =
200 and length decay λ = 0.5

Dataset Accuracy

Fine-grained
Dev 52.5 (±0.5) %
Test 51.4 (±0.6) %

Binary
Dev 88.4 (±0.3) %
Test 88.4 (±0.5) %

Table 2: Analysis of average accuracy and stan-
dard deviation of our model on sentiment classifi-
cation task.

Model Dev Acc. Test Acc.
SVM (1-gram) 77.5 77.4
SVM (2-gram) 78.2 78.0
SVM (3-gram) 78.2 78.5
NBoW 74.4 74.4
CNN 79.5 79.2
Ours 80.0 80.0

Table 3: Performance of various methods on Chi-
nese news categorization task. Our model obtains
better results than the SVM, NBoW and traditional
CNN baselines.

79.2% obtained by the neural bag-of-words model
and CNN model. In contrast, our model obtains
80.0% accuracy on both the development and test
sets, outperforming the three baselines by a 0.8%
absolute margin. The best hyperparameter con-
figuration in this task uses less feature layers and
lower n-gram order (specifically, 2 layers and n =
2) compared to the sentiment classification task.
We hypothesize that the difference is due to the
nature of the two tasks: the document classifica-
tion task requires to handle less compositions or
context interactions than sentiment analysis.

7.2 Hyperparameter Analysis
We next investigate the impact of hyperparame-
ters in our model performance. We use the mod-
els trained on fine-grained sentiment classification
task with only root labels.

Number of layers We plot the fine-grained sen-
timent classification accuracies obtained during
hyperparameter grid search. Figure 2 illustrates
how the number of feature layers impacts the
model performance. As shown in the figure,
adding higher-level features clearly improves the
classification accuracy across various hyperpa-
rameter settings and initializations.

Non-consecutive n-gram features We also an-
alyze the effect of modeling non-consecutive n-

1571



Table 1

the movie is not good

the 0.25

movie 0.25

is 0.08

not -1.91

good -1.00

the 0.25

movie 0.25

is 0.08

not -1.91

bad 1.99

the 0.25

movie 0.25

is 0.08

neither -1.99

good -0.95

nor -1.97

bad 1.75

the 0.25

movie 0.25

is 0.08

bad 12

the 0.25

movie 0.25

is 0.08

good 1.99

-2
-1
0
1
2

the movie is not good
-2
-1
0
1
2

the movie is not bad

-2
-1
0
1
2

the movie is neither good nor bad
-2
-1
0
1
2

the movie is bad
-2
-1
0
1
2

the movie is good

Table 1

the movie is not good

the 0.25

movie 0.25

is 0.08

not -1.91

good -1.00

the 0.25

movie 0.25

is 0.08

not -1.91

bad 1.99

the 0.25

movie 0.25

is 0.08

neither -1.99

good -0.95

nor -1.97

bad 1.75

the 0.25

movie 0.25

is 0.08

bad 12

the 0.25

movie 0.25

is 0.08

good 1.99

-2
-1
0
1
2

the movie is not good
-2
-1
0
1
2

the movie is not bad

-2
-1
0
1
2

the movie is neither good nor bad
-2
-1
0
1
2

the movie is bad
-2
-1
0
1
2

the movie is good

Table 1

the movie is not good

the 0.25

movie 0.25

is 0.08

not -1.91

good -1.00

the 0.25

movie 0.25

is 0.08

not -1.91

bad 1.99

the 0.25

movie 0.25

is 0.08

neither -1.99

good -0.95

nor -1.97

bad 1.75

the 0.25

movie 0.25

is 0.08

bad 12

the 0.25

movie 0.25

is 0.08

good 1.99

okay 10.34

but 0

not 10.51

good 10.04

-2
-1
0
1
2

the movie is not good
-2
-1
0
1
2

the movie is not bad

-2
-1
0
1
2

the movie is neither good nor bad
-2
-1
0
1
2

the movie is bad
-2
-1
0
1
2

the movie is good
-2
-1
0
1
2

okay but not good

Table 1

the movie is not good

the 0.25

movie 0.25

is 0.08

not -1.91

good -1.00

the 0.25

movie 0.25

is 0.08

not -1.91

bad 1.99

the 0.25

movie 0.25

is 0.08

neither -1.99

good -0.95

nor -1.97

bad 1.75

the 0.25

movie 0.25

is 0.08

bad 12

the 0.25

movie 0.25

is 0.08

good 1.99

okay 10.34

but 0

not 10.51

good 10.04

-2
-1
0
1
2

the movie is not good
-2
-1
0
1
2

the movie is not bad

-2
-1
0
1
2

the movie is neither good nor bad
-2
-1
0
1
2

the movie is bad
-2
-1
0
1
2

the movie is good
-2
-1
0
1
2

okay but not good

(1) positive prediction (2) negative prediction (3) negative prediction (4) positive prediction

Table 1

the movie is not good

the 0.25

movie 0.25

is 0.08

not -1.91

good -1.00

the 0.25

movie 0.25

is 0.08

not -1.91

bad 1.99

the 0.25

movie 0.25

is 0.08

neither -1.99

good -0.95

nor -1.97

bad 1.75

the 0.25

movie 0.25

is 0.08

bad 12

the 0.25

movie 0.25

is 0.08

good 1.99

okay 10.34

but 0

not 10.51

good 10.04

-2
-1
0
1
2

the movie is not good
-2
-1
0
1
2

the movie is not bad

-2
-1
0
1
2

the movie is neither good nor bad
-2
-1
0
1
2

the movie is bad
-2
-1
0
1
2

the movie is good
-2
-1
0
1
2

okay but not good

no #1.56

movement #0.81

, 0.09

no #1.97

yuks 0.08

, 0.46

not #0.58

much #0.85

of #1.01

anything #1.43

. #1.01

-2
-1
0
1
2

no movement , no yuks , not much of anything .

(5) negative prediction (6) negative prediction (ground truth: negative)

too #0.94
bad #1.99
, #0.88

but 0.06

thanks 1.39

to 1.16

some 1.07

lovely 1.93

.. 1.98

.. 1.79

and 1.91

several 1.77

fine 1.98

.. 2

, 2

it 0.42

‘s #0.72

not #0.99

a #1.02

total 0.7

loss 1.32

. 0.97

-2

-1

0

1

2

too bad , but thanks to some lovely .. .. and several fine .. , it ‘s not a total loss .

(7) positive prediction (ground truth: positive)

Figure 5: Example sentences and their sentiments predicted by our model trained with root labels. The
predicted sentiment scores at each word position are plotted. Examples (1)-(5) are synthetic inputs, (6)
and (7) are two real inputs from the test set. Our model successfully identifies negation, double negation
and phrases with different sentiment in one sentence.

Table 1

1 layer 2 layers 3 layers

0.445 0.4692

0.446 0.4738

0.4469 0.4769

0.4478 0.4629

0.4487 0.4688

0.4505 0.4701

0.4505 0.4692

0.4505 0.4665

0.4514 0.4688

0.4523 0.4697

0.4523 0.462

0.4523 0.4706

0.4523 0.4652

0.4523 0.4688

0.4532 0.4665

0.4532 0.4756

0.4541 0.4534

0.4541 0.4652

0.455 0.4652

0.455 0.4633

0.4569 0.467

0.4569 0.476

0.4578 0.4679

0.4578 0.4692

0.4587 0.4538

0.4587 0.4801

0.4587 0.4701

0.4596 0.4588

0.4596 0.4715

0.4614 0.4557

0.4614 0.4719

0.4614 0.4751

0.4623 0.4575

0.4632 0.4747

0.4641 0.4679

0.4641 0.4729

0.465 0.4701

0.465 0.471

0.4659 0.4688

0.4659 0.4774

0.4659 0.4724

0.4659 0.4692

0.4668 0.4688

0.4678 0.4724

0.4678 0.4851

0.4678 0.4751

0.4687 0.4661

0.4732 0.4792

0.4632 0.481

0.4714 0.4842

0.4714 0.49

0.4714 0.4769

0.4714 0.4828

0.4723 0.4674

0.4723 0.4828

0.4732 0.4593

0.4732 0.4814

0.4732 0.4697

0.475 0.4638

0.475 0.4778

0.4759 0.4887

0.4759 0.4887

0.4759 0.4783

0.4759 0.4692

0.4768 0.4701

0.4768 0.49

0.4768 0.4842

0.4777 0.4824

0.4787 0.476

0.4796 0.4747

0.4796 0.4982

0.4796 0.486

0.4814 0.4742

0.4814 0.4959

0.4823 0.4729

0.4841 0.4801

0.485 0.4719

0.4859 0.4864

0.4877 0.4873

0.4877 0.5009

0.4668 0.4932

0.4696 0.4724

0.4696 0.4919

0.4705 0.4905

0.4714 0.4869

0.4723 0.4665

0.4723 0.481

0.4723 0.4873

0.4732 0.4905

0.4741 0.4783

0.4759 0.4769

0.4759 0.4778

0.4768 0.4896

0.4787 0.4851

0.4796 0.4801

0.4805 0.5081

0.4805 0.4869

0.4805 0.4964

0.4805 0.4882

0.4814 0.4932

0.4814 0.4955

0.4823 0.4661

0.4823 0.4652

0.4823 0.4819

0.4832 0.4719

0.4832 0.4787

0.4832 0.4891

0.4832 0.4769

0.4832 0.4986

0.485 0.4964

0.4859 0.476

0.4859 0.4986

0.4868 0.486

0.4877 0.4959

0.4886 0.4878

0.4896 0.4602

0.4896 0.4937

0.4914 0.4765

0.4923 0.4986

0.495 0.5063

44.5%

46.1%

47.8%

49.4%

51.0%

43.5% 45.1% 46.8% 48.4% 50.0%

1 layer 2 layers 3 layers

Figure 2: Dev accuracy (x-axis) and test accuracy
(y-axis) of independent runs of our model on fine-
grained sentiment classification task. Deeper ar-
chitectures achieve better accuracies.

grams. Figure 3 splits the model accuracies ac-
cording to the choice of span decaying factor λ.
Note when λ = 0, the model applies feature ex-
tractions to consecutive n-grams only. As shown
in Figure 3, this setting leads to consistent perfor-
mance drop. This result confirms the importance
of handling non-consecutive n-gram patterns.

Non-linear activation Finally, we verify the ef-
fectiveness of rectified linear unit activation func-

decay=0.0 decay=0.3 decay=0.5

0.4587 0.4724

0.4623 0.4774

0.4632 0.4593

0.465 0.4864

0.4659 0.4765

0.4668 0.4796

0.4678 0.4715

0.4687 0.4805

0.4696 0.4805

0.4696 0.4864

0.4705 0.4548

0.4705 0.4729

0.4714 0.4652

0.4714 0.4629

0.4723 0.4787

0.4723 0.4982

0.4723 0.4787

0.4723 0.4606

0.4732 0.4765

0.4732 0.4701

0.475 0.4801

0.4759 0.4688

0.4759 0.4661

0.4768 0.4837

0.4768 0.4652

0.4777 0.4557

0.4777 0.4588

0.4777 0.4688

0.4777 0.4986

0.4787 0.4633

0.4796 0.471

0.4805 0.4891

0.4632 0.481

0.4668 0.4932

0.4696 0.4724

0.4705 0.4905

0.4714 0.4842

0.4714 0.49

0.4714 0.4869

0.4714 0.4769

0.4723 0.4665

0.4723 0.481

0.4723 0.4674

0.4723 0.4828

0.4732 0.4697

0.4732 0.4905

0.475 0.4778

0.4759 0.4692

0.4768 0.4896

0.4768 0.49

0.4768 0.4842

0.4787 0.476

0.4796 0.4747

0.4796 0.486

0.4805 0.5081

0.4805 0.4869

0.4805 0.4882

0.4814 0.4932

0.4823 0.4729

0.4823 0.4661

0.4823 0.4652

0.4832 0.4891

0.4859 0.476

0.4859 0.4864

0.4886 0.4878

0.4896 0.4602

0.495 0.5063

0.4696 0.4919

0.4714 0.4828

0.4723 0.4873

0.4732 0.4593

0.4732 0.4814

0.4741 0.4783

0.475 0.4638

0.4759 0.4769

0.4759 0.4887

0.4759 0.4887

0.4759 0.4783

0.4759 0.4778

0.4768 0.4701

0.4777 0.4824

0.4787 0.4851

0.4796 0.4982

0.4796 0.4801

0.4805 0.4964

0.4814 0.4742

0.4814 0.4959

0.4814 0.4955

0.4823 0.4819

0.4832 0.4719

0.4832 0.4787

0.4832 0.4769

0.4832 0.4986

0.4841 0.4801

0.485 0.4719

0.485 0.4964

0.4859 0.4986

0.4868 0.486

0.4877 0.4873

0.4877 0.4959

0.4877 0.5009

0.4896 0.4937

0.4914 0.4765

0.4923 0.4986

44.5%

46.1%

47.8%

49.4%

51.0%

45.0% 46.3% 47.5% 48.8% 50.0%

decay=0.0 decay=0.3 decay=0.5

Figure 3: Comparison of our model variations
in sentiment classification task when considering
consecutive n-grams only (decaying factor λ = 0)
and when considering non-consecutive n-grams
(λ > 0). Modeling non-consecutive n-gram fea-
tures leads to better performance.

tion (ReLU) by comparing it with no activation (or
identity activation f(x) = x). As shown in Fig-
ure 4, our model with ReLU activation generally
outperforms its variant without ReLU. The obser-
vation is consistent with previous work on convo-
lutional neural networks and other neural network
models.

1572



None ReLU

0.4696 0.4724

0.4714 0.4769

0.4714 0.4828

0.4723 0.4665

0.4723 0.481

0.4723 0.4873

0.4723 0.4674

0.4723 0.4828

0.4732 0.4593

0.4732 0.4697

0.4741 0.4783

0.475 0.4638

0.475 0.4778

0.4759 0.4769

0.4759 0.4887

0.4759 0.4783

0.4759 0.4692

0.4759 0.4778

0.4768 0.4701

0.4768 0.4896

0.4777 0.4824

0.4787 0.476

0.4787 0.4851

0.4796 0.4747

0.4796 0.4801

0.4805 0.4869

0.4814 0.4742

0.4823 0.4729

0.4823 0.4661

0.4823 0.4652

0.4823 0.4819

0.4832 0.4719

0.4832 0.4787

0.4832 0.4891

0.4832 0.4769

0.485 0.4719

0.4859 0.476

0.4877 0.4873

0.4896 0.4602

0.4914 0.4765

0.4632 0.481

0.4668 0.4932

0.4696 0.4919

0.4705 0.4905

0.4714 0.4842

0.4714 0.49

0.4714 0.4869

0.4732 0.4814

0.4732 0.4905

0.4759 0.4887

0.4768 0.49

0.4768 0.4842

0.4796 0.4982

0.4796 0.486

0.4805 0.5081

0.4805 0.4964

0.4805 0.4882

0.4814 0.4959

0.4814 0.4932

0.4814 0.4955

0.4832 0.4986

0.4841 0.4801

0.485 0.4964

0.4859 0.4986

0.4859 0.4864

0.4868 0.486

0.4877 0.4959

0.4877 0.5009

0.4886 0.4878

0.4896 0.4937

0.4923 0.4986

0.495 0.5063

44.5%

46.1%

47.8%

49.4%

51.0%

46.0% 47.0% 48.0% 49.0% 50.0%

None ReLU

Figure 4: Applying ReLU activation on top of
tensor-based feature mapping leads to better per-
formance in sentiment classification task. Runs
with no activation are plotted as blue circles.

7.3 Example Predictions
Figure 5 gives examples of input sentences and
the corresponding predictions of our model in
fine-grained sentiment classification. To see how
our model captures the sentiment at different lo-
cal context, we apply the learned softmax ac-
tivation to the extracted features at each posi-
tion without taking the average. That is, for
each index i, we obtain the local sentiment p =
softmax

(
W>

(
z(1)[i]⊕ z(2)[i]⊕ z(3)[i])). We

plot the expected sentiment scores
∑2

s=−2 s ·p(s),
where a score of 2 means “very positive”, 0 means
“neutral” and -2 means “very negative”. As shown
in the figure, our model successfully learns nega-
tion and double negation. The model also iden-
tifies positive and negative segments appearing in
the sentence.

8 Conclusion

We proposed a feature mapping operator for con-
volutional neural networks by modeling n-gram
interactions based on tensor product and evaluat-
ing all non-consecutive n-gram vectors. The as-
sociated parameters are maintained as a low-rank
tensor, which leads to efficient feature extraction
via dynamic programming. The model achieves
top performance on standard sentiment classifica-
tion and document categorization tasks.

Acknowledgments

We thank Kai Sheng Tai, Mohit Iyyer and Jordan
Boyd-Graber for answering questions about their
paper. We also thank Yoon Kim, the MIT NLP
group and the reviewers for their comments. We

acknowledge the support of the U.S. Army Re-
search Office under grant number W911NF-10-1-
0533. The work is developed in collaboration with
the Arabic Language Technologies (ALT) group at
Qatar Computing Research Institute (QCRI). Any
opinions, findings, conclusions, or recommenda-
tions expressed in this paper are those of the au-
thors, and do not necessarily reflect the views of
the funding organizations.

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-

gio. 2014. Neural machine translation by jointly
learning to align and translate. arXiv preprint
arXiv:1409.0473.

Yoshua Bengio, Réjean Ducharme, Pascal Vincent, and
Christian Janvin. 2003. A neural probabilistic lan-
guage model. The Journal of Machine Learning Re-
search, 3:1137–1155.

James Bergstra, Olivier Breuleux, Frédéric Bastien,
Pascal Lamblin, Razvan Pascanu, Guillaume Des-
jardins, Joseph Turian, David Warde-Farley, and
Yoshua Bengio. 2010. Theano: a CPU and
GPU math expression compiler. In Proceedings
of the Python for Scientific Computing Conference
(SciPy).

Danqi Chen and Christopher D Manning. 2014. A fast
and accurate dependency parser using neural net-
works. In Proceedings of the 2014 Conference on
Empirical Methods in Natural Language Processing
(EMNLP), pages 740–750.

R. Collobert and J. Weston. 2008. A unified architec-
ture for natural language processing: Deep neural
networks with multitask learning. In International
Conference on Machine Learning, ICML.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
scratch. The Journal of Machine Learning Re-
search, 12:2493–2537.

Jacob Devlin, Rabih Zbib, Zhongqiang Huang, Thomas
Lamar, Richard Schwartz, and John Makhoul. 2014.
Fast and robust neural network joint models for sta-
tistical machine translation. In 52nd Annual Meet-
ing of the Association for Computational Linguis-
tics.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
and stochastic optimization. The Journal of Ma-
chine Learning Research, 12:2121–2159.

Jianfeng Gao, Patrick Pantel, Michael Gamon, Xi-
aodong He, Li Deng, and Yelong Shen. 2014. Mod-
eling interestingness with deep neural networks. In

1573



Proceedings of the 2013 Conference on Empirical
Methods in Natural Language Processing.

Geoffrey E Hinton, Nitish Srivastava, Alex Krizhevsky,
Ilya Sutskever, and Ruslan R Salakhutdinov. 2012.
Improving neural networks by preventing co-
adaptation of feature detectors. arXiv preprint
arXiv:1207.0580.

Ozan Irsoy and Claire Cardie. 2014. Deep recursive
neural networks for compositionality in language.
In Advances in Neural Information Processing Sys-
tems.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-Graber,
and Hal Daume III. 2015. Deep unordered compo-
sition rivals syntactic methods for text classification.
In Association for Computational Linguistics.

Nal Kalchbrenner and Phil Blunsom. 2013. Recurrent
continuous translation models. In Proceedings of
the 2013 Conference on Empirical Methods in Nat-
ural Language Processing (EMNLP 2013), pages
1700–1709.

Nal Kalchbrenner, Edward Grefenstette, and Phil Blun-
som. 2014. A convolutional neural network for
modelling sentences. In Proceedings of the 52th An-
nual Meeting of the Association for Computational
Linguistics.

Dimitri Kartsaklis, Mehrnoosh Sadrzadeh, and Stephen
Pulman. 2012. A unified sentence space for
categorical distributional-compositional semantics:
Theory and experiments. In In Proceedings of COL-
ING: Posters.

Yoon Kim. 2014. Convolutional neural networks for
sentence classification. In Proceedings of the Em-
piricial Methods in Natural Language Processing
(EMNLP 2014).

Andreas Küchler and Christoph Goller. 1996. Induc-
tive learning in symbolic domains using structure-
driven recurrent neural networks. In KI-96: Ad-
vances in Artificial Intelligence, pages 183–197.

Quoc Le and Tomas Mikolov. 2014. Distributed repre-
sentations of sentences and documents. In Proceed-
ings of the 31st International Conference on Ma-
chine Learning (ICML-14), pages 1188–1196.

Phong Le and Willem Zuidema. 2015. Compositional
distributional semantics with long short term mem-
ory. In Proceedings of Joint Conference on Lexical
and Computational Semantics (*SEM).

Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. 1998.
Gradient-based learning applied to document recog-
nition. Proceedings of the IEEE, 86(11):2278–2324,
November.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proceedings of the

52th Annual Meeting of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics.

Tomas Mikolov, Martin Karafiát, Lukas Burget, Jan
Cernockỳ, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH 2010, 11th Annual Conference of the
International Speech Communication Association,
Makuhari, Chiba, Japan, September 26-30, 2010,
pages 1045–1048.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey
Dean. 2013. Efficient estimation of word represen-
tations in vector space. CoRR.

Jeff Mitchell and Mirella Lapata. 2008. Vector-based
models of semantic composition. In ACL, pages
236–244.

Jeffrey Pennington, Richard Socher, and Christopher D
Manning. 2014. Glove: Global vectors for word
representation. volume 12.

Jordan B Pollack. 1990. Recursive distributed repre-
sentations. Artificial Intelligence, 46:77–105.

Yelong Shen, Xiaodong He, Jianfeng Gao, Li Deng,
and Grégoire Mesnil. 2014. Learning semantic rep-
resentations using convolutional neural networks for
web search. In Proceedings of the companion publi-
cation of the 23rd international conference on World
wide web companion, pages 373–374. International
World Wide Web Conferences Steering Committee.

Richard Socher, Cliff C. Lin, Andrew Y. Ng, and
Christopher D. Manning. 2011a. Parsing natural
scenes and natural language with recursive neural
networks. In Proceedings of the 26th International
Conference on Machine Learning (ICML).

Richard Socher, Jeffrey Pennington, Eric H Huang,
Andrew Y Ng, and Christopher D Manning. 2011b.
Semi-supervised recursive autoencoders for predict-
ing sentiment distributions. In Proceedings of the
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 151–161. Association for
Computational Linguistics.

Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Christopher D. Manning, Andrew Y. Ng,
and Christopher Potts. 2013. Recursive deep mod-
els for semantic compositionality over a sentiment
treebank. In Proceedings of the 2013 Conference on
Empirical Methods in Natural Language Process-
ing, pages 1631–1642, October.

Ilya Sutskever, Oriol Vinyals, and Quoc VV Le. 2014.
Sequence to sequence learning with neural net-
works. In Advances in Neural Information Process-
ing Systems, pages 3104–3112.

Kai Sheng Tai, Richard Socher, and Christopher D
Manning. 2015. Improved semantic representations
from tree-structured long short-term memory net-
works. In Proceedings of the 53th Annual Meeting
of the Association for Computational Linguistics.

1574



Joseph Turian, Lev Ratinov, and Yoshua Bengio. 2010.
Word representations: A simple and general method
for semi-supervised learning. In Proceedings of the
48th Annual Meeting of the Association for Compu-
tational Linguistics, ACL ’10. Association for Com-
putational Linguistics.

Wen-tau Yih, Xiaodong He, and Christopher Meek.
2014. Semantic parsing for single-relation question
answering. In Proceedings of ACL.

Xiang Zhang and Yann LeCun. 2015. Text understand-
ing from scratch. arXiv preprint arXiv:1502.01710.

1575


