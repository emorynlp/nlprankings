



















































Fast and Robust Compressive Summarization with Dual Decomposition and Multi-Task Learning


Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 196–206,
Sofia, Bulgaria, August 4-9 2013. c©2013 Association for Computational Linguistics

Fast and Robust Compressive Summarization
with Dual Decomposition and Multi-Task Learning

Miguel B. Almeida∗† André F. T. Martins∗†
∗Priberam Labs, Alameda D. Afonso Henriques, 41, 2o, 1000-123 Lisboa, Portugal

†Instituto de Telecomunicações, Instituto Superior Técnico, 1049-001 Lisboa, Portugal
{mba,atm}@priberam.pt

Abstract

We present a dual decomposition frame-
work for multi-document summarization,
using a model that jointly extracts and
compresses sentences. Compared with
previous work based on integer linear pro-
gramming, our approach does not require
external solvers, is significantly faster, and
is modular in the three qualities a sum-
mary should have: conciseness, informa-
tiveness, and grammaticality. In addition,
we propose a multi-task learning frame-
work to take advantage of existing data
for extractive summarization and sentence
compression. Experiments in the TAC-
2008 dataset yield the highest published
ROUGE scores to date, with runtimes that
rival those of extractive summarizers.

1 Introduction

Automatic text summarization is a seminal prob-
lem in information retrieval and natural language
processing (Luhn, 1958; Baxendale, 1958; Ed-
mundson, 1969). Today, with the overwhelming
amount of information available on the Web, the
demand for fast, robust, and scalable summariza-
tion systems is stronger than ever.

Up to now, extractive systems have been the
most popular in multi-document summarization.
These systems produce a summary by extracting
a representative set of sentences from the origi-
nal documents (Kupiec et al., 1995; Carbonell and
Goldstein, 1998; Radev et al., 2000; Gillick et al.,
2008). This approach has obvious advantages: it
reduces the search space by letting decisions be
made for each sentence as a whole (avoiding fine-
grained text generation), and it ensures a grammat-
ical summary, assuming the original sentences are
well-formed. The typical trade-offs in these mod-

els (maximizing relevance, and penalizing redun-
dancy) lead to submodular optimization problems
(Lin and Bilmes, 2010), which are NP-hard but ap-
proximable through greedy algorithms; learning is
possible with standard structured prediction algo-
rithms (Sipos et al., 2012; Lin and Bilmes, 2012).
Probabilistic models have also been proposed to
capture the problem structure, such as determinan-
tal point processes (Gillenwater et al., 2012).

However, extractive systems are rather limited
in the summaries they can produce. Long, partly
relevant sentences tend not to appear in the sum-
mary, or to block the inclusion of other sen-
tences. This has motivated research in compres-
sive summarization (Lin, 2003; Zajic et al., 2006;
Daumé, 2006), where summaries are formed by
compressed sentences (Knight and Marcu, 2000),
not necessarily extracts. While promising results
have been achieved by models that simultaneously
extract and compress (Martins and Smith, 2009;
Woodsend and Lapata, 2010; Berg-Kirkpatrick et
al., 2011), there are still obstacles that need to
be surmounted for these systems to enjoy wide
adoption. All approaches above are based on in-
teger linear programming (ILP), suffering from
slow runtimes, when compared to extractive sys-
tems. For example, Woodsend and Lapata (2012)
report 55 seconds on average to produce a sum-
mary; Berg-Kirkpatrick et al. (2011) report sub-
stantially faster runtimes, but fewer compressions
are allowed. Having a compressive summarizer
which is both fast and expressive remains an open
problem. A second inconvenience of ILP-based
approaches is that they do not exploit the modu-
larity of the problem, since the declarative specifi-
cation required by ILP solvers discards important
structural information. For example, such solvers
are unable to take advantage of efficient dynamic
programming routines for sentence compression
(McDonald, 2006).

196



This paper makes progress in two fronts:

• We derive a dual decomposition framework for
extractive and compressive summarization (§2–
3). Not only is this framework orders of mag-
nitude more efficient than the ILP-based ap-
proaches, it also allows the three well-known
metrics of summaries—conciseness, informa-
tiveness, and grammaticality—to be treated sep-
arately in a modular fashion (see Figure 1). We
also contribute with a novel knapsack factor,
along with a linear-time algorithm for the corre-
sponding dual decomposition subproblem.

• We propose multi-task learning (§4) as a prin-
cipled way to train compressive summarizers,
using auxiliary data for extractive summariza-
tion and sentence compression. To this end,
we adapt the framework of Evgeniou and Pon-
til (2004) and Daumé (2007) to train structured
predictors that share some of their parts.

Experiments on TAC data (§5) yield state-of-the-
art results, with runtimes similar to that of extrac-
tive systems. To our best knowledge, this had
never been achieved by compressive summarizers.

2 Extractive Summarization

In extractive summarization, we are given a set
of sentences D := {s1, . . . , sN} belonging to one
or more documents, and the goal is to extract a
subset S ⊆ D that conveys a good summary of D
and whose total number of words does not exceed
a prespecified budget B.

We use an indicator vector y := 〈yn〉Nn=1 to rep-
resent an extractive summary, where yn = 1 if
sn ∈ S, and yn = 0 otherwise. Let Ln be the
number of words of the nth sentence. By design-
ing a quality score function g : {0, 1}N → R, this
can be cast as a global optimization problem with
a knapsack constraint:

maximize g(y)

w.r.t. y ∈ {0, 1}N

s.t.
∑N

n=1 Lnyn ≤ B. (1)

Intuitively, a good summary is one which selects
sentences that individually convey “relevant” in-
formation, while collectively having small “re-
dundancy.” This trade-off was explicitly mod-
eled in early works through the notion of max-
imal marginal relevance (Carbonell and Gold-
stein, 1998; McDonald, 2007). An alternative

are coverage-based models (§2.1; Filatova and
Hatzivassiloglou, 2004; Yih et al., 2007; Gillick
et al., 2008), which seek a set of sentences that
covers as many diverse “concepts” as possible; re-
dundancy is automatically penalized since redun-
dant sentences cover fewer concepts. Both models
can be framed under the framework of submodular
optimization (Lin and Bilmes, 2010), leading to
greedy algorithms that have approximation guar-
antees. However, extending these models to allow
for sentence compression (as will be detailed in
§3) breaks the diminishing returns property, mak-
ing submodular optimization no longer applicable.

2.1 Coverage-Based Summarization

Coverage-based extractive summarization can be
formalized as follows. Let C(D) := {c1, . . . , cM}
be a set of relevant concept types which are
present in the original documents D.1 Let σm be a
relevance score assigned to the mth concept, and
let the set Im ⊆ {1, . . . , N} contain the indices of
the sentences in which this concept occurs. Then,
the following quality score function is defined:

g(y) =
∑M

m=1 σmum(y), (2)

where um(y) :=
∨
n∈Im yn is a Boolean function

that indicates whether the mth concept is present
in the summary. Plugging this into Eq. 1, one ob-
tains the following Boolean optimization problem:

maximize
∑M

m=1 σmum

w.r.t. y ∈ {0, 1}N , u ∈ {0, 1}M
s.t. um =

∨
n∈Im yn, ∀m ∈ [M ]∑N

n=1 Lnyn ≤ B, (3)

where we used the notation [M ] := {1, . . . ,M}.
This can be converted into an ILP and addressed
with off-the-shelf solvers (Gillick et al., 2008). A
drawback of this approach is that solving an ILP
exactly is NP-hard. Even though existing commer-
cial solvers can solve most instances with a mod-
erate speed, they still exhibit poor worst-case be-
haviour; this is exacerbated when there is the need
to combine an extractive component with other
modules, as in compressive summarization (§3).

1Previous work has modeled concepts as events (Filatova
and Hatzivassiloglou, 2004), salient words (Lin and Bilmes,
2010), and word bigrams (Gillick et al., 2008). In the sequel,
we assume concepts are word k-grams, but our model can
handle other representations, such as phrases or predicate-
argument structures.

197



2.2 A Dual Decomposition Formulation

We next describe how the problem in Eq. 3 can be
addressed with dual decomposition, a class of op-
timization techniques that tackle the dual of com-
binatorial problems in a modular, extensible, and
parallelizable manner (Komodakis et al., 2007;
Rush et al., 2010). In particular, we employ al-
ternating directions dual decomposition (AD3;
Martins et al., 2011a, 2012) for solving a linear re-
laxation of Eq. 3. AD3 resembles the subgradient-
based algorithm of Rush et al. (2010), but it enjoys
a faster convergence rate. Both algorithms split
the original problem into several components,
and then iterate between solving independent lo-
cal subproblems at each component and adjusting
multipliers to promote an agreement.2 The differ-
ence between the two methods is that the AD3 lo-
cal subproblems, instead of requiring the compu-
tation of a locally optimal configuration, require
solving a local quadratic problem. Martins et al.
(2011b) provided linear-time solutions for several
logic constraints, with applications to syntax and
frame-semantic parsing (Das et al., 2012). We will
see that AD3 can also handle budget and knapsack
constraints efficiently.

To tackle Eq. 3 with dual decomposition, we
split the coverage-based summarizer into the fol-
lowing M + 1 components (one per constraint):

1. For each of the M concepts in C(D), one
component for imposing the logic constraint
in Eq. 3. This corresponds to the OR-WITH-
OUTPUT factor described by Martins et al.
(2011b); the AD3 subproblem for themth factor
can be solved in time O(|Im|).

2. Another component for the knapsack con-
straint. This corresponds to a (novel) KNAP-
SACK factor, whose AD3 subproblem is solv-
able in time O(N). The actual algorithm is de-
scribed in the appendix (Algorithm 1).3

3 Compressive Summarization

We now turn to compressive summarization,
which does not limit the summary sentences to be
verbatim extracts from the original documents; in-

2For details about dual decomposition and Lagrangian re-
laxation, see the recent tutorial by Rush and Collins (2012).

3The AD3 subproblem in this case corresponds to com-
puting an Euclidean projection onto the knapsack polytope
(Eq. 11). Others addressed the related, but much harder, inte-
ger quadratic knapsack problem (McDonald, 2007).

stead, it allows the extraction of compressed sen-
tences where some words can be deleted.

Formally, let us express each sentence of D
as a sequence of word tokens, sn := 〈tn,`〉Ln`=0,
where tn,0 ≡ $ is a dummy symbol. We rep-
resent a compression of sn as an indicator vec-
tor zn := 〈zn,`〉Ln`=0, where zn,` = 1 if the `th
word is included in the compression. By conven-
tion, the dummy symbol is included if and only if
the remaining compression is non-empty. A com-
pressive summary can then be represented by an
indicator vector z which is the concatenation of
N such vectors, z = 〈z1, . . . ,zN 〉; each position
in this indicator vector is indexed by a sentence
n ∈ [N ] and a word position ` ∈ {0} ∪ [Ln].

Models for compressive summarization were
proposed by Martins and Smith (2009) and Berg-
Kirkpatrick et al. (2011) by combining extraction
and compression scores. Here, we follow the lat-
ter work, by combining a coverage score function
g with sentence-level compression score functions
h1, . . . , hN . This yields the decoding problem:

maximize g(z) +
∑N

n=1 hn(zn)

w.r.t. zn ∈ {0, 1}Ln , ∀n ∈ [N ]
s.t.

∑N
n=1

∑Ln
`=1 zn,` ≤ B. (4)

3.1 Coverage Model
We use a coverage function similar to Eq. 2, but
taking a compressive summary z as argument:

g(z) =
∑M

m=1 σmum(z), (5)

where we redefine um as follows. First, we
parametrize each occurrence of the mth concept
(assumed to be a k-gram) as a triple 〈n, `s, `e〉,
where n indexes a sentence, `s indexes a start po-
sition within the sentence, and `e indexes the end
position. We denote by Tm the set of triples repre-
senting all occurrences of the mth concept in the
original text, and we associate an indicator vari-
able zn,`s:`e to each member of this set. We then
define um(z) via the following logic constraints:

• A concept type is selected if some of its k-gram
tokens are selected:

um(y) :=
∨
〈n,`s,`e〉∈Tm zn,`s:`e . (6)

• A k-gram concept token is selected if all its
words are selected:

zn,`s:`e :=
∧`e
`=`s

zn,`. (7)

198



Sentences
$     The      leader    of   moderate  Kashmiri  separatists warned   Thursday   that ...

$     Talks    with   Kashmiri  separatists began    last       year ...

"Kashmiri separatists"

Budget

Concept tokens

Concept type

Figure 1: Components of our compressive summarizer. Factors depicted in blue belong to the compres-
sion model, and aim to enforce grammaticality. The logic factors in red form the coverage component.
Finally, the budget factor, in green, is connected to the word nodes; it ensures that the summary fits the
word limit. Shaded circles represent active variables while white circles represent inactive variables.

We set concept scores as σm := w · Φcov(D, cm),
where Φcov(D, cm) is a vector of features (de-
scribed in §3.5) and w the corresponding weights.

3.2 Compression Model
For the compression score function, we follow
Martins and Smith (2009) and decompose it as a
sum of local score functions ρn,` defined on de-
pendency arcs:

hn(zn) :=
∑Ln

`=1 ρn,`(zn,`, zn,π(`)), (8)

where π(`) denotes the index of the word which
is the parent of the `th word in the dependency
tree (by convention, the root of the tree is the
dummy symbol). To model the event that an
arc is “cut” by disconnecting a child from its
head, we define arc-deletion scores ρn,`(0, 1) :=
w · Φcomp(sn, `, π(`)), where Φcomp is a feature
map, which is described in detail in §3.5. We set
ρn,`(0, 0) = ρn,`(1, 1) = 0, and ρn,`(1, 0) = −∞,
to allow only the deletion of entire subtrees.

A crucial fact is that one can maximize Eq. 8
efficiently with dynamic programming (using the
Viterbi algorithm for trees); the total cost is linear
in Ln. We will exploit this fact in the dual decom-
position framework described next.4

3.3 A Dual Decomposition Formulation
In previous work, the optimization problem in
Eq. 4 was converted into an ILP and fed to an off-
the-shelf solver (Martins and Smith, 2009; Berg-
Kirkpatrick et al., 2011; Woodsend and Lapata,
2012). Here, we employ the AD3 algorithm, in a

4The same framework can be readily adapted to other
compression models that are efficiently decodable, such as
the semi-Markov model of McDonald (2006), which would
allow incorporating a language model for the compression.

similar manner as described in §2, but with an ad-
ditional component for the sentence compressor,
and slight modifications in the other components.
We have the following N +M +

∑M
m=1 |Tm|+ 1

components in total, illustrated in Figure 1:

1. For each of the N sentences, one component
for the compression model. The AD3 quadratic
subproblem for this factor can be addressed by
solving a sequence of linear subproblems, as de-
scribed by Martins et al. (2012). Each of these
subproblems corresponds to maximizing an ob-
jective function of the same form as Eq. 8; this
can be done in O(Ln) time with dynamic pro-
gramming, as discussed in §3.2.

2. For each of the M concept types in C(D),
one OR-WITH-OUTPUT factor for the logic con-
straint in Eq. 6. This is analogous to the one
described for the extractive case.

3. For each k-gram concept token in Tm, one
AND-WITH-OUTPUT factor that imposes the
constraint in Eq. 7. This factor was described
by Martins et al. (2011b) and its AD3 subprob-
lem can be solved in time linear in k.

4. Another component linked to all the words im-
posing that at most B words can be selected;
this is done via a BUDGET factor, a particular
case of KNAPSACK. The runtime of this AD3

subproblem is linear in the number of words.

In addition, we found it useful to add a second
BUDGET factor limiting the number of sentences
that can be selected to a prescribed value K. We
set K = 6 in our experiments.

199



3.4 Rounding Strategy

Recall that the problem in Eq. 4 is NP-hard, and
that AD3 is solving a linear relaxation. While
there are ways of wrapping AD3 in an exact search
algorithm (Das et al., 2012), such strategies work
best when the solution of the relaxation has few
fractional components, which is typical of pars-
ing and translation problems (Rush et al., 2010;
Chang and Collins, 2011), and attractive networks
(Taskar et al., 2004). Unfortunately, this is not the
case in summarization, where concepts “compete”
with each other for inclusion in the summary, lead-
ing to frustrated cycles. We chose instead to adopt
a fast and simple rounding procedure for obtaining
a summary from a fractional solution.

The procedure works as follows. First, solve
the LP relaxation using AD3, as described above.
This yields a solution z∗, where each component
lies in the unit interval [0, 1]. If these components
are all integer, then we have a certificate that this
is the optimal solution. Otherwise, we collect the
K sentences with the highest values of z∗n,0 (“pos-
teriors” on sentences), and seek the feasible sum-
mary which is the closest (in Euclidean distance)
to z∗, while only containing those sentences. This
can be computed exactly in timeO(B

∑K
k=1 Lnk),

through dynamic programming.5

3.5 Features and Hard Constraints

As Berg-Kirkpatrick et al. (2011), we used
stemmed word bigrams as concepts, to which we
associate the following concept features (Φcov):
indicators for document counts, features indicat-
ing if each of the words in the bigram is a stop-
word, the earliest position in a document each con-
cept occurs, as well as two and three-way conjunc-
tions of these features.

For the compression model, we include the fol-
lowing arc-deletion features (Φcomp):

• the dependency label of the arc being deleted, as
well as its conjunction with the part-of-speech
tag of the head, of the modifier, and of both;

• the dependency labels of the arc being deleted
and of its parent arc;

• the modifier tag, if the modifier is a function
word modifying a verb ;

5Briefly, if we link the roots of theK sentences to a super-
root node, the problem above can be transformed into that
of finding the best configuration in the resulting binary tree
subject to a budget constraint. We omit details for space.

• a feature indicating whether the modifier or any
of its descendants is a negation word;

• indicators of whether the modifier is a temporal
word (e.g., Friday) or a preposition pointing to
a temporal word (e.g., on Friday).

In addition, we included hard constraints to pre-
vent the deletion of certain arcs, following pre-
vious work in sentence compression (Clarke and
Lapata, 2008). We never delete arcs whose de-
pendency label is SUB, OBJ, PMOD, SBAR, VC, or
PRD (this makes sure we preserve subjects and ob-
jects of verbs, arcs departing from prepositions or
complementizers, and that we do not break verb
chains or predicative complements); arcs linking
to a conjunction word or siblings of such arcs (to
prevent inconsistencies in handling coordinative
conjunctions); arcs linking verbs to other verbs,
to adjectives (e.g., make available), to verb parti-
cles (e.g., settle down), to the word that (e.g., said
that), or to the word to if it is a leaf (e.g., allowed
to come); arcs pointing to negation words, cardinal
numbers, or determiners; and arcs connecting two
proper nouns or words within quotation marks.

4 Multi-Task Learning

We next turn to the problem of learning the model
from training data. Prior work in compressive
summarization has followed one of two strategies:
Martins and Smith (2009) and Woodsend and La-
pata (2012) learn the extraction and compression
models separately, and then post-combine them,
circumventing the lack of fully annotated data.
Berg-Kirkpatrick et al. (2011) gathered a small
dataset of manually compressed summaries, and
trained with full supervision. While the latter
approach is statistically more principled, it has
the disadvantage of requiring fully annotated data,
which is difficult to obtain in large quantities. On
the other hand, there is plenty of data contain-
ing manually written abstracts (from the DUC and
TAC conferences) and user-generated text (from
Wikipedia) that may provide useful weak supervi-
sion.

With this in mind, we put together a multi-task
learning framework for compressive summariza-
tion (which we name task #1). The goal is to
take advantage of existing data for related tasks,
such as extractive summarization (task #2), and
sentence compression (task #3). The three tasks
are instances of structured predictors (Bakır et

200



Tasks Features Decoder
Comp. summ. (#1) Φcov, Φcomp AD3 (solve Eq. 4)

Extr. summ. (#2) Φcov AD3 (solve Eq. 3)
Sent. comp. (#3) Φcomp dyn. prg. (max. Eq. 8)

Table 1: Features and decoders used for each task.

al., 2007), and for all of them we assume feature-
based models that decompose over “parts”:

• For the compressive summarization task, the
parts correspond to concept features (§3.1) and
to arc-deletion features (§3.2).
• For the extractive summarization task, there are

parts for concept features only.

• For the sentence compression task, the parts
correspond to arc-deletion features only.

This is summarized in Table 1. Features for
the three tasks are populated into feature vectors
Φ1(x, y), Φ2(x, y), and Φ3(x, y), respectively,
where 〈x, y〉 denotes a task-specific input-output
pair. We assume the feature vectors are all D di-
mensional, where we place zeros in entries cor-
responding to parts that are absent. Note that
this setting is very general and applies to arbi-
trary structured prediction problems (not just sum-
marization), the only assumption being that some
parts are shared between different tasks.

Next, we associate weight vectors v1,v2,v3 ∈
RD to each task, along with a “shared” vector w.
Each task makes predictions according to the rule:

ŷ := arg max
y

(w + vk) · Φk(x, y), (9)

where k ∈ {1, 2, 3}. This setting is equiva-
lent to the approach of Daumé (2007) for domain
adaptation, which consists in splitting each fea-
ture into task-component features and a shared
feature; but here we do not duplicate features ex-
plicitly. To learn the weights, we regularize the
weight vectors separately, and assume that each
task has its own loss function Lk, so that the to-
tal loss L is a weighted sum L(w,v1,v2,v3) :=∑3

k=1 σkLk(w + vk). This yields the following
objective function to be minimized:

F (w,v1,v2,v3) =
λ

2
‖w‖2 +

3∑

k=1

λk
2
‖vk‖2

+
1

N

3∑

k=1

σkLk(w + vk), (10)

where λ and the λk’s are regularization constants,
andN is the total number of training instances.6 In
our experiments (§5), we let the Lk’s be structured
hinge losses (Taskar et al., 2003; Tsochantaridis et
al., 2004), where the corresponding cost functions
are concept recall (for task #2), precision of arc
deletions (for task #3), and a combination thereof
(for task #1).7 These losses were normalized, and
we set σk = N/Nk, where Nk is the number of
training instances for the kth task. This ensures
all tasks are weighted evenly. We used the same
rationale to set λ = λ1 = λ2 = λ3, choosing this
value through cross-validation in the dev set.

We optimize Eq. 10 with stochastic subgradient
descent. This leads to update rules of the form

w ← (1− ηtλ)w − ηtσk∇̃Lk(w + vk)
vj ← (1− ηtλj)vj − ηtδjkσk∇̃Lk(w + vk),

where ∇̃Lk are stochastic subgradients for the kth
task, that take only a single instance into account,
and δjk = 1 if and only if j = k. Stochastic sub-
gradients can be computed via cost-augmented de-
coding (see footnote 7).

Interestingly, Eq. 10 subsumes previous ap-
proaches to train compressive summarizers. The
limit λ→∞ (keeping the λk’s fixed) forces w →
0, decoupling all the tasks. In this limit, inference
for task #1 (compressive summarization) is based
solely on the model learned from that task’s data,
recovering the approach of Berg-Kirkpatrick et al.
(2011). In the other extreme, setting σ1 = 0 sim-
ply ignores task #1’s training data. As a result, the
optimal v1 will be a vector of zeros; since tasks
#2 and #3 have no parts in common, the objective
will decouple into a sum of two independent terms

6Note that, by substituting uk := w+vk and solving for
w, the problem in Eq. 10 becomes that of minimizing the sum
of the losses with a penalty for the (weighted) variance of the
vectors {0,u1,u2,u3}, regularizing the difference towards
their average, as in Evgeniou and Pontil (2004). This is sim-
ilar to the hierarchical joint learning approach of Finkel and
Manning (2010), except that our goal is to learn a new task
(compressive summarization) instead of combining tasks.

7Let Yk denote the output set for the kth task. Given
a task-specific cost function ∆k : Yk × Yk → R,
and letting 〈xt, yt〉Tt=1 be the labeled dataset for this
task, the structured hinge loss takes the form Lk(uk) :=∑

tmaxy′∈Yk(uk · (Φk(xt, y′)− Φk(xt, yt)) + ∆k(y′, yt)).
The inner maximization over y′ is called the cost-augmented
decoding problem: it differs from Eq. 9 by the inclusion
of the cost term ∆k(y′, yt). Our costs decompose over the
model’s factors, hence any decoder for Eq. 9 can be used
for the maximization above: for tasks #1–#2, we solve a
relaxation by running AD3 without rounding, and for task #3
we use dynamic programming; see Table 1.

201



involving v2 and v3, which is equivalent to train-
ing the two tasks separately and post-combining
the models, as Martins and Smith (2009) did.

5 Experiments

5.1 Experimental setup

We evaluated our compressive summarizers on
data from the Text Analysis Conference (TAC)
evaluations. We use the same splits as previ-
ous work (Berg-Kirkpatrick et al., 2011; Wood-
send and Lapata, 2012): the non-update portions
of TAC-2009 for training and TAC-2008 for test-
ing. In addition, we reserved TAC-2010 as a dev-
set. The test partition contains 48 multi-document
summarization problems; each provides 10 related
news articles as input, and asks for a summary
with up to 100 words, which is evaluated against
four manually written abstracts. We ignored all
the query information present in the TAC datasets.

Single-Task Learning. In the single-task exper-
iments, we trained a compressive summarizer on
the dataset disclosed by Berg-Kirkpatrick et al.
(2011), which contains manual compressive sum-
maries for the TAC-2009 data. We trained a struc-
tured SVM with stochastic subgradient descent;
the cost-augmented inference problems are re-
laxed and solved with AD3, as described in §3.3.8
We followed the procedure described in Berg-
Kirkpatrick et al. (2011) to reduce the number of
candidate sentences: scores were defined for each
sentence (the sum of the scores of the concepts
they cover), and the best-scored sentences were
greedily selected up to a limit of 1,000 words. We
then tagged and parsed the selected sentences with
TurboParser.9 Our choice of a dependency parser
was motivated by our will for a fast system; in par-
ticular, TurboParser attains top accuracies at a rate
of 1,200 words per second, keeping parsing times
below 1 second for each summarization problem.

Multi-Task Learning. For the multi-task ex-
periments, we also used the dataset of Berg-
Kirkpatrick et al. (2011), but we augmented the
training data with extractive summarization and
sentence compression datasets, to help train the

8We use the AD3 implementation in http://www.
ark.cs.cmu.edu/AD3, setting the maximum number of
iterations to 200 at training time and 1000 at test time. We
extended the code to handle the knapsack and budget factors;
the modified code will be part of the next release (AD3 2.1).

9http://www.ark.cs.cmu.edu/TurboParser

compressive summarizer. For extractive sum-
marization, we used the DUC 2003 and 2004
datasets (a total of 80 multi-document summariza-
tion problems). We generated oracle extracts by
maximizing bigram recall with respect to the man-
ual abstracts, as described in Berg-Kirkpatrick et
al. (2011). For sentence compression, we adapted
the Simple English Wikipedia dataset of Wood-
send and Lapata (2011), containing aligned sen-
tences for 15,000 articles from the English and
Simple English Wikipedias. We kept only the
4,481 sentence pairs corresponding to deletion-
based compressions.

5.2 Results
Table 2 shows the results. The top rows refer
to three strong baselines: the ICSI-1 extractive
coverage-based system of Gillick et al. (2008),
which achieved the best ROUGE scores in the
TAC-2008 evaluation; the compressive summa-
rizer of Berg-Kirkpatrick et al. (2011), denoted
BGK’11; and the multi-aspect compressive sum-
marizer of Woodsend and Lapata (2012), denoted
WL’12. All these systems require ILP solvers.
The bottom rows show the results achieved by
our implementation of a pure extractive system
(similar to the learned extractive summarizer of
Berg-Kirkpatrick et al., 2011); a system that post-
combines extraction and compression components
trained separately, as in Martins and Smith (2009);
and our compressive summarizer trained as a sin-
gle task, and in the multi-task setting.

The ROUGE and Pyramid scores show that the
compressive summarizers (when properly trained)
yield considerable benefits in content coverage
over extractive systems, confirming the results of
Berg-Kirkpatrick et al. (2011). Comparing the
two bottom rows, we see a clear benefit by train-
ing in the multi-task setting, with a consistent
gain in both coverage and linguistic quality. Our
ROUGE-2 score (12.30%) is, to our knowledge,
the highest reported on the TAC-2008 dataset,
with little harm in grammaticality with respect to
an extractive system that preserves the original
sentences. Figure 2 shows an example summary.

5.3 Runtimes
We conducted another set of experiments to com-
pare the runtime of our compressive summarizer
based on AD3 with the runtimes achieved by
GLPK, the ILP solver used by Berg-Kirkpatrick et
al. (2011). We varied the maximum number of it-

202



System R-2 R-SU4 Pyr LQ
ICSI-1 11.03 13.96 34.5† –
BGK’11 11.71 14.47 41.3† –
WL’12 11.37 14.47 – –
Extractive 11.16 14.07 36.0 4.6
Post-comb. 11.07 13.85 38.4 4.1
Single-task 11.88 14.86 41.0 3.8
Multi-task 12.30 15.18 42.6 4.2

Table 2: Results for compressive summarization.
Shown are the ROUGE-2 and ROUGE SU-4 re-
calls with the default options from the ROUGE
toolkit (Lin, 2004); Pyramid scores (Nenkova and
Passonneau, 2004); and linguistic quality scores,
scored between 1 (very bad) to 5 (very good). For
Pyramid, the evaluation was performed by two
annotators, each evaluating half of the problems;
scores marked with † were computed by different
annotators and are not directly comparable. Lin-
guistic quality was evaluated by two linguists; we
show the average of the reported scores.

Solver Runtime (sec.) ROUGE-2
ILP Exact 10.394 12.40
LP-Relax. 2.265 12.38
AD3-5000 0.952 12.38
AD3-1000 0.406 12.30
AD3-200 0.159 12.15
Extractive (ILP) 0.265 11.16

Table 3: Runtimes of several decoders on a Intel
Core i7 processor @2.8 GHz, with 8GB RAM. For
each decoder, we show the average time taken to
solve a summarization problem in TAC-2008. The
reported runtimes of AD3 and LP-Relax include
the time taken to round the solution (§3.4), which
is 0.029 seconds on average.

erations of AD3 in {200, 1000, 5000}, and clocked
the time spent by GLPK to solve the exact ILPs
and their relaxations. Table 3 depicts the results.10

We see that our proposed configuration (AD3-
1000) is orders of magnitude faster than the ILP
solver, and 5 times faster than its relaxed variant,
while keeping similar accuracy levels.11 The gain
when the number of iterations in AD3 is increased
to 5000 is small, given that the runtime is more

10Within dual decomposition algorithms, we verified ex-
perimentally that AD3 is substantially faster than the subgra-
dient algorithm, which is consistent with previous findings
(Martins et al., 2011b).

11The runtimes obtained with the exact ILP solver seem
slower than those reported by Berg-Kirkpatrick et al. (2011).
(around 1.5 sec. on average, according to their Fig. 3). We
conjecture that this difference is due to the restricted set of
subtrees that can be deleted by Berg-Kirkpatrick et al. (2011),
which greatly reduces their search space.

Japan dispatched four military ships to help Russia res-
cue seven crew members aboard a small submarine
trapped on the seabed in the Far East. The Russian
Pacific Fleet said the crew had 120 hours of oxygen
reserves on board when the submarine submerged at
midday Thursday (2300 GMT Wednesday) off the Kam-
chatka peninsula, the stretch of Far Eastern Russia fac-
ing the Bering Sea. The submarine, used in rescue,
research and intelligence-gathering missions, became
stuck at the bottom of the Bay of Berezovaya off Rus-
sia’s Far East coast when its propeller was caught in a
fishing net. The Russian submarine had been tending
an underwater antenna mounted to the sea floor when it
became snagged on a wire helping to stabilize a ventila-
tion cable attached to the antenna. Rescue crews low-
ered a British remote-controlled underwater vehicle to a
Russian mini-submarine trapped deep under the Pacific
Ocean, hoping to free the vessel and its seven trapped
crewmen before their air supply ran out.

Figure 2: Example summary from our compres-
sive system. Removed text is grayed out.

than doubled; accuracy starts to suffer, however, if
the number of iterations is reduced too much. In
practice, we observed that the final rounding pro-
cedure was crucial, as only 2 out of the 48 test
problems had integral solutions (arguably because
of the “repulsive” nature of the network, as hinted
in §3.4). For comparison, we also report in the bot-
tom row the average runtime of the learned extrac-
tive baseline. We can see that our system’s runtime
is competitive with this baseline. To our knowl-
edge, this is the first time a compressive sum-
marizer achieves such a favorable accuracy/speed
tradeoff.

6 Conclusions

We presented a multi-task learning framework for
compressive summarization, leveraging data for
related tasks in a principled manner. We decode
with AD3, a fast and modular dual decomposition
algorithm which is orders of magnitude faster than
ILP-based approaches. Results show that the state
of the art is improved in automatic and manual
metrics, with speeds close to extractive systems.

Our approach is modular and easy to extend.
For example, a different compression model could
incorporate rewriting rules to enable compres-
sions that go beyond word deletion, as in Cohn
and Lapata (2008). Other aspects may be added
as additional components in our dual decom-
position framework, such as query information
(Schilder and Kondadadi, 2008), discourse con-

203



straints (Clarke and Lapata, 2007), or lexical pref-
erences (Woodsend and Lapata, 2012). Our multi-
task approach may be used to jointly learn pa-
rameters for these aspects; the dual decomposi-
tion algorithm ensures that optimization remains
tractable even with many components.

A Projection Onto Knapsack

This section describes a linear-time algorithm (Al-
gorithm 1) for solving the following problem:

minimize ‖z − a‖2
w.r.t. zn ∈ [0, 1], ∀n ∈ [N ],

s.t.
∑N

n=1 Lnzn ≤ B, (11)

where a ∈ RN and Ln ≥ 0,∀n ∈ [N ]. This in-
cludes as special cases the problems of projecting
onto a budget constraint (Ln = 1,∀n) and onto
the simplex (same, plus B = 1).

Let clip(t) := max{0,min{1, t}}. Algorithm 1
starts by clipping a to the unit interval; if that
yields a z satisfying

∑N
n=1 Lnzn ≤ B, we are

done. Otherwise, the solution of Eq. 11 must sat-
isfy

∑N
n=1 Lnzn = B. It can be shown from the

KKT conditions that the solution is of the form
z∗n := clip(an+ τ

∗Ln) for a constant τ∗ lying in a
particular interval of split-points (line 11). To seek
this constant, we use an algorithm due to Pardalos
and Kovoor (1990) which iteratively shrinks this
interval. The algorithm requires computing medi-
ans as a subroutine, which can be done in linear
time (Blum et al., 1973). The overall complexity
in O(N) (Pardalos and Kovoor, 1990).

Acknowledgments

We thank all reviewers for their insightful com-
ments; Trevor Cohn for helpful discussions about
multi-task learning; Taylor Berg-Kirkpatrick for
answering questions about their summarizer and
for providing code; and Helena Figueira and Pedro
Mendes for helping with manual evaluation. This
work was partially supported by the EU/FEDER
programme, QREN/POR Lisboa (Portugal), under
the Discooperio project (contract 2011/18501),
and by a FCT grant PTDC/EEI-SII/2312/2012.

References
G. Bakır, T. Hofmann, B. Schölkopf, A. Smola,

B. Taskar, and S. Vishwanathan. 2007. Predicting
Structured Data. The MIT Press.

Algorithm 1 Projection Onto Knapsack.
1: input: a := 〈an〉Nn=1, costs 〈Ln〉Nn=1, maximum cost B
2:
3: {Try to clip into unit interval:}
4: Set zn ← clip(an) for n ∈ [N ]
5: if

∑N
n=1 Lnzn ≤ B then

6: Return z and stop.
7: end if
8:
9: {Run Pardalos and Kovoor (1990)’s algorithm:}

10: Initialize working set W← {1, . . . ,K}
11: Initialize set of split points:

P← {−an/Ln, (1− an)/Ln}Nn=1 ∪ {±∞}
12: Initialize τL ← −∞, τR ←∞, stight ← 0, ξ ← 0.
13: while W 6= ∅ do
14: Compute τ ← Median(P)
15: Set s← stight + ξτ +

∑
n∈W Lnclip(an + τLn)

16: If s ≤ B, set τL ← τ ; if s ≥ B, set τR ← τ
17: Reduce set of split points: P← P ∩ [τL, τR]
18: Define the sets:

WL := {n ∈W | (1− an)/Ln < τL}
WR := {n ∈W | − an/Ln > τR}

WM :=

{
n ∈W

∣∣∣∣ −
an
Ln
≤ τL ∧ 1− an

Ln
≥ τR

}

19: Update working set: W←W \ (WL ∪WR ∪WM)
20: Update tight-sum:

stight ← stight+
∑

n∈WL Ln(1−an)−
∑

n∈WR Lnan

21: Update slack-sum: ξ ← ξ +∑n∈WM L
2
n

22: end while
23: Define τ∗ ← (B −∑Ni=1 Liai − stight)/ξ
24: Set zn ← clip(an + τ∗Ln), ∀n ∈ [N ]
25: output: z := 〈zn〉Nn=1.

P. B. Baxendale. 1958. Machine-made index for tech-
nical literature—an experiment. IBM Journal of Re-
search Development, 2(4):354–361.

Taylor Berg-Kirkpatrick, Dan Gillick, and Dan Klein.
2011. Jointly learning to extract and compress. In
Proc. of Annual Meeting of the Association for Com-
putational Linguistics.

Manuel Blum, Robert W Floyd, Vaughan Pratt,
Ronald L Rivest, and Robert E Tarjan. 1973. Time
bounds for selection. Journal of Computer and Sys-
tem Sciences, 7(4):448–461.

J. Carbonell and J. Goldstein. 1998. The use of MMR,
diversity-based reranking for reordering documents
and producing summaries. In SIGIR.

Y.-W. Chang and M. Collins. 2011. Exact decoding of
phrase-based translation models through lagrangian
relaxation. In Proc. of Empirical Methods for Natu-
ral Language Processing.

James Clarke and Mirella Lapata. 2007. Modelling
compression with discourse constraints. In Proc. of
Empirical Methods in Natural Language Process-
ing.

J. Clarke and M. Lapata. 2008. Global Inference for
Sentence Compression An Integer Linear Program-

204



ming Approach. Journal of Artificial Intelligence
Research, 31:399–429.

T. Cohn and M. Lapata. 2008. Sentence compression
beyond word deletion. In Proc. COLING.

D. Das, A. F. T. Martins, and N. A. Smith. 2012. An
Exact Dual Decomposition Algorithm for Shallow
Semantic Parsing with Constraints. In Proc. of First
Joint Conference on Lexical and Computational Se-
mantics (*SEM).

H. Daumé. 2006. Practical Structured Learning Tech-
niques for Natural Language Processing. Ph.D. the-
sis, University of Southern California.

H. Daumé. 2007. Frustratingly easy domain adapta-
tion. In Proc. of Annual Meeting of the Association
for Computational Linguistics.

H. P. Edmundson. 1969. New methods in automatic
extracting. Journal of the ACM, 16(2):264–285.

T. Evgeniou and M. Pontil. 2004. Regularized multi–
task learning. In Proc. of ACM SIGKDD Inter-
national Conference on Knowledge Discovery and
Data Mining, pages 109–117. ACM.

Elena Filatova and Vasileios Hatzivassiloglou. 2004.
A formal model for information selection in multi-
sentence text extraction. In Proc. of International
Conference on Computational Linguistics.

J.R. Finkel and C.D. Manning. 2010. Hierarchical
joint learning: Improving joint parsing and named
entity recognition with non-jointly labeled data. In
Proc. of Annual Meeting of the Association for Com-
putational Linguistics.

J. Gillenwater, A. Kulesza, and B. Taskar. 2012. Dis-
covering diverse and salient threads in document
collections. In Proc. of Empirical Methods in Natu-
ral Language Processing.

Dan Gillick, Benoit Favre, and Dilek Hakkani-Tur.
2008. The icsi summarization system at tac 2008.
In Proc. of Text Understanding Conference.

K. Knight and D. Marcu. 2000. Statistics-based
summarization—step one: Sentence compression.
In AAAI/IAAI.

N. Komodakis, N. Paragios, and G. Tziritas. 2007.
MRF optimization via dual decomposition:
Message-passing revisited. In Proc. of International
Conference on Computer Vision.

J. Kupiec, J. Pedersen, and F. Chen. 1995. A trainable
document summarizer. In SIGIR.

H. Lin and J. Bilmes. 2010. Multi-document summa-
rization via budgeted maximization of submodular
functions. In Proc. of Annual Meeting of the North
American chapter of the Association for Computa-
tional Linguistics.

H. Lin and J. Bilmes. 2012. Learning mixtures of sub-
modular shells with application to document sum-
marization. In Proc. of Uncertainty in Artificial In-
telligence.

C.-Y. Lin. 2003. Improving summarization perfor-
mance by sentence compression-a pilot study. In the
Int. Workshop on Inf. Ret. with Asian Languages.

Chin-Yew Lin. 2004. Rouge: A package for auto-
matic evaluation of summaries. In Stan Szpakowicz
Marie-Francine Moens, editor, Text Summarization
Branches Out: Proceedings of the ACL-04 Work-
shop, pages 74–81, Barcelona, Spain, July.

H. P. Luhn. 1958. The automatic creation of literature
abstracts. IBM Journal of Research Development,
2(2):159–165.

A. F. T. Martins and N. A. Smith. 2009. Summariza-
tion with a Joint Model for Sentence Extraction and
Compression. In North American Chapter of the As-
sociation for Computational Linguistics: Workshop
on Integer Linear Programming for NLP.

A. F. T. Martins, M. A. T. Figueiredo, P. M. Q. Aguiar,
N. A. Smith, and E. P. Xing. 2011a. An Aug-
mented Lagrangian Approach to Constrained MAP
Inference. In Proc. of International Conference on
Machine Learning.

A. F. T. Martins, N. A. Smith, P. M. Q. Aguiar, and
M. A. T. Figueiredo. 2011b. Dual Decomposition
with Many Overlapping Components. In Proc. of
Empirical Methods for Natural Language Process-
ing.

Andre F. T. Martins, Mario A. T. Figueiredo, Pedro
M. Q. Aguiar, Noah A. Smith, and Eric P. Xing.
2012. Alternating Directions Dual Decomposition.
Arxiv preprint arXiv:1212.6550.

R. McDonald. 2006. Discriminative sentence com-
pression with soft syntactic constraints. In Proc. of
Annual Meeting of the European Chapter of the As-
sociation for Computational Linguistics.

R. McDonald. 2007. A study of global inference algo-
rithms in multi-document summarization. In ECIR.

A. Nenkova and R. Passonneau. 2004. Evaluating
content selection in summarization: The pyramid
method. In Proceedings of NAACL, pages 145–152.

Panos M. Pardalos and Naina Kovoor. 1990. An al-
gorithm for a singly constrained class of quadratic
programs subject to upper and lower bounds. Math-
ematical Programming, 46(1):321–328.

D. R. Radev, H. Jing, and M. Budzikowska. 2000.
Centroid-based summarization of multiple docu-
ments: sentence extraction, utility-based evaluation,
and user studies. In the NAACL-ANLP Workshop on
Automatic Summarization.

205



A.M. Rush and M. Collins. 2012. A Tutorial on Dual
Decomposition and Lagrangian Relaxation for In-
ference in Natural Language Processing. Journal of
Artificial Intelligence Research, 45:305–362.

A. Rush, D. Sontag, M. Collins, and T. Jaakkola. 2010.
On dual decomposition and linear programming re-
laxations for natural language processing. In Proc.
of Empirical Methods for Natural Language Pro-
cessing.

Frank Schilder and Ravikumar Kondadadi. 2008. Fast-
sum: Fast and accurate query-based multi-document
summarization. In Proc. of Annual Meeting of the
Association for Computational Linguistics.

R. Sipos, P. Shivaswamy, and T. Joachims. 2012.
Large-margin learning of submodular summariza-
tion models.

B. Taskar, C. Guestrin, and D. Koller. 2003. Max-
margin Markov networks. In Proc. of Neural Infor-
mation Processing Systems.

B. Taskar, V. Chatalbashev, and D. Koller. 2004.
Learning associative Markov networks. In Proc. of
International Conference of Machine Learning.

I. Tsochantaridis, T. Hofmann, T. Joachims, and Y. Al-
tun. 2004. Support vector machine learning for in-
terdependent and structured output spaces. In Proc.
of International Conference of Machine Learning.

K. Woodsend and M. Lapata. 2010. Automatic gener-
ation of story highlights. In Proc. of Annual Meet-
ing of the Association for Computational Linguis-
tics, pages 565–574.

Kristian Woodsend and Mirella Lapata. 2011. Learn-
ing to simplify sentences with quasi-synchronous
grammar and integer programming. In Proc. of Em-
pirical Methods in Natural Language Processing.

Kristian Woodsend and Mirella Lapata. 2012. Mul-
tiple aspect summarization using integer linear pro-
gramming. In Proc. of Empirical Methods in Natu-
ral Language Processing.

Wen-tau Yih, Joshua Goodman, Lucy Vanderwende,
and Hisami Suzuki. 2007. Multi-document summa-
rization by maximizing informative content-words.
In Proc. of International Joint Conference on Artifi-
cal Intelligence.

D. Zajic, B. Dorr, J. Lin, and R. Schwartz. 2006.
Sentence compression as a component of a multi-
document summarization system. In the ACL DUC
Workshop.

206


