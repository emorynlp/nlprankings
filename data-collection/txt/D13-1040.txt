










































Unsupervised Relation Extraction with General Domain Knowledge


Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 415–425,
Seattle, Washington, USA, 18-21 October 2013. c©2013 Association for Computational Linguistics

Unsupervised Relation Extraction with General Domain Knowledge

Oier Lopez de Lacalle1,2 and Mirella Lapata1
1Institute for Language, Cognition and Computation

School of Informatics, University of Edinburgh, 10 Crichton Street, Edinburgh EH8 9AB
2IKERBASQUE, Basque Foundation for Science, Bilbao, Spain

oier.lopezdelacalle@ehu.es, mlap@inf.ed.ac.uk

Abstract

In this paper we present an unsupervised ap-
proach to relational information extraction.
Our model partitions tuples representing an
observed syntactic relationship between two
named entities (e.g., “X was born in Y”
and “X is from Y”) into clusters correspond-
ing to underlying semantic relation types
(e.g., BornIn, Located). Our approach incor-
porates general domain knowledge which we
encode as First Order Logic rules and auto-
matically combine with a topic model devel-
oped specifically for the relation extraction
task. Evaluation results on the ACE 2007
English Relation Detection and Categoriza-
tion (RDC) task show that our model outper-
forms competitive unsupervised approaches
by a wide margin and is able to produce clus-
ters shaped by both the data and the rules.

1 Introduction

Information extraction (IE) is becoming increas-
ingly useful as a form of shallow semantic analy-
sis. Learning relational facts from text is one of the
core tasks of IE and has applications in a variety
of fields including summarization, question answer-
ing, and information retrieval. Previous work (Sur-
deanu and Ciaramita, 2007; Culotta and Sorensen,
2004; Zhou et al., 2007) has traditionally relied on
extensive human involvement (e.g., hand-annotated
training instances, manual pattern extraction rules,
hand-picked seeds). Standard supervised techniques
can yield high performance when large amounts
of hand-labeled data are available for a fixed in-
ventory of relation types (e.g., Employment, Lo-
cated), however, extraction systems do not easily

generalize beyond their training domains and often
must be re-engineered for each application. Un-
supervised approaches offer a promising alternative
which could lead to significant resource savings and
more portable extraction systems.

It therefore comes as no surprise that latent topic
analysis methods have been used for a variety of
IE tasks. Yao et al. (2011), for example, propose
a series of topic models which perform relation
discovery by clustering tuples representing an ob-
served syntactic relationship between two named en-
tities (e.g., “X was born in Y” and “X is from Y”).
The clusters correspond to semantic relations whose
number or type is not known in advance. Their mod-
els depart from standard Latent Dirichlet Allocation
(Blei et al., 2003) in that a document consists of re-
lation tuples rather than individual words; moreover,
tuples have features each of which is generated in-
dependently from a hidden relation (e.g., the words
corresponding to the first and second entities, the
type and order of the named entities). Since these
features are local, they cannot capture more global
constraints pertaining to the relation extraction task.
Such constraints may take the form of restrictions
on which tuples should be clustered together or
not. For instance, different types of named entities
may be indicative of different relations (ORG-LOC
entities often express a Location relation whereas
PER-PER entities express Business or Family rela-
tions) and thus tuples bearing these entities should
not be grouped together. Another example are tuples
with identical or similar features which intuitively
should be clustered together.

In this paper, we propose an unsupervised ap-
proach to relation extraction which does not re-

415



quire any relation-specific training data and allows
to incorporate global constraints general express-
ing domain knowledge. We encode domain knowl-
edge as First Order Logic (FOL) rules and automati-
cally integrate them with a topic model to produce
clusters shaped by the data and the constraints at
hand. Specifically, we extend the Fold-all (First-
Order Logic latent Dirichlet Allocation) framework
(Andrzejewski et al., 2011) to the relation extraction
task, explain how to incorporate meaningful con-
straints, and develop a scalable inference technique.
In the presence of multiple candidate relation de-
compositions for a given corpus, domain knowledge
can steer the model towards relations which are best
aligned with user and task modeling goals. We also
argue that a general mechanism for encoding addi-
tional modeling assumptions and side information
can lessen the need for “custom” relation extraction
model variants. Experimental results on the ACE-
2007 Relation Detection and Categorization (RDC)
dataset show that our model outperforms competi-
tive unsupervised approaches by a wide margin and
is able to uncover meaningful relations with only
two general rule types.

Our contributions in this work are three-fold: a
new model that modifies the Fold-all framework and
extends it to the relation extraction task; a new for-
malization of the logic rules applicable to topic mod-
els defined over a rich set of features; and a proposal
for mining the logic rules automatically from a cor-
pus contrary to Andrzejewski et al. (2011) who em-
ploy manually crafted seeds.

2 Related Work

A variety of learning paradigms have been applied
to relation extraction. As mentioned earlier, super-
vised methods have been shown to perform well in
this task. The reliance on manual annotation, which
is expensive to produce and thus limited in quantity,
has provided the impetus for semi-supervised and
purely unsupervised approaches. Semi-supervised
methods use a small number of seed instances or
patterns (per relation) to launch an iterative train-
ing process (Riloff and Jones, 1999; Agichtein and
Gravano, 2000; Bunescu and Mooney, 2007; Pan-
tel and Pennacchiotti, 2006). The seeds are used
to extract a new set of patterns from a large cor-
pus, which are then used to extract more instances,

and so on. Unsupervised relation extraction meth-
ods are not limited to a predefined set of target
relations, but discover all types of relations found
in the text. The relations represent clusters over
strings of words (Banko et al., 2007; Hasegawa et
al., 2004), syntactic patterns between entities (Yao
et al., 2011; Shinyama and Sekine, 2006), or logical
expressions (Poon and Domingos, 2009). Another
learning paradigm is distant supervision which does
not require labeled data but instead access to a rela-
tional database such as Freebase (Mintz et al., 2009).
The idea is to take entities that appear in some rela-
tion in the database, find the sentences that express
the relation in an unlabeled corpus, and use them to
train a relation classifier.

Our own work adds an additional approach into
the mix. We use a topic model to infer an arbi-
trary number of relations between named entities.
Although we do not have access to relation-specific
information (either as a relational database or manu-
ally annotated data), we impose task-specific con-
straints which inject domain knowledge into the
learning algorithm. We thus alleviate known prob-
lems with the interpretability of the clusters obtained
from topic models and are able to guide our model
towards reasonable relations. Andrzejewski et al.
(2011) show how to integrate First-Order Logic with
vanilla LDA. We extend their formulation to relation
tuples rather than individual words. Our model gen-
erates a corpus of entity tuples which are in turn rep-
resented by features and uses automatically acquired
FOL rules. The idea of integrating topic modeling
with FOL builds on research in probabilistic logic
modeling such as Markov Logic Networks (Richard-
son and Domingos, 2006). Schoenmackers et al.
(2010) learn Horn clauses from web-scale text with
aim of finding answers to a user’s query. Our work
is complementary to theirs. We could make use of
their rules to discover more accurate relations.

The general goal of assisting the learner in re-
covering the “correct” clustering by supplying ad-
ditional domain knowledge is not new. Gondek and
Hofmann (2004) supply a known clustering they do
not want the learner to return, whereas Wagstaff
et al. (2001) use pairwise labels for items indicat-
ing whether they belong in the same cluster. These
methods combine domain knowledge with statistical
learning in order to improve performance with re-

416



spect to the true target clustering. Although, the tar-
get labels are not available in our case, we are able to
show that the inclusion of domain knowledge yields
clustering improvements.

3 Learning Setting

Our relation extraction task broadly adheres to the
ACE specification guidelines. Our aim is to detect
and characterize the semantic relations between
two named entities. The input to our model is a
corpus of documents, where each document is a
bag of relation tuples which can be obtained from
the output of any dependency parser. Each tuple
represents a syntactic relationship between two
named entity (NE) mentions, and consists of three
components: the dependency path between the
two mentions, the source NE, and the target NE. A
dependency path is the concatenation of dependency
edges and nodes along a path in the dependency
tree. For example, the sentence “George Bush
traveled to France on Thursday for a summit.”
would yield the tuple [SOURCE:George Bush(PER),
PATH:→nsubj→traveled→prep→to→pobj→,
DES:France(LOC)]. The tuple here expresses the
relation Located, however our model does not
observe any relation labels during training. The
model assigns tuples to clusters, corresponding to
an underlying relation type. Each tuple instance can
be then labeled with an identifier corresponding to
the cluster (aka relation) it has been assigned to.

4 Modeling Framework

Our model builds on the work of Yao et al. (2011)
who develop a series of generative probabilistic
models for relation extraction. Specifically, we ex-
tend their relational LDA model by interfacing it
with FOL-rules. In the following, we first describe
their approach in more detail and then present our
extensions and modifications.

4.1 Relational LDA

Relational LDA is an extension to LDA with a sim-
ilar generative story. LDA models each document
as a mixture of topics, which are in turn character-
ized as distributions over words. In relational LDA,
each document is a mixture of relations over tuples
representing syntactic relations between two named
entities. The relation tuples are in turn generated a

by set of features drawn independently from the un-
derlying relation distribution.

More technically, a multinomial distribution over
relations θdi is drawn from a Dirichlet prior
(θ ∼ Dir(α)) at the document level. Relation tuples
are generated from a multinomial distribution θdi
(zi|θdi ∼ Mult(θdi)) and are represented with k fea-
tures. Each feature is drawn (independently) from
a multinomial distribution selected by the relation
assigned to tuple i (fik|zi, φzi ∼ Mult(φzi)). Rela-
tions are drawn from a Dirichlet prior (φ ∼ Dir(β)).
In other words, each tuple in a document is assigned
a hidden relation (z = z1...zN ); each relation is
represented by a multinomial distribution over fea-
tures φr (Dirichlet prior β). φr is a vector with F
dimensions each corresponding to a feature. Fi-
nally, documents (j = 1...D) are associated with a
multinomial distribution θj over relations (Dirichlet
prior α). θj is a vector with R dimensions, one for
each relation.

Figure 1 represents relational LDA model as a an
undirected graphical model or factor graph (Bishop,
2006), ignoring for the moment the factor which
connects the d, z, f1...k and o variables. Directed
graphical models can be converted into undirected
ones by adding edges between co-parents (Koller
and Friedman, 2009). Each clique in the graph de-
fines a potential function which replaces the condi-
tional probabilities in the directed graph. Each max-
imal clique is associated with a special factor node
(the black squares) and clique members are con-
nected to that factor. The probability of any specific
configuration is calculated by multiplying the poten-
tial functions and normalizing them. We adopt the
factor graph representation as is it convenient for in-
troducing logic rules into the model. The joint prob-
ability of the model given the priors and the docu-
ments (P (p, z, φ, θ|α, β,d)) is equivalent to:

R∏
r

p(φr|β)
D∏
j

p(θj |α)
N∏
i

θdi(zi)
∏
k∈pi

φzi(fk) (1)

where θdi(zi) is the zi-th element in the vector θdi
and φzi(fk) is fk-th feature in the φzi vector. Vari-
able pi is the i-th tuple containing k features. The
parameters of the latent variables (e.g., φ, θ) are
typically estimated using an approximate inference
algorithm such as Gibbs Sampling (Griffiths and
Steyvers, 2004).

417



Figure 1: Relational LDA as a factor graph. Filled
circles represent observed variables, empty circles are
associated with latent variables or model hyperparame-
ters, and plates indicate repeating structures. The black
squares are the factor nodes and are associated with the
potential functions corresponding to conditional indepen-
dence among the variables. The model observes D doc-
uments (d) consisting of N tuples (p), each represented
by a set of features f1,f2 . . . fk. z represents the relation
type assignment to a tuple, θ is the relation type propor-
tion for a given document, and φ the relation type dis-
tribution over the features. The logic factor (indicated
with the arrow) connects the KB with the relational LDA
model. Variable o is an observed variable which contains
the side information expressed in FOL.

As shown in Figure 1, the observed variables are
represented by filled circles. In our case, our model
sees the corpus (p, d), where d is the variable rep-
resenting the document and the tuples (p) are repre-
sented by a set of features f1,f2 . . . fk in the graph.
Empty circles are associated with latent variables to
be estimated: z represents the relation type assign-
ment to the tuple, θ is the relation type proportion
for the given document, and φ is the relation type
distribution over the features.

The features representing the tuples tap onto se-
mantic information expressed by different surface
forms and are an important part of the model. We
use a subset of the features proposed in Yao et al.
(2011) which we briefly describe below:

SOURCE This feature corresponds to the first en-
tity mention of the tuple. In the sentence George
Bush traveled to France on Thursday for a summit.,
the value of this feature would be George Bush .

Value Predicate Description
zi = r Z(i, r) Latent relation type
fk = v F(k, v) feature of relation tuple
pi = i P(i, fk) tuple i contains feature fk
di = j D(i, j) observed document

Table 1: Logical variables for Relational LDA. The vari-
able i ranges over tuples in the corpus (i = [1 . . . N ]),
and k over features in the corpus (k = [1 . . . F ]).

DEST The feature corresponds to the second entity
mention and its value would be France in the previ-
ous example.

NEPAIR The feature indicates the type and order
of two entity mentions in the tuple. This would
be PER-ORG in our example.

PATH This feature refers to the dependency
path between two entity mentions. In our
sentence, the value of the feature would be
PATH:→nsubj→traveled→prep→to→pobj→.

TRIGGER Finally, trigger features are content
words occurring in the dependency path. The path
PATH:→nsubj→traveled→prep→to→pobj→ con-
tains only one trigger word, namely traveled. The
intuition behind this feature is that paths sharing the
same set of trigger words should be grouped in the
same cluster.

4.2 First Order Logic and Relational LDA
We next couple relational LDA with global con-
straints, which we express using FOL rules. We
begin by representing relational LDA as a Markov
Logic Network (Richardson and Domingos, 2006).
We define a logical predicate for each model vari-
able. For example, assigned relation variable
(Z(i, r)) is true if zi = r and false otherwise. Table 1
shows the mapping of model variables onto logical
predicates. Logical rules are encoded in the form of
a weighted FOL knowledge base (KB) which is then
converted into Conjunctive Normal form:

KB = {(λ1, ψ1), ..., (λL, ψL)} (2)

The KB consists of L pairs, where each ψl rep-
resents a FOL rule and λl ≥ 0 its weight. Rules
are soft preferences rather than hard constraints;
the weights represent the importance of ψl and are

418



set manually by the domain expert. The KB is
tied to the probabilistic model via its groundings
in the corpus. For each FOL rule ψl, let G(ψl) be
the set of groundings, each mapping the free vari-
ables in ψl to a specific value. For example, in the
rule ∀i, j, p : F(i, Obama) ∧ F(j,WhiteHouse) ∧
P(p, i) ∧ P(p, j) ⇒ Z(p, r)1, G consists of all the
rules where the free variables i, j and p are instanti-
ated. At grounding time, we parse the corpus search-
ing for the tuples that satisfy the logic rules and store
the indices of the tuples that ground the rule. The
stored indices are used to set ψl to a specific value.
For the (Obama, White House) example above, G
consists of F propositional rules for each observed
feature, where i ∈ [1 . . . F ]. For each grounding
(g ∈ G(ψl)) we define an indicator function:

1g(z,p,d,o) =


1, if g is true under

z and p,d,o
0, otherwise

(3)

where z are relation assignments to tuples, p is the
set of features in tuples, d are documents, and o
the side information encoded in FOL. Contrary to
Andrzejewski et al. (2011), we need to ground the
rules while taking into account if the feature speci-
fied in the rule is expressed by any tuple or the spe-
cific given tuple, since we are assigning relations to
tuples, and not directly to words.

Next, we define a Markov Random Field (MRF)
which combines relational LDA with the FOL
knowledge base. The MRF is defined over latent
relation tuple assignments z, relation feature multi-
nomials φ, and relation document multinomials θ
(the feature set, document, and external informa-
tion o are observed). Under this model the con-
ditional probability P (z, φ, θ|α, β,p,d,o,KB) is
proportional to:

exp

 L∑
l

∑
g∈G(ψl)

λl1g(z,p,d,o)

×
R∏
r

p(φr|β)
D∏
j

p(θj |α)
N∏
i

θdi(zi)
∏
k∈pi

φzi(fk)

(4)

The first term in Equation (4) corresponds to the
logic factor in Figure 1 that groups variables d, z,

1This rule translates as “every tuple containing Obama and
White House as features should be in relation cluster r”.

f1, f2, . . . fk and o. The remaining terms in Equa-
tion (4) refer to relational LDA. The goal of the
model is to estimate the most likely θ and φ for the
given observed state. As z can not be marginalized
out, we proceed with MAP estimation of (z, φ, θ),
maximizing the log of the probability as in Andrze-
jewski et al. (2011):

arg max
z,φ,θ

L∑
l

∑
g∈G(ψl)

λl1g(z,p,d,o)+

R∑
r

log p(φr|β)+

N∑
i

log θdi(zi)
∏
k∈pi

φzi(fk)

(5)

Once the parameters of the model are estimated
(see Section 4.3 for details), we use the φ proba-
bility distribution to assign a relation to a new test
tuple. We select the relation that maximizes the
probability arg maxr

∏k
i P (fi|φr) where f1 . . . fk

are features representing the tuple and r the relation
index.

4.3 Inference
Exact inference is intractable for both relational
LDA and MLN models. In order to infer the most
likely multinomial parameters φ and θ, we applied
the Alternating Optimization with Mirror Descent
algorithm introduced in Andrzejewski et al. (2011).
The algorithm alternates between optimizing the
multinomial parameters (φ, θ), whilst holding the re-
lation assignments (z) fixed, and vice-versa. At each
iteration, the algorithm first finds the optimal (φ, θ)
for a fixed z as the MAP estimate of the Dirichlet
posterior:

φr(f) ∝ nrf + β − 1 (6)

θj(r) ∝ njr + α− 1 (7)

where nrf is the number of times feature f is
assigned to relation r in relation assignments z,
and njr is the number of times relation r is assigned
to document j. Next, z is optimized while keeping φ
and θ fixed. This step is divided into two parts. The
algorithm first deals with all zi which appear only in
trivial groundings, i.e., groundings whose indicator
functions 1g are not affected by the latent relation
assignment z. As zi only appears in the last term of

419



Equation (5), the algorithm needs only optimize the
following term:

zi = arg max
r=1...R

θdi(r)
∏
k∈pi

φzi(fk) (8)

The second part deals with the remaining zi that ap-
pear in non-trivial groundings in the first term of
Equation (5). We follow Andrzejewski et al. (2011)
in relaxing (5) into a continuous optimization prob-
lem and refer the reader to their paper for a more
in depth treatment. Suffice it to say that once the
binary variables zir ∈ {0, 1} are relaxed to contin-
uous values zir ∈ [0, 1], it is possible to introduce
the relational LDA term in the equation and com-
pute the gradient using the Entropic Mirror Descent
Algorithm (Beck and Teboulle, 2003):

arg max
z∈[0,1]|KB|

L∑
l

∑
g∈G(ψl)

λl1g(z)+∑
i,r

zir log θdi(r)
∏
k∈pi

φzi(fk)

s.t zir ≥ 0 ,
∑
i,r

zir = 1

(9)

In every iteration the approximation algorithm
randomly samples a term from the objective func-
tion (Equation (9)). The sampled term can be
a particular ground rule g or the relational LDA
term (

∑
r zir log θdi(r)

∏
k∈pi φzi(fk)) for some

uniformly sampled index i. The sampling of the
terms is weighted according to the rule weight (λl)
and the grounded value (G(ψl)) in the case of logic
rules, and the size of corpus in tuples (|zKB|) for re-
lational LDA. Once we choose term f and take the
gradient, we can apply the Entropic Mirror Descent
update:

zir ←
zir exp(ηOzirf)∑
r′ zir′ exp(ηOzir′f)

(10)

Finally, zi is recovered by rounding to arg maxr zir.
The main advantage of this approach is that it re-
quires only a means to sample groundings g for each
ruleψl, and can avoid fully grounding the FOL rules.

4.4 Logic Rules
Our model assigns relations to tuples rather than top-
ics to words. Since our tuples are described in terms

of features our logic rules must reflect this too. For
our experiments we defined two very general types
of rules described below.

Must-link Tuple The motivation behind this rule
is that tuples which share features probably express
the same underlying relation. The rule must spec-
ify which feature has to be shared for the tuples
to be clustered together. For example, the rule be-
low states that tuples containing the dependency
path PATH:→appos→president→prep→of→pobj→
should go in the same cluster:

∀i, j, k : F(i, PATH:is the president of ) ∧ P(j, fi)
∧P(k, fi)⇒ ¬Z(j, t) ∨ Z(k, r)

Cannot-link Tuple We also define rules prohibit-
ing tuples to be clustered together because they do
not share any features. For example, tuples with
ORG-LOC entities, probably express a Location re-
lation and should not be clustered together with
PER-PER tuples, which in all likelihood express a
different relationship (e.g., Family). The rule below
expresses this constraint:

∀i, j, k, l : F(i, NEPAIR:PER-PER)
∧F(j, NEPAIR:ORG-LOC)

∧P(k, fi) ∧ P(l, fj)⇒ ¬Z(k, r) ∨ ¬Z(l, r)

The specification of the first order logic rules is
an integral part of the model. The rules express
knowledge about the task at hand, the domain in-
volved, and the way the relation extraction problem
is modeled (i.e., tuples expressed as features). So
far, we have abstractly formulated the rules without
explaining how they are specifically instantiated in
our model. We could write them down by hand after
inspecting some data or through consultation with a
domain expert. Instead, we obtain logic rules au-
tomatically from a corpus following the procedure
described in Section 5.

5 Experimental Setup

Data We trained our model on the New York
Times (years 2000–2007) corpus created by Yao et
al. (2011). The corpus contains approximately 2M
entity tuples. The latter were extracted from
428K documents. After post-processing (tokeniza-
tion, sentence-splitting, and part-of-speech tagging),

420



Must-link Tuple
F(i, NEPAIR:PER-PER, TRIGGER:wife) ∧ P(j, fi) ∧ P(k, fi)⇒ ¬Z(j, t) ∨ Z(k, r)
F(i, NEPAIR:PER-LOC, TRIGGER:die) ∧ P(j, fi) ∧ P(k, fi)⇒ ¬Z(j, t) ∨ Z(k, r)
F(i, PATH:←nsubj←die→prep→in→pobj→) ∧ P(j, fi) ∧ P(k, fi)⇒ ¬Z(j, t) ∨ Z(k, r)
F(i, SOURCE:Kobe, DEST:Lakers) ∧ P(j, fi) ∧ P(k, fi)⇒ ¬Z(j, t) ∨ Z(k, r)

Cannot-link Tuple
F(i, NEPAIR:ORG-LOC) ∧ F(j, NEPAIR:PER-PER) ∧ P(k, fi) ∧ P(l, fj)⇒ ¬Z(k, r) ∨ ¬Z(l, r)
F(i, NEPAIR:LOC-LOC) ∧ F(j, TRIGGER:president) ∧ P(k, fi) ∧ P(l, fj)⇒ ¬Z(k, r) ∨ ¬Z(l, r)
F(i, NEPAIR:PER-LOC) ∧ F(j, TRIGER:member) ∧ P(k, fi) ∧ P(l, fj)⇒ ¬Z(k, r) ∨ ¬Z(l, r)
F(i, NEPAIR:PER-PER) ∧ F(j, TRIGER:sell) ∧ P(k, fi) ∧ P(l, fj)⇒ ¬Z(k, r) ∨ ¬Z(l, r)

Table 2: Examples of automatically extracted Must-link and Cannot-link tuple rules.

named entities were automatically recognized and
labeled with PER, ORG, LOC, and MISC (Finkel
et al., 2005). Dependency paths for each pair of
named entity mentions were extracted from the out-
put of the MaltParser (Nivre et al., 2004). In our
experiments, we discarded tuples with paths longer
than 10 edges (Lin and Pantel, 2001). We evalu-
ated our model on the test partition of the ACE 2007
(English) RDC dataset which is labeled with gold
standard entity mentions and their relations. There
are six general relation types and 18 subtypes. We
used 25% of the ACE training partition as a devel-
opment set for parameter tuning.

Logic Rule Extraction We automatically ex-
tracted logic rules from the New York Times
(NYT) corpus as follows. The intuition behind
Must-link rules is that tuples with common features
should cluster together. Although we do not know
which features would yield the best rules, we
naively assume that good features are frequently
co-occurring features. Using the log-likelihood
ratio (Dunning, 1993), we first discarded low
confidence feature co-occurrences (p < 0.05). Two
features co-occur if they are both found within
the same sentence. We then sorted the remaining
co-occurrences by their frequency and retained the
N -best ones. We only considered unigram and
bigram features since higher-order ones tend to
be sparse. An example of a bigram feature would
be (PATH:←nsubj←grow→prep→in→pobj→,
DEST:Chicago).

The main intuition behind Cannot-link rules is
that tuples without any common features should
not cluster together. So, if two features never

co-occur, they probably express different relations.
For every unigram and bigram feature in the re-
spective N -best list, we find the features it does
not co-occur with in the NYT corpus. For ex-
ample, NEPAIR:PER–LOC does not co-occur with
DEST:Yankees and the bigram DEST:United Na-
tions, NEPAIR:PER–ORG does not co-occur with
SOURCE:Mr. Bush, NEPAIR:PER–LOC. Cannot-
link rules are then based on such non-co-occurring
feature pairs.

We optimized N empirically on the development
set. We experimented with values ranging from 20
to 500. We obtained 20 Must-link rules for coarse-
grained relations and 400 rules for their subtypes.
We extracted 1,814 Cannot-link rules for general re-
lations (N = 50) and 34,522 rules for subtypes
(N = 400). The number of features involved in the
Must-link rules was 25 for coarse-grained relations
and 422 for fine-grained relations. For Cannot-link
rules, 62 features were involved in coarse-grained
relations and 422 in fine-grained relations.

Examples of the rules we extracted are shown in
Table 2. The first rule in the upper half of the ta-
ble states that tuples must cluster together if their
source and target entities are PER and contain the
trigger word wife in their dependency path. The sec-
ond rule is similar, the source entity here is PER,
the target LOC and the trigger word is die. Ac-
cording to the third rule, tuples featuring the path
PATH:←nsubj←die→prep→in→pobj→ should be
in the same cluster. The fourth rule forces tuples
whose source entity is Kobe and target entity is Lak-
ers to cluster together. The second half of the table
illustrates Cannot-link tuple rules. The first rule pre-
vents tuples with ORG-LOC entities to cluster to-

421



gether with PER-PER tuples. The second rule states
that we cannot link LOC-LOC tuples with those
whose trigger word is president, and so on.

Parameter Tuning Our framework has several
parameters that must be adjusted for an optimal clus-
tering solution. These include the hyperparame-
ters α and β as well as the number of clusters. In
addition, we have to assign a weight to each FOL
rule grounding. An exhaustive search on the hy-
perparameters and rule weights is not possible. We
therefore followed a step-wise approximation proce-
dure. First, we find the best α and β values, whilst
varying the number of clusters. Once we have the
best hyperparameters for each clustering, we set the
weights for the FOL rules. We varied the number
of relations from 5 to 50. We experimented with α
values in the range of [0.05 − 0.5] and β values in
the range of [0.05 − 0.5]. These values were opti-
mized separately for coarse- and fine-grained rela-
tions. Table 3 shows the optimal number of clusters
for different model variants and relation types.

The FOL weights can also make a difference in
the final output; the bigger the weight the more
times the rule will be sampled in the Mirror Descent
algorithm. We experimented with two weighting
schemes: (a) we gave a weight of 1 or 0.5 to each
rule grounding and (b) we scaled the weights so as
to make their contribution comparable to relational
LDA. We obtained best results on the development
set with the former scheme.

Baselines We compared our FOL relational LDA
model against standard LDA (Blei et al., 2003) and
relational LDA without the FOL component. In the
case of standard LDA, we estimated topics (rela-
tions) over words, and used the context of the en-
tity mentions pairs as a bag of words feature to se-
lect the most likely cluster at test time. Parameters
for LDA and relational LDA were optimized follow-
ing the same parameter tuning procedure described
above.

We also compared our model against the unsuper-
vised method introduced in Hasegawa et al. (2004).
Their key idea is to cluster pairs of co-occurring
named entities according to the similarity of their
surrounding contexts. Following their approach, we
measured context similarity using the vector space
model and the cosine metric and grouped NE pairs
into clusters using a complete linkage hierarchical

clustering algorithm. We adopted the same parame-
ter values as detailed in their paper (e.g., cosine sim-
ilarity threshold, length of context vectors). At test
time, instances were assigned to the relation cluster
most similar to them (according to the cosine mea-
sure).

Evaluation We evaluated the clusters obtained by
our model and the comparison systems using the Fs-
core measure introduced in the SemEval 2007 task
(Agirre and Soroa, 2007); it is the harmonic mean
of precision and recall defined as the number of cor-
rect members of a cluster divided by the number of
items in the cluster and the number of items in the
gold-standard class, respectively.

6 Results

Our results are summarized in Table 3 which reports
Fscore for (Hasegawa et al., 2004), LDA, relational
LDA (RelLDA), and our model with the FOL com-
ponent. To assess the impact of the rules on the
clustering, we conducted several rule ablation stud-
ies. We thus present results with a model that in-
cludes both Must-link and Cannot-link tuple rules
(CLT+MLT), and models that include either Must-
link (MLT) or Cannot-link (CLT) rules but not both.
We show the performance of these models with the
entire feature set (see (ALL) in the table) and with a
subset consisting solely of NE pair related features
(see (NEPAIR) in the table). We report results against
coarse- and fine-grained relations (6 and 18 relation
types in ACE, respectively). The table shows the
optimal number of relation clusters (in parentheses)
per model and relation type.

We also wanted to examine the quality of the logic
rules. Recall that we learn these heuristically from
the NYT corpus. We thus trained an additional vari-
ant of our model with rules extracted from the ACE
training set (75%) which contains relation annota-
tions. The extraction procedure was similar to the
unsupervised case, save that the relation types were
known and thus informative features could be mined
more reliably. For Must-link rules, we extracted un-
igram and bigram feature frequencies for each re-
lation type and applied TF-IDF weighting in order
to discover the most discriminative ones. We cre-
ated logic rules for the 10 best feature combinations
in each relation type. Regarding Cannot-link rules,
we enumerated the features (unigrams and bigrams)

422



Model Subtype Type
HASEGAWA 26.1 (12) 34.7 (12)
LDA 23.4 (10) 29.0 (5)
RelLDA 30.4 (40) 38.6 (5)
U-MLT (ALL) 36.6 (10) 48.0 (5)
U-CLT (ALL) 30.5 (5) 39.3 (5)
U-CLT+MLT (ALL) 29.8 (5) 42.0 (5)
U-MLT (NEPAIR) 36.5 (10) 47.2 (5)
U-CLT (NEPAIR) 28.8 (50) 40.5 (5)
U-CLT+MLT (NEPAIR) 30.9 (10) 41.5 (5)
S-MLT (ALL) 37.0 (10) 47.0 (5)
S-CLT (ALL) 31.4 (50) 40.9 (5)
S-CLT+MLT (ALL) 32.3 (10) 42.5 (5)
S-MLT (NEPAIR) 37.0 (10) 47.6 (10)
S-CLT (NEPAIR) 31.4 (10) 40.1 (5)
S-CLT+MLT (NEPAIR) 37.1 (10) 46.0 (5)

Table 3: Model performance on the ACE 2007 test set
using Fscore. Results are shown for six main relation
types and their subtypes (18 in total). (ALL) models con-
tain rules extracted from the entire feature set. For (NE-
PAIR) models, rules were extracted from NEPAIR-related
features only. Prefix U- denotes models that use unsu-
pervised rules; prefix S- highlights models using super-
vised rules. The optimal number of relations per model
is shown in parentheses.

that did not co-occur in any relation type and applied
TF-IDF weighting. Again, we created rules for the
10 most discriminative features. We defined rules
over the entire feature set (466 Must-link and 26,074
Cannot-link rules) and a subset containing only NE
pairs. In Table 3, prefixes S- and U- indicate model
variants with supervised and unsupervised rules, re-
spectively.

Our results show that standard LDA is not suit-
able for relation extraction. The obtained clusters
are not informative enough to induce semantic re-
lations, whereas RelLDA yields substantially bet-
ter Fscores. This is not entirely surprising, given
that RelLDA is a relation extraction specific model.
Hasegawa et al.’s (2004) model lies somewhere in
the middle between LDA and RelLDA. The com-
bination of RelLDA with automatically extracted
FOL rules improves over RelLDA across the board
(see the U- models in Table 3). MLT rules deliver
the largest improvement for both coarse and fine-
grained relation types. In general, CLT models per-
form worse as well as models using both types of
rules (MLT+CLT). The inferior performance of the

rule combination may be due to the fact that MLT
and CLT rules contain conflicting information and
to a certain extent cancel each other out. The use
of many rules might also negatively impact infer-
ence, i.e., discriminative rules are sampled less and
cannot influence the model towards a better solu-
tion. Restricting the number of features and rules
to named entity pairs only incurs a negligible drop
in performance. This is good news for scaling pur-
poses, since a small number of rules can greatly
speed-up inference. Interestingly, model variants
which use supervised FOL rules (see the prefix S-
in Table 3) perform on par with unsupervised mod-
els. Again, MLT rules perform best in the super-
vised case, whereas CLT rules marginally improve
over RelLDA.

We assessed whether differences in performance
are statistically significant (p < 0.05) using boot-
strap resampling (Noreen, 1989). All models across
all relation types are significantly better than LDA
and Hasegawa et al. (2004). FOL-based models per-
form significantly better than RelLDA, with the ex-
ception of all CLT models and U-CLT+MLT (ALL).
MLT models are significantly better than any other
rule-based model, except those that only use NE-
PAIR features. We also measured whether differ-
ent models agree on their topic assignments using
Cohen’s Kappa.2 RelLDA agrees least with MLT
models and most with CLT models (i.e., κ = 0.50
for U-MLT (ALL) and κ = 0.65 for U-CLT (ALL)).
This suggests that the CLT rules do not affect the
output of RelLDA as much as MLT ones. Examples
of relation clusters discovered by the U-MLT (ALL)
model are shown in Table 4.

A last note on parameter selection. Our experi-
ments explored the parameter space extensively in
order to examine any interactions between the in-
duced relations and the logic rules. For most model
variants inferring subtype relations, the preferred
number of clusters is 10. For coarse-grained rela-
tions, the optimal number of clusters is five. Over-
all, we found that the quality of the output is highly
correlated with the quality of the logic rules and that
a few good rules are more important than the opti-
mal number of clusters. We consider these findings
robust enough to apply across domains and datasets.

2For all comparison models the number of relation clusters
was set to 10.

423



SOURCE PATH DEST

Republican president of Senate
Senate director of Yankees
House professor at Republican
Bush chairman of Congress
Democrat spokesman for House
Mr. Bush executive of Mets
Democrats director at U. of California
Republican analyst at United Nations

E
m

pl
oy

m
en

t

SOURCE PATH DEST

Yankees defeat World Series
Mets win Olympic
United States beat World Cup
Giants play Yankees
Jets win Super Bowl
Nets lose Olympics
Knicks sign Mets
Rangers victory over Giants

Sp
or

ts

Table 4: Clusters discovered by the U-MLT (ALL) model
indicating employment- and sports-type relations. For the
sake of readability, we do not display the syntactic depen-
dencies between words in a path.

7 Conclusions

In this paper we presented a new model for unsu-
pervised relation extraction which operates over tu-
ples representing a syntactic relationship between
two named entities. Our model clusters such tuples
into underlying semantic relations (e.g., Located,
Family) by incorporating general domain knowledge
which we encode as First Order Logic rules. Specif-
ically, we combine a topic model developed for the
relation extraction task with domain relevant rules,
and present an algorithm for estimating the param-
eters of this model. Evaluation results on the ACE
2007 (English) RDC task show that our model out-
performs competitive unsupervised approaches by a
wide margin and is able to produce clusters shaped
by both the data and the rules.

In the future, we would like to explore additional
types of rules such as seed rules, which would as-
sign tuples complying with the “seed” information
to distinct relations. Aside from devising new rule
types, an obvious next step would be to explore dif-
ferent ways of extracting the rule set based on differ-
ent criteria (e.g., the most general versus most spe-
cific rules). Also note that in the current framework
rule weights are set manually by the domain expert.

An appealing direction would be to learn these auto-
matically e.g., via a procedure that optimizes some
clustering objective. Finally, it should be interesting
to use some form of distant supervision (Mintz et al.,
2009) either as a means of obtaining useful rules or
to discard potentially noisy or uninformative rules.

Acknowledgments

We gratefully acknowledge financial support from
the Department of Education, Universities and Re-
search of the Basque Government (BFI-2011-442).
We also thank Limin Yao and Sebastian Riedel for
sharing their corpus with us and the members of the
Probabilistic Models reading group at the University
of Edinburgh for helpful feedback.

References
Eugene Agichtein and Luis Gravano. 2000. Snowball:

Extracting relations from large plain-text collections.
In Proceedings of the 5th ACM International Confer-
ence on Digital Libraries, pages 85–94, San Antonio,
Texas.

Eneko Agirre and Aitor Soroa. 2007. Semeval-2007
task 02: Evaluating word sense induction and discrim-
ination systems. In Proceedings of the 4th Interna-
tional Workshop on Semantic Evaluations, pages 7–12,
Prague, Czech Republic.

David Andrzejewski, Xiaojin Zhu, Mark Craven, and Ben
Recht. 2011. A framework for incorporating general
domain knowledge into latent Dirichlet allocation us-
ing first-order logic. In Proceedings of the 22nd In-
ternational Joint Conference on Artificial Intelligence,
pages 1171–1177, Barcelona, Spain.

Michele Banko, Michael J. Cafarella, Stephen Soderland,
Matthew Broadhead, and Oren Etzioni. 2007. Open
information extraction from the web. In Proceedings
of the 20th International Joint Conference on Artificial
Intelligence, pages 2670–2676, Hyderabad, India.

Amir Beck and Marc Teboulle. 2003. Mirror de-
scent and nonlinear projected subgradient methods for
convex optimization. Operations Research Letters,
31(3):167–175.

Christopher M. Bishop. 2006. Pattern Recognition and
Machine Learning. Springer.

David M. Blei, Andrew Y. Ng, and Michael I. Jordan.
2003. Latent Dirichlet allocation. Journal of Machine
Learning Research, 3:993–1022.

Razvan Bunescu and Raymond Mooney. 2007. Learning
to extract relations from the web using minimal su-
pervision. In Proceedings of the 45th Annual Meeting

424



of the Association of Computational Linguistics, pages
576–583, Prague, Czech Republic.

Aron Culotta and Jeffrey Sorensen. 2004. Dependency
tree kernels for relation extraction. In Proceedings of
the 42nd Meeting of the Association for Computational
Linguistics, Main Volume, pages 423–429, Barcelona,
Spain.

Ted Dunning. 1993. Accurate methods for the statistics
of surprise and coincidence. Computational Linguis-
tics, 19(1):61–74.

Jenny Rose Finkel, Trond Grenager, and Christopher
Manning. 2005. Incorporating non-local informa-
tion into information extraction systems by Gibbs sam-
pling. In Proceedings of the 43rd Annual Meeting of
the Association for Computational Linguistics, pages
363–370, Ann Arbor, Michigan.

David Gondek and Thomas Hofmann. 2004. Non-
redundant data clustering. In IEEE International Con-
ference on Data Mining, pages 75–82. IEEE Computer
Society.

Thomas L. Griffiths and Mark Steyvers. 2004. Finding
scientific topics. PNAS, 101(1):5228–5235.

Takaaki Hasegawa, Satoshi Sekine, and Ralph Grishman.
2004. Discovering relations among named entities
from large corpora. In Proceedings of the 42nd Annual
Meeting of the Association for Computational Linguis-
tics, pages 415–422, Barcelona, Spain.

D. Koller and N. Friedman. 2009. Probabilistic Graphi-
cal Models: Principles and Techniques. MIT Press.

Dekang Lin and Patrick Pantel. 2001. DIRT – discovery
of inference rules from text. In Proceedings of the 7th
ACM SIGKDD International Conference on Knowl-
edge Discovery and Data Mining, pages 323–328, San
Francisco, California.

Mike Mintz, Steven Bills, Rion Snow, and Daniel Juraf-
sky. 2009. Distant supervision for relation extraction
without labeled data. In Proceedings of the Joint Con-
ference of the 47th Annual Meeting of the ACL and
the 4th International Joint Conference on Natural Lan-
guage Processing of the AFNLP, pages 1003–1011,
Suntec, Singapore.

Joakim Nivre, Johan Hall, and Jens Nilsson. 2004.
Memory-based dependency parsing. In Proceedings
of the 8th Conference on Computational Natural Lan-
guage Learning, pages 49–56, Boston, Massachusetts.

Eric W. Noreen. 1989. Computer-intensive Methods for
Testing Hypotheses: An Introduction. John Wiley and
Sons Inc.

Patrick Pantel and Marco Pennacchiotti. 2006. Espresso:
Leveraging generic patterns for automatically harvest-
ing semantic relations. In Proceedings of the 21st In-
ternational Conference on Computational Linguistics

and 44th Annual Meeting of the Association for Com-
putational Linguistics, pages 113–120, Sydney, Aus-
tralia.

Hoifung Poon and Pedro Domingos. 2009. Unsuper-
vised semantic parsing. In Proceedings of the 2009
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 1–10, Suntec, Singapore.

Matthew Richardson and Pedro Domingos. 2006.
Markov logic networks. Machine Learning,
62(1–2):107–136.

Ellen Riloff and Rosie Jones. 1999. Learning dictionar-
ies for information extraction. In Proceedings of the
16th International Joint Conference on Artificial Intel-
ligence, pages 474–479, Stockholm, Sweden.

Stefan Schoenmackers, Jesse Davis, Oren Etzioni, and
Daniel Weld. 2010. Learning first-order Horn clauses
from web text. In Proceedings of the 2010 Conference
on Empirical Methods in Natural Language Process-
ing, pages 1088–1098, Cambridge, MA, October. As-
sociation for Computational Linguistics.

Yusuke Shinyama and Satoshi Sekine. 2006. Preemptive
information extraction using unrestricted relation dis-
covery. In Proceedings of the Human Language Tech-
nology Conference of the NAACL, Main Conference,
pages 304–311, New York City, USA.

Mihai Surdeanu and Massimiliano Ciaramita. 2007. Ro-
bust information extration with perceptrons. In Pro-
ceedings of the NIST 2007 Automatic Content Extrac-
tion Workshop.

Kiri Wagstaff, Claire Cardie, C Rogers, and S Schrödl.
2001. Constrained k-means clustering with back-
ground knowledge. In International Conference on
Machine Learning, pages 577–584. Morgan Kauf-
mann.

Limin Yao, Aria Haghighi, Sebastian Riedel, and Andrew
McCallum. 2011. Structured relation discovery using
generative models. In Proceedings of the 2011 Confer-
ence on Empirical Methods in Natural Language Pro-
cessing, pages 1456–1466, Edinburgh, Scotland, UK.

GuoDong Zhou, Min Zhang, DongHong Ji, and QiaoM-
ing Zhu. 2007. Tree kernel-based relation extraction
with context-sensitive structured parse tree informa-
tion. In Proceedings of the 2007 Joint Conference
on Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learning,
pages 728–736, Prague, Czech Republic.

425


