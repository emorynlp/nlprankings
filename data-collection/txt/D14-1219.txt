



















































Discriminative Reranking of Discourse Parses Using Tree Kernels


Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 2049–2060,
October 25-29, 2014, Doha, Qatar. c©2014 Association for Computational Linguistics

Discriminative Reranking of Discourse Parses Using Tree Kernels

Shafiq Joty and Alessandro Moschitti
ALT Research Group

Qatar Computing Research Institute
{sjoty,amoschitti}@qf.org.qa

Abstract

In this paper, we present a discrimina-
tive approach for reranking discourse trees
generated by an existing probabilistic dis-
course parser. The reranker relies on tree
kernels (TKs) to capture the global depen-
dencies between discourse units in a tree.
In particular, we design new computa-
tional structures of discourse trees, which
combined with standard TKs, originate
novel discourse TKs. The empirical evalu-
ation shows that our reranker can improve
the state-of-the-art sentence-level parsing
accuracy from 79.77% to 82.15%, a rel-
ative error reduction of 11.8%, which in
turn pushes the state-of-the-art document-
level accuracy from 55.8% to 57.3%.

1 Introduction

Clauses and sentences in a well-written text are
interrelated and exhibit a coherence structure.
Rhetorical Structure Theory (RST) (Mann and
Thompson, 1988) represents the coherence struc-
ture of a text by a labeled tree, called discourse
tree (DT) as shown in Figure 1. The leaves cor-
respond to contiguous clause-like units called ele-
mentary discourse units (EDUs). Adjacent EDUs
and larger discourse units are hierarchically con-
nected by coherence relations (e.g., ELABORA-
TION, CAUSE). Discourse units connected by a re-
lation are further distinguished depending on their
relative importance: nuclei are the core parts of the
relation while satellites are the supportive ones.

Conventionally, discourse analysis in RST in-
volves two subtasks: (i) discourse segmentation:
breaking the text into a sequence of EDUs, and
(ii) discourse parsing: linking the discourse units
to form a labeled tree. Despite the fact that dis-
course analysis is central to many NLP appli-
cations, the state-of-the-art document-level dis-
course parser (Joty et al., 2013) has an f -score

of only 55.83% using manual discourse segmen-
tation on the RST Discourse Treebank (RST-DT).

Although recent work has proposed rich lin-
guistic features (Feng and Hirst, 2012) and pow-
erful parsing models (Joty et al., 2012), discourse
parsing remains a hard task, partly because these
approaches do not consider global features and
long range structural dependencies between DT
constituents. For example, consider the human-
annotated DT (Figure 1a) and the DT generated by
the discourse parser of Joty et al. (2013) (Figure
1b) for the same text. The parser makes a mistake
in finding the right structure: it considers only e3
as the text to be attributed to e2, where all the text
spans from e3 to e6 (linked by CAUSE and ELAB-
ORATION) compose the statement to be attributed.
Such errors occur because existing systems do not
encode long range dependencies between DT con-
stituents such as those between e3 and e4−6.

Reranking models can make the global struc-
tural information available to the system as fol-
lows: first, a base parser produces several DT
hypotheses; and then a classifier exploits the en-
tire information in each hypothesis, e.g., the com-
plete DT with its dependencies, for selecting the
best DT. Designing features capturing such global
properties is however not trivial as it requires the
selection of important DT fragments. This means
selecting subtree patterns from an exponential fea-
ture space. An alternative approach is to implicitly
generate the whole feature space using tree kernels
(TKs) (Collins and Duffy, 2002; Moschitti, 2006).

In this paper, we present reranking models for
discourse parsing based on Support Vector Ma-
chines (SVMs) and TKs. The latter allows us
to represent structured data using the substructure
space thus capturing structural dependencies be-
tween DT constituents, which is essential for ef-
fective discourse parsing. Specifically, we made
the following contributions. First, we extend the

2049



Topic-Comment

Attribution

Cause

Elaboration

Elaboration

e

e

e

e

e e

2

3

4

5 6

1

(a) A human-annotated discourse tree.

Background

Attribution

Cause

Elaboration

Elaboration

e

e e e

e e

2 3 4

5 6

1

(b) A discourse tree generated by Joty et al. (2013).

Figure 1: Example of human-annotated and system-generated discourse trees for the text [what’s more,]e1 [he believes]e2
[seasonal swings in the auto industry this year aren’t occurring at the same time in the past,]e3 [because of production and pric-
ing differences]e4 [that are curbing the accuracy of seasonal adjustments]e5] [built into the employment data.]e6 Horizontal
lines indicate text segments; satellites are connected to their nuclei by curved arrows.

existing discourse parser1 (Joty et al., 2013) to
produce a list of k most probable parses for each
input text, with associated probabilities that define
the initial ranking.

Second, we define a set of discourse tree ker-
nels (DISCTK) based on the functional composi-
tion of standard TKs with structures representing
the properties of DTs. DISCTK can be used for
any classification task involving discourse trees.

Third, we use DISCTK to define kernels for
reranking and use them in SVMs. Our rerankers
can exploit the complete DT structure using TKs.
They can ascertain if portions of a DT are compat-
ible, incompatible or simply not likely to coexist,
since each substructure is an exploitable feature.
In other words, problematic DTs are expected to
be ranked lower by our reranker.

Finally, we investigate the potential of our ap-
proach by computing the oracle f -scores for both
document- and sentence-level discourse parsing.
However, as demonstrated later in Section 6, for
document-level parsing, the top k parses often
miss the best parse. For example, the oracle f -
scores for 5- and 20-best document-level parsing
are only 56.91% and 57.65%, respectively. Thus
the scope of improvement for the reranker is rather
narrow at the document level. On the other hand,
the oracle f -score for 5-best sentence-level dis-
course parsing is 88.09%, where the base parser
(i.e., 1-best) has an oracle f -score of 79.77%.
Therefore, in this paper we address the following
two questions: (i) how far can a reranker improve
the parsing accuracy at the sentence level? and
(ii) how far can this improvement, if at all, push
the (combined) document-level parsing accuracy?

To this end, our comparative experiments on

1Available from http://alt.qcri.org/tools/

RST-DT show that the sentence-level reranker can
improve the f -score of the state-of-the-art from
79.77% to 82.15%, corresponding to a relative
error reduction of 11.8%, which in turn pushes
the state-of-the-art document-level f -score from
55.8% to 57.3%, an error reduction of 3.4%.

In the rest of the paper, after introducing the TK
technology in Section 2, we illustrate our novel
structures, and how they lead to the design of
novel DISCTKs in Section 3. We present the k-
best discourse parser in Section 4. In Section 5, we
describe our reranking approach using DISCTKs.
We report our experiments in Section 6. We briefly
overview the related work in Section 7, and finally,
we summarize our contributions in Section 8.

2 Kernels for Structural Representation

Tree kernels (Collins and Duffy, 2002; Shawe-
Taylor and Cristianini, 2004; Moschitti, 2006) are
a viable alternative for representing arbitrary sub-
tree structures in learning algorithms. Their ba-
sic idea is that kernel-based learning algorithms,
e.g., SVMs or perceptron, only need the scalar
product between the feature vectors representing
the data instances to learn and classify; and kernel
functions compute such scalar products in an effi-
cient way. In the following subsections, we briefly
describe the kernel machines and three types of
tree kernels (TKs), which efficiently compute the
scalar product in the subtree space, where the vec-
tor components are all possible substructures of
the corresponding trees.

2.1 Kernel Machines

Kernel Machines (Cortes and Vapnik, 1995), e.g.,
SVMs, perform binary classification by learning
a hyperplane H(~x) = ~w · ~x + b = 0, where

2050



Chapter 2. Background 15

a

b

c e

g )
a

b

c e

g

b

c e

g c e

Figure 2.4: A tree (left) and all of its proper subtrees (right).

a

b

c e

g )
a

b

c e

g

a

b g

c e

g

b

c e

Figure 2.5: A tree (left) and all of its subset trees (right).

Proper Subtree A proper subtree ti comprises node vi along with all of its de-

scendants (see figure 2.4 for an example of a tree along with all its proper subtrees).

Subset Tree A subset tree is a subtree for which the following constraint is sat-

isfied: either all of the children of a node belong to the subset tree or none of them.

The reason for adding such a constraint can be understood by considering the fact

that subset trees were defined for measuring the similarity of parse trees in natural

language applications. In that context a node along with all of its children represent

a grammar production. Figure 2.5 gives an example of a tree along with some of its

subset trees.

Figure 2: A tree with its STK subtrees; STKb also includes
leaves as features.

~x ∈ Rn is the feature vector representation of an
object o ∈ O to be classified and ~w ∈ Rn and
b ∈ R are parameters learned from the training
data. One can train such machines in the dual
space by rewriting the model parameter ~w as a lin-
ear combination of training examples, i.e., ~w =∑

i=1..l yiαi~xi, where yi is equal to 1 for positive
examples and −1 for negative examples, αi ∈ R+
and ~xi∀i ∈ {1, .., l} are the training instances.
Then, we can use the data object oi ∈ O directly
in the hyperplane equation considering their map-
ping function φ : O → Rn, as follows: H(o) =∑

i=1..l yiαi~xi ·~x+b =
∑

i=1..l yiαiφ(oi) ·φ(o)+
b =

∑
i=1..l yiαiK(oi, o) + b, where the product

K(oi, o) = 〈φ(oi) · φ(o)〉 is the kernel function
(e.g., TK) associated with the mapping φ.

2.2 Tree Kernels

Convolution TKs compute the number of com-
mon tree fragments between two trees T1 and T2
without explicitly considering the whole fragment
space. A TK function over T1 and T2 is defined as:
TK(T1, T2) =

∑
n1∈NT1

∑
n2∈NT2 ∆(n1, n2),

where NT1 and NT2 are the sets of the nodes of
T1 and T2, respectively, and ∆(n1, n2) is equal
to the number of common fragments rooted in
the n1 and n2 nodes.2 The computation of ∆
function depends on the shape of fragments,
conversely, a different ∆ determines the richness
of the kernel space and thus different tree kernels.
In the following, we briefly describe two existing
and well-known tree kernels. Please see several
tutorials on kernels (Moschitti, 2013; Moschitti,
2012; Moschitti, 2010) for more details.3

Syntactic Tree Kernels (STK) produce fragments
such that each of their nodes includes all or none
of its children. Figure 2 shows a tree T and its
three fragments (do not consider the single nodes)
in the STK space on the left and right of the ar-

2To get a similarity score between 0 and 1, it is
common to apply a normalization in the kernel space,
i.e. TK(T1,T2)√

TK(T1,T1)×TK(T2,T2)
.

3Tutorials notes available at http://disi.unitn.
it/moschitti/

14 Chapter 2. Background

a

b

c e

g

2 3

31

Figure 2.2: A positional Tree. The number over an arc represents the position of

the node with respect to its parent.

a

b

c e

g )
a

b

c e

g

a

b g

c e

g a

gb

c e

a

b

c e

a

b

e

Figure 2.3: A tree (left) and some of its subtrees (right).

node. The maximum out-degree of a tree is the highest index of all the nodes of the

tree. The out-degree of a node for an ordered tree corresponds to the number of its

children. The depth of a node vi with respect to one of its ascendants vj is defined

as the number of nodes comprising the path from vj to vi. When not specified, the

node with respect to the depth is computed, is the root.

A tree can be decomposed in many types of substructures.

Subtree A subtree t is a subset of nodes in the tree T , with corresponding edges,

which forms a tree. A subtree rooted at node vi will be indicated with ti, while a

subtree rooted at a generic node v will be indicated by t(v). When t is used in a

context where a node is expected, t refers to the root node of the subtree t. The

set of subtrees of a tree will be indicated by NT . When clear from the context NT

may refer to specific type of subtrees. Figure 2.3 gives an example of a tree together

with its subtrees. Various types of subtrees can be defined for a tree T .

Figure 3: A tree with its PTK fragments.

row, respectively. STK(T ,T ) counts the number
of common fragments, which in this case is the
number of subtrees of T , i.e., three. In the figure,
we also show three single nodes, c, e, and g, i.e.,
the leaves of T , which are computed by a vari-
ant of the kernel, that we call STKb. The com-
putational complexity of STK is O(|NT1 ||NT2 |),
but the average running time tends to be linear
(i.e. O(|NT1 | + |NT2 |)) for syntactic trees (Mos-
chitti, 2006).

Partial Tree Kernel (PTK) generates a richer set
of tree fragments. Given a target tree T , PTK
can generate any subset of connected nodes of T ,
whose edges are in T . For example, Figure 3
shows a tree with its nine fragments including all
single nodes (i.e., the leaves of T ). PTK is more
general than STK as its fragments can include any
subsequence of children of a target node. The time
complexity of PTK is O(pρ2|NT1 ||NT2 |), where
p is the largest subsequence of children that one
wants to consider and ρ is the maximal out-degree
observed in the two trees. However, the average
running time again tends to be linear for syntactic
trees (Moschitti, 2006).

3 Discourse Tree Kernels (DISCTK)

Engineering features that can capture the depen-
dencies between DT constituents is a difficult task.
In principle, any dependency between words, rela-
tions and structures (see Figure 1) can be an im-
portant feature for discourse parsing. This may
lead to an exponential number of features, which
makes the feature engineering process very hard.

The standard TKs described in the previous sec-
tion serve as a viable option to get useful sub-
tree features automatically. However, the defini-
tion of the input to a TK, i.e., the tree represent-
ing a training instance, is extremely important as
it implicitly affects the subtree space generated by
the TK, where the target learning task is carried
out. This can be shown as follows. Let φM ()
be a mapping from linguistic objects oi, e.g., a
discourse parse, to a meaningful tree Ti, and let
φTK() be a mapping into a tree kernel space us-

2051



(a) JRN

(b) SRN

Figure 4: DISCTK trees: (a) Joint Relation-Nucleus (JRN), and (b) Split Relation Nucleus (SRN).

ing one of the TKs described in Section 2.2, i.e.,
TK(T1, T2) = φTK(T1) · φTK(T2). If we apply
TK to the objects oi transformed by φM (), we
obtain TK(φM (o1), φM (o2)) = φTK(φM (o1)) ·
φTK(φM (o2))=

(
φTK◦φM

)
(o1)·

(
φTK◦φM

)
(o2)

= DiscTK(o1, o2), which is a new kernel4 in-
duced by the mapping φDiscTK =

(
φTK ◦ φM

)
.

We define two different mappings φM to trans-
form the discourse parses generated by the base
parser into two different tree structures: (i) the
Joint Relation-Nucleus tree (JRN), and (ii) the
Split Relation Nucleus tree (SRN).

3.1 Joint Relation-Nucleus Tree (JRN)

As shown in Figure 4a, JRN is a direct mapping
of the parser output, where the nuclearity statuses
(i.e., satellite or nucleus) of the connecting nodes
are attached to the relation labels.5 For example,
the root BACKGROUNDSatellite−Nucleus in Figure
4a denotes a Background relation between a satel-
lite discourse unit on the left and a nucleus unit on
the right. Text spans (i.e., EDUs) are represented
as sequences of Part-of-Speech (POS) tags con-
nected to the associated words, and are grouped
under dummy SPAN nodes. We experiment with
two lexical variations of the trees: (i) All includes
all the words in the EDU, and (ii) Bigram includes
only the first and last two words in the EDU.

When JRN is used with the STK kernel, an ex-
ponential number of fragments are generated. For
example, the upper row of Figure 5 shows two

4People interested in algorithms may like it more design-
ing a complex algorithm to compute

(
φTK ◦φM

)
. However,

the design of φM is conceptually equivalent and more effec-
tive from an engineering viewpoint.

5This is a common standard followed by the parsers.

smallest (atomic) fragments and one subtree com-
posed of two atomic fragments. Note that much
larger structures encoding long range dependen-
cies are also part of the feature space. These frag-
ments can reveal if the discourse units are orga-
nized in a compatible way, and help the reranker
to detect the kind of errors shown earlier in Fig-
ure 1b. However, one problem with JRN repre-
sentation is that since the relation nodes are com-
posed of three different labels, the generated sub-
trees tend to be sparse. In the following, we de-
scribe SRN that attempts to solve this issue.

3.2 Split Relation Nucleus Tree (SRN)
SRN is not very different from JRN as shown in
Figure 4b. The only difference is that instead of
attaching the nuclearity statuses to the relation la-
bels, in this representation we assign them to their
respective discourse units. When STK kernel is
applied to SRN it again produces an exponential
number of fragments. For example, the lower row
of Figure 5 shows two atomic fragments and one
subtree composed of two atomic fragments. Com-
paring the two examples in Figure 5, it is easy
to understand that the space of subtrees extracted
from SRN is less sparse than that of JRN.

Note that, as described in Secion 2.2, when the
PTK kernel is applied to JRN and SRN trees, it can
generate a richer feature space, e.g., features that
are paths containing relation labels (e.g., BACK-
GROUND - CAUSE - ELABORATION or ATTRIBU-
TION - CAUSE - ELABORATION).

4 Generation of k-best Discourse Parses
In this section we describe the 1-best discourse
parser of Joty et al. (2013), and how we extend

2052



Figure 5: Fragments from JRN in Figure 4a (upper row) and SRN in Figure 4b (lower row).

it to k-best discourse parsing.
Joty et al. (2013) decompose the problem of

document-level discourse parsing into two stages
as shown in Figure 6. In the first stage, the intra-
sentential discourse parser produces discourse
subtrees for the individual sentences in a docu-
ment. Then the multi-sentential parser combines
the sentence-level subtrees and produces a DT for
the document. Both parsers have the same two
components: a parsing model and a parsing al-
gorithm. The parsing model explores the search
space of possible DTs and assigns a probability to
every possible DT. Then the parsing algorithm se-
lects the most probable DT(s). While two separate
parsing models are employed for intra- and multi-
sentential parsing, the same parsing algorithm is
used in both parsing conditions. The two-stage
parsing exploits the fact that sentence boundaries
correlate very well with discourse boundaries. For
example, more than 95% of the sentences in RST-
DT have a well-formed discourse subtree in the
full document-level discourse tree.

The choice of using two separate models for
intra- and multi-sentential parsing is well justified
for the following two reasons: (i) it has been ob-
served that discourse relations have different dis-
tributions in the two parsing scenarios, and (ii) the
models could independently pick their own infor-
mative feature sets. The parsing model used for
intra-sentential parsing is a Dynamic Conditional
Random Field (DCRF) (Sutton et al., 2007) shown
in Figure 7. The observed nodes Uj at the bottom
layer represent the discourse units at a certain level
of the DT; the binary nodes Sj at the middle layer
predict whether two adjacent units Uj−1 and Uj
should be connected or not; and the multi-class
nodes Rj at the top layer predict the discourse
relation between Uj−1 and Uj . Notice that the
model represents the structure and the label of a
DT constituent jointly, and captures the sequential
dependencies between the DT constituents. Since
the chain-structured DCRF model does not scale
up to multi-sentential parsing of long documents,

Model

A lgorithm
Sentences 
segmented
into EDUs

Document-level
discourse tree

Model

A lgorithm

Multi-sentential parserIntra-sentential parser

Figure 6: The two-stage document-level discourse parser
proposed by Joty et al. (2013).

U UU U U

2

2

2

3 j t-1 t

SS S S S

R R R R R

3

3 j

j t-1

t-1 t

U
1

t

Relation 
sequence

Structure
sequence

 Unit 
sequence 
at level i 

Figure 7: The intra-sentential parsing model.

the multi-sentential parsing model is a CRF which
breaks the chain structure of the DCRF model.

The parsing models are applied recursively at
different levels of the DT in their respective pars-
ing scenarios (i.e., intra- and multi-sentential),
and the probabilities of all possible DT con-
stituents are obtained by computing the posterior
marginals over the relation-structure pairs (i.e.,
P (Rj , Sj=1|U1, · · · , Ut,Θ), where Θ are model
parameters). These probabilities are then used in
a CKY-like probabilistic parsing algorithm to find
the globally optimal DT for the given text.

Let U bx and U
e
x denote the beginning and

end EDU Ids of a discourse unit Ux, and
R[U bi , U

e
m, U

e
j ] refers to a coherence relation

R that holds between the discourse unit con-
taining EDUs U bi through U

e
m and the unit

containing EDUs U em+1 through U
e
j . Given n

discourse units, the parsing algorithm uses the
upper-triangular portion of the n×n dynamic
programming table A, where cell A[i, j] (for
i < j) stores:
A[i, j] = P (r∗[U bi , U

e
m∗ , U

e
j ]), where

(m∗, r∗) = argmax
i≤m<j ; R

P (R[U bi , U
e
m, U

e
j ])×

A[i,m]×A[m+ 1, j] (1)

2053



1 1 2
2 2

3

B

r1 r3 r2
r2 r3

r4

C

r2

r1

e1 e2

r4

e3 e4

Figure 8: The B and C dynamic programming tables (left), and the corresponding discourse tree (right).

In addition to A, which stores the probability of
the most probable constituents of a DT, the pars-
ing algorithm also simultaneously maintains two
other tables B and C for storing the best structure
(i.e., U em∗) and the relations (i.e., r

∗) of the corre-
sponding DT constituents, respectively. For exam-
ple, given 4 EDUs e1 · · · e4, the B and C tables at
the left side in Figure 8 together represent the DT
shown at the right. More specifically, to generate
the DT, we first look at the top-right entries in the
two tables, and find B[1, 4] = 2 and C[1, 4] = r2,
which specify that the two discourse units e1:2 and
e3:4 should be connected by the relation r2 (the
root in the DT). Then, we see how EDUs e1 and
e2 should be connected by looking at the entries
B[1, 2] and C[1, 2], and find B[1, 2] = 1 and
C[1, 2] = r1, which indicates that these two units
should be connected by the relation r1 (the left
pre-terminal). Finally, to see how EDUs e3 and e4
should be linked, we look at the entriesB[3, 4] and
C[3, 4], which tell us that they should be linked by
the relation r4 (the right pre-terminal).

It is straight-forward to generalize the above al-
gorithm to produce k most probable DTs. When
filling up the dynamic programming tables, rather
than storing a single best parse for each subtree,
we store and keep track of k-best candidates si-
multaneously. More specifically, each cell in the
dynamic programming tables (i.e., A, B and C)
should now contain k entries (sorted by their prob-
abilities), and for each such entry there should be a
back-pointer that keeps track of the decoding path.

The algorithm works in polynomial time. For
n discourse units and M number of relations, the
1-best parsing algorithm has a time complexity of
O(n3M) and a space complexity of O(n2), where
the k-best version has a time and space complexi-
ties ofO(n3Mk2 log k) andO(n2k), respectively.
There are cleverer ways to reduce the complexity
(e.g., see (Huang and Chiang, 2005) for three such
ways). However, since the efficiency of the algo-
rithm did not limit us to produce k-best parses for
larger k, it was not a priority in this work.

5 Kernels for Reranking Discourse Trees

In Section 3, we described DISCTK, which essen-
tially can be used for any classification task involv-
ing discourse trees. For example, given a DT, we
can use DISCTK to classify it as correct vs. in-
correct. However, such classification is not com-
pletely aligned to our purpose, since our goal is
to select the best (i.e., the most correct) DT from
k candidate DTs; i.e., a ranking task. We adopt
a preference reranking technique as described in
(Moschitti et al., 2006; Dinarelli et al., 2011).

5.1 Preference Reranker

Preference reranking (PR) uses a classifier C of
pairs of hypotheses 〈hi, hj〉, which decides if hi
(i.e., a candidate DT in our case) is better than
hj . We generate positive and negative examples to
train the classifier using the following approach.
The pairs 〈h1, hi〉 constitute positive examples,
where h1 has the highest f -score accuracy on the
Relation metric (to be described in Section 6) with
respect to the gold standard among the candidate
hypotheses, and vice versa, 〈hi, h1〉 are considered
as negative examples. At test time, C classifies all
pairs 〈hi, hj〉 generated from the k-best hypothe-
ses. A positive decision is a vote for hi, and a neg-
ative decision is a vote for hj . Also, the classifier
score can be used as a weighted vote. Hypotheses
are then ranked according to the number (sum) of
the (weighted) votes they get.6

We build our reranker using simple SVMs.7

6As shown by Collins and Duffy (2002), only the classifi-
cation of k hypotheses (paired with the empty one) is needed
in practice, thus the complexity is only O(k).

7Structural kernels, e.g., TKs, cannot be used in more ad-
vanced algorithms working in structured output spaces, e.g.,
SVMstruct. Indeed, to our knowledge, no one could suc-
cessfully find a general and exact solution for the argmax
equation, typically part of such advanced models, when struc-
tural kernels are used. Some approximate solutions for sim-
ple kernels, e.g., polynomial or gaussian kernels, are given in
(Joachims and Yu, 2009), whereas (Severyn and Moschitti,
2011; Severyn and Moschitti, 2012) provide solutions for
using the cutting-plane algorithm (which requires argmax
computation) with structural kernels but in binary SVMs.

2054



Since in our problem a pair of hypotheses 〈hi, hj〉
constitutes a data instance, we now need to define
the kernel between the pairs. However, notice that
DISCTK only works on a single pair.

Considering that our task is to decide whether
hi is better than hj , it can be convenient to
represent the pairs in terms of differences be-
tween the vectors of the two hypotheses, i.e.,
φK(hi)− φK(hj), where K (i.e., DISCTK) is de-
fined between two hypotheses (not on two pairs
of hypotheses). More specifically, to compute
this difference implicitly, we can use the follow-
ing kernel summation: PK(〈h1, h2〉, 〈h′1, h′2〉) =
(φK(h1) − φK(h2)) ◦ (φK(h′1) − φK(h′2)) =
K(h1, h′1)+K(h2, h′2)−K(h1, h′2)−K(h2, h′1).

In general, Preference Kernel (PK) works well
because it removes many identical features by tak-
ing differences between two huge implicit TK-
vectors. In our reranking framework, we also in-
clude traditional feature vectors in addition to the
trees. Therefore, each hypothesis h is represented
as a tuple 〈T,~v〉 composed of a tree T and a fea-
ture vector ~v. We then define a structural kernel
(i.e., similarity) between two hypotheses h and
h′ as follows: K(h, h′) = DiscTK(T, T ′) +
FV (~v,~v′), where DISCTK maps the DTs T and
T ′ to JRN or SRN and then applies STK, STKb or
PTK defined in Sections 2.2 and 3, and FV is a
standard kernel, e.g., linear, polynomial, gaussian,
etc., over feature vectors (see next section).

5.2 Feature Vectors

We also investigate the impact of traditional
(i.e., not subtree) features for reranking discourse
parses. Our feature vector comprises two types of
features that capture global properties of the DTs.

Basic Features. This set includes eight global
features. The first two are the probability and
the (inverse) rank of the DT given by the base
parser. These two features are expected to help
the reranker to perform at least as good as the base
parser. The other six features encode the structural
properties of the DT, which include depth of the
DT, number of nodes connecting two EDUs (i.e.,
SPANs in Figure 4), number of nodes connecting
two relational nodes, number of nodes connecting
a relational node and an EDU, number of nodes
that connects a relational node as left child and an
EDU as right child, and vice versa.

Relation Features. We encode the relations in
the DT as bag-of-relations (i.e., frequency count).

This will allow us to assess the impact of a flat rep-
resentation of the DT. Note that more important
relational features would be the subtree patterns
extracted from the DT. However, they are already
generated by TKs in a simpler way. See (Pighin
and Moschitti, 2009; Pighin and Moschitti, 2010)
for a way to extract the most relevant features from
a model learned in the kernel space.

6 Experiments

Our experiments aim to show that reranking of
discourse parses is a promising research direction,
which can improve the state-of-the-art. To achieve
this, we (i) compute the oracle accuracy of the k-
best parser, (ii) test different kernels for reranking
discourse parses by applying standard kernels to
our new structures, (iii) show the reranking perfor-
mance using the best kernel for different number
of hypotheses, and (iv) show the relative impor-
tance of features coming from different sources.

6.1 Experimental Setup

Data. We use the standard RST-DT corpus (Carl-
son et al., 2002), which comes with discourse an-
notations for 385 articles (347 for training and 38
for testing) from the Wall Street Journal. We ex-
tracted sentence-level DTs from a document-level
DT by finding the subtrees that exactly span over
the sentences. This gives 7321 and 951 sentences
in the training and test sets, respectively. Follow-
ing previous work, we use the same 18 coarser re-
lations defined by Carlson and Marcu (2001).

We create the training data for the reranker in a
5-fold cross-validation fashion.8 Specifically, we
split the training set into 5 equal-sized folds, and
train the parsing model on 4 folds and apply to the
rest to produce k most probable DTs for each text.
Then we generate and label the pairs (by compar-
ing with the gold) from the k most probable trees
as described in Section 5.1. Finally, we merge the
5 labeled folds to create the full training data.

SVM Reranker. We use SVM-light-TK to train
our reranking models,9 which enables the use
of tree kernels (Moschitti, 2006) in SVM-light
(Joachims, 1999). We build our new kernels for
reranking exploiting the standard built-in TK func-
tions, such as STK, STKb and PTK. We applied

8Note that our earlier experiments with a 2-fold cross vali-
dation process yielded only 50% of our current improvement.

9http://disi.unitn.it/moschitti/Tree-Kernel.htm

2055



a linear kernel to standard feature vectors as it
showed to be the best on our development set.

Metrics. The standard procedure to evaluate dis-
course parsing performance is to compute Pre-
cision, Recall and f -score of the unlabeled and
labeled metrics proposed by Marcu (2000b).10

Specifically, the unlabeled metric Span measures
how accurate the parser is in finding the right
structure (i.e., skeleton) of the DT, while the la-
beled metrics Nuclearity and Relation measure the
parser’s ability to find the right labels (nuclearity
and relation) in addition to the right structure. Op-
timization of the Relation metric is considered to
be the hardest and the most desirable goal in dis-
course parsing since it gives aggregated evaluation
on tree structure and relation labels. Therefore,
we measure the oracle accuracy of the k-best dis-
course parser based on the f -scores of the Relation
metric, and our reranking framework aims to op-
timize the Relation metric.11 Specifically, the ora-
cle accuracy for k-best parsing is measured as fol-

lows: ORACLE =
∑N

i=1 max
k
j=1 f−scorer(gi,hji)

N , where
N is the total number of texts (sentences or docu-
ments) evaluated, gi is the gold DT annotation for
text i, hji is the j

th parse hypothesis generated by
the k-best parser for text i, and f -scorer(gi, h

j
i ) is

the f -score accuracy of hypothesis hji on the Re-
lation metric. In all our experiments we report the
f -scores of the Relation metric.

6.2 Oracle Accuracy

Table 1 presents the oracle scores of the k-
best intra-sentential parser PAR-S on the standard
RST-DT test set. The 1-best result corresponds
to the accuracy of the base parser (i.e., 79.77%).
The 2-best shows dramatic oracle-rate improve-
ment (i.e., 4.65% absolute), suggesting that the
base parser often generates the best tree in its
top 2 outputs. 5-best increases the oracle score
to 88.09%. Afterwards, the increase in accuracy
slows down, achieving, e.g., 90.37% and 92.57%
at 10-best and 20-best, respectively.

The results are quite different at the document
level as Table 2 shows the oracle scores of the k-
best document-level parser PAR-D.12 The results

10Precision, Recall and f -score are the same when the dis-
course parser uses manual discourse segmentation. Since all
our experiments in this paper are based on manual discourse
segmentation, we only report the f -scores.

11It is important to note that optimizing Relation metric
may also result in improved Nuclearity scores.

12For document-level parsing, Joty et al. (2013) pro-

k 1 2 5 10 15 20
PAR-S 79.77 84.42 88.09 90.37 91.74 92.57

Table 1: Oracle scores as a function of k of k-best sentence-
level parses on RST-DT test set.

k 1 2 5 10 15 20
PAR-D 55.83 56.52 56.91 57.23 57.54 57.65

Table 2: Oracle scores as a function of k of k-best
document-level parses on RST-DT test set.

suggest that the best tree is often missing in the
top k parses, and the improvement in oracle-rate is
very little as compared to the sentence-level pars-
ing. The 2-best and the 5-best improve over the
base accuracy by only 0.7% and 1.0%, respec-
tively. The improvement becomes even lower for
larger k. For example, the gain from 20-best to
30-best parsing is only 0.09%. This is not sur-
prising because generally document-level DTs are
big with many constituents, and only a very few
of them change from k-best to k+1-best parsing.
These small changes do not contribute much to
the overall f -score accuracy.13 In summary, the
results in Tables 1 and 2 demonstrate that a k-best
reranker can potentially improve the parsing accu-
racy at the sentence level, but may not be a suit-
able option for improving parsing at the document
level. In the following, we report our results for
reranking sentence-level discourse parses.

6.3 Performance of Different DISCTKs

Section 3 has pointed out that different DISCTKs
can be obtained by specifying the TK type (e.g.,
STK, STKb, PTK) and the mapping φM (i.e.,
JRN, SRN) in the overall kernel function

(
φTK ◦

φM
)
(o1)·

(
φTK◦φM

)
(o2). Table 3 reports the per-

formance of such model compositions using the 5-
best hypotheses on the RST-DT test set. Addition-
ally, it also reports the accuracy for the two ver-
sions of JRN and SRN, i.e., Bigram and All. From
these results, we can note the following.

Firstly, the kernels generally perform better on
Bigram than All lexicalization. This suggests that
using all the words from the text spans (i.e., EDUs)
produces sparse models.

pose two approaches to combine intra- and multi-sentential
parsers, namely 1S-1S (1 Sentence-1 Subtree) and Sliding
window. In this work we extend 1S-1S to k-best document-
level parser PAR-D since it is not only time efficient but it
also achieves better results on the Relation metric.

13Note that Joty et al. (2012; 2013) report lower f -scores
both at the sentence level (i.e., 77.1% as opposed to our
79.77%) and at the document level (i.e., 55.73% as opposed
to our 55.83%). We fixed a crucial bug in their (1-best) pars-
ing algorithm, which accounts for the improved performance.

2056



φTK ◦ φM JRN SRN
Bigram All Bigram All

STK 81.28 80.04 82.15 80.04
STKb 81.35 80.28 82.18 80.25
PTK 81.63 78.50 81.42 78.25

Table 3: Reranking performance of different discourse tree
kernels on different representations.

Secondly, while the tree kernels perform sim-
ilarly on the JRN representation, STK performs
significantly better (p-value < 0.01) than PTK
on SRN.14 This result is interesting as it pro-
vides indications of the type of DT fragments use-
ful for improving parsing accuracy. As pointed
out in Section 2.2, PTK includes all features
generated by STK, and additionally, it includes
fragments whose nodes can have any subsets of
the children they have in the original DT. Since
this does not improve the accuracy, we speculate
that complete fragments, e.g., [CAUSE [ATTRI-
BUTION][ELABORATION]] are more meaningful
than the partial ones, e.g., [CAUSE [ATTRIBU-
TION]] and [CAUSE [ELABORATION]], which
may add too much uncertainty on the signature
of the relations contained in the DT. We verified
this hypothesis by running an experiment with
PTK constraining it to only generate fragments
whose nodes preserve all or none of their children.
The accuracy of such fragments approached the
ones of STK, suggesting that relation information
should be used as a whole for engineering features.

Finally, STKb is slightly (but not significantly)
better than STK suggesting that the lexical infor-
mation is already captured by the base parser.

Note that the results in Table 3 confirms many
other experiments we carried out on several devel-
opment sets. For any run: (i) STK always performs
as well as STKb, (ii) STK is always better than
PTK, and (iii) SRN is always better than JRN. In
what follows, we show the reranking performance
based on STK applied to SRN with Bigram.

6.4 Insights on DISCTK-based Reranking
Table 4 reports the performance of our reranker
(RR) in comparison with the oracle (OR) accuracy
for different values of k, where we also show the
corresponding relative error rate reduction (ERR)
with respect to the baseline. To assess the general-
ity of our approach, we evaluated our reranker on
both the standard test set and the entire training set
using 5-fold cross validation.15

14Statistical significance is verified using paired t-test.
15The reranker was trained on 4 folds and tested on the rest

Baseline Basic feat. + Rel. feat. + Tree
79.77 79.84 79.81 82.15

Table 5: Comparison of features from different sources for
5-best discourse reranking.

(Joty et al., 2013) With Reranker
PAR-D 55.8 57.3

Table 6: Document-level parsing results with 5-best
sentence-level discourse reranker.

We note that: (i) the best result on the standard
test set is 82.15% for k = 4 and 5, which gives
an ERR of 11.76%, and significantly (p-value <
0.01) outperforms the baseline, (ii) the improve-
ment is consistent when we move from standard
test set to 5-folds, (iii) the best result on the 5-folds
is 80.86 for k = 6, which is significantly (p-value
< 0.01) better than the baseline 78.57, and gives
an ERR of 11.32%. We also experimented with
other values of k in both training and test sets (also
increasing k only in the test set), but we could not
improve over our best result. This suggests that
outperforming the baseline (which in our case is
the state of the art) is rather difficult.16

In this respect, we also investigated the im-
pact of traditional ranking methods based on fea-
ture vectors, and compared it with our TK-based
model. Table 5 shows the 5-best reranking accu-
racy for different feature subsets. The Basic fea-
tures (Section 5.2) alone do not significantly im-
prove over the Baseline. The only relevant fea-
tures are the probability and the rank of each hy-
pothesis, which condense all the information of
the local model (TKs models always used them).

Similarly, adding the relations as bag-of-
relations in the vector (Rel. feat.) does not pro-
vide any gain, whereas the relations encoded in
the tree fragments (Tree) gives improvement. This
shows the importance of using structural depen-
dencies for reranking discourse parses.

Finally, Table 6 shows that if we use our
sentence-level reranker in the document-level
parser of Joty et al. (2013), the accuracy of the lat-
ter increases from 55.8% to 57.3%, which is a sig-
nificant improvement (p < 0.01), and establishes
a new state-of-the-art for document-level parsing.

6.5 Error Analysis

We looked at some examples where our reranker
failed to identify the best DT. Unsurprisingly, it

16The human agreement on sentence-level parsing is 83%.

2057



Standard test set 5-folds (average)
k=1 k=2 k=3 k=4 k=5 k=6 k=1 k=2 k=3 k=4 k=5 k=6

RR 79.77 81.08 81.56 82.15 82.15 82.11 78.57 79.76 80.28 80.68 80.80 80.86
ERR - 6.48 8.85 11.76 11.76 11.57 - 5.88 8.45 10.43 11.02 11.32
OR 79.77 84.42 86.55 87.68 88.09 88.75 78.57 83.20 85.13 86.49 87.35 88.03

Table 4: Reranking performance (RR) in comparison with oracle (OR) accuracy for different values of k on the standard
testset and 5-folds of RST-DT. Second row shows the relative error rate reduction (ERR).

happens many times for small DTs containing
only two or three EDUs, especially when the re-
lations are semantically similar. Figure 9 presents
such a case, where the reranker fails to rank the
DT with Summary ahead of the DT with Elabo-
ration. Although we understand that the reranker
lacks enough structural context to distinguish the
two relations in this example, we expected that in-
cluding the lexical items (e.g., (CFD)) in our DT
representation could help. However, similar short
parenthesized texts are also used to elaborate as
in Senate Majority Leader George Mitchell (D.,
Maine), where the text (D., Maine) (i.e., Democrat
from state Maine) elaborates its preceding text.
This confuses our reranker. We also found er-
ror examples where the reranker failed to distin-
guish between Background and Elaboration, and
between Cause and Elaboration. This suggests
that we need rich semantic representation of the
text to improve our reranker further.

7 Related Work
Early work on discourse parsing applied hand-
coded rules based on discourse cues and surface
patterns (Marcu, 2000a). Supervised learning was
first attempted by Marcu (2000b) to build a shift-
reduce discourse parser. This work was then con-
siderably improved by Soricut and Marcu (2003).
They presented probabilistic generative models for
sentence-level discourse parsing based on lexico-
syntactic patterns. Sporleder and Lapata (2005)
investigated the necessity of syntax in discourse
analysis. More recently, Hernault et al. (2010)
presented the HILDA discourse parser that itera-
tively employs two SVM classifiers in pipeline to
build a DT in a greedy way. Feng and Hirst (2012)
improved the HILDA parser by incorporating rich
linguistic features, which include lexical seman-
tics and discourse production rules.

Joty et al. (2013) achieved the best prior results
by (i) jointly modeling the structure and the la-
bel of a DT constituent, (ii) performing optimal
rather than greedy decoding, and (iii) discriminat-
ing between intra- and multi-sentential discourse
parsing. However, their model does not con-

Same-UnitSummary

begins trading today.On the Big Board, Crawford & Co., Atlanta, (CFD)

Elaboration

Figure 9: An error made by our reranker.

sider long range dependencies between DT con-
stituents, which are encoded by our kernels. Re-
garding the latter, our work is surely inspired by
(Collins and Duffy, 2002), which uses TK for syn-
tactic parsing reranking or in general discrimina-
tive reranking, e.g., (Collins and Koo, 2005; Char-
niak and Johnson, 2005; Dinarelli et al., 2011).
However, such excellent studies do not regard
discourse parsing, and in absolute they achieved
lower improvements than our methods.

8 Conclusions and Future Work
In this paper, we have presented a discriminative
approach for reranking discourse trees generated
by an existing discourse parser. Our reranker uses
tree kernels in SVM preference ranking frame-
work to effectively capture the long range struc-
tural dependencies between the constituents of a
discourse tree. We have shown the reranking per-
formance for sentence-level discourse parsing us-
ing the standard tree kernels (i.e., STK and PTK)
on two different representations (i.e., JRN and
SRN) of the discourse tree, and compare it with
the traditional feature vector-based approach. Our
results show that: (i) the reranker improves only
when it considers subtree features computed by
the tree kernels, (ii) SRN is a better representation
than JRN, (iii) STK performs better than PTK for
reranking discourse trees, and (iv) our best result
outperforms the state-of-the-art significantly.

In the future, we would like to apply our
reranker to the document-level parses. However,
this will require a better hypotheses generator.

Acknowledgments
This research is part of the Interactive sYstems
for Answer Search (Iyas) project, conducted by
the Arabic Language Technologies (ALT) group
at Qatar Computing Research Institute (QCRI)
within the Qatar Foundation.

2058



References
Lynn Carlson and Daniel Marcu. 2001. Discourse Tag-

ging Reference Manual. Technical Report ISI-TR-
545, University of Southern California Information
Sciences Institute.

Lynn Carlson, Daniel Marcu, and Mary Ellen
Okurowski. 2002. RST Discourse Treebank (RST-
DT) LDC2002T07. Linguistic Data Consortium,
Philadelphia.

Eugene Charniak and Mark Johnson. 2005. Coarse-
to-Fine n-Best Parsing and MaxEnt Discriminative
Reranking. In Proceedings of the 43rd Annual Meet-
ing of the Association for Computational Linguis-
tics, ACL’05, pages 173–180, NJ, USA. ACL.

Michael Collins and Nigel Duffy. 2002. New Ranking
Algorithms for Parsing and Tagging: Kernels over
Discrete Structures, and the Voted Perceptron. In
ACL.

Michael Collins and Terry Koo. 2005. Discriminative
Reranking for Natural Language Parsing. Comput.
Linguist., 31(1):25–70, March.

Corinna Cortes and Vladimir Vapnik. 1995. Support
Vector Networks. Machine Learning, 20:273–297.

Marco Dinarelli, Alessandro Moschitti, and Giuseppe
Riccardi. 2011. Discriminative Reranking for
Spoken Language Understanding. IEEE Transac-
tions on Audio, Speech and Language Processing
(TASLP), 20:526539.

Vanessa Feng and Graeme Hirst. 2012. Text-level Dis-
course Parsing with Rich Linguistic Features. In
Proceedings of the 50th Annual Meeting of the As-
sociation for Computational Linguistics, ACL ’12,
pages 60–68, Jeju Island, Korea. ACL.

Hugo Hernault, Helmut Prendinger, David A. duVerle,
and Mitsuru Ishizuka. 2010. HILDA: A Discourse
Parser Using Support Vector Machine Classification.
Dialogue and Discourse, 1(3):1—33.

Liang Huang and David Chiang. 2005. Better K-
best Parsing. In Proceedings of the Ninth Inter-
national Workshop on Parsing Technology, Parsing
’05, pages 53–64, Stroudsburg, PA, USA. Associa-
tion for Computational Linguistics.

Thorsten Joachims and Chun-Nam John Yu. 2009.
Sparse Kernel SVMs via Cutting-Plane Training.
Machine Learning, 76(2-3):179–193. ECML.

Thorsten Joachims. 1999. Making large-Scale SVM
Learning Practical. In Advances in Kernel Methods
- Support Vector Learning.

Shafiq Joty, Giuseppe Carenini, and Raymond T. Ng.
2012. A Novel Discriminative Framework for
Sentence-Level Discourse Analysis. In Proceedings
of the 2012 Joint Conference on Empirical Methods
in Natural Language Processing and Computational
Natural Language Learning, EMNLP-CoNLL ’12,
pages 904–915, Jeju Island, Korea. ACL.

Shafiq Joty, Giuseppe Carenini, Raymond T. Ng, and
Yashar Mehdad. 2013. Combining Intra- and
Multi-sentential Rhetorical Parsing for Document-
level Discourse Analysis. In Proceedings of the
51st Annual Meeting of the Association for Compu-
tational Linguistics, ACL ’13, Sofia, Bulgaria. ACL.

William Mann and Sandra Thompson. 1988. Rhetor-
ical Structure Theory: Toward a Functional Theory
of Text Organization. Text, 8(3):243–281.

Daniel Marcu. 2000a. The Rhetorical Parsing of Un-
restricted Texts: A Surface-based Approach. Com-
putational Linguistics, 26:395–448.

Daniel Marcu. 2000b. The Theory and Practice of
Discourse Parsing and Summarization. MIT Press,
Cambridge, MA, USA.

Alessandro Moschitti, Daniele Pighin, and Roberto
Basili. 2006. Semantic Role Labeling via Tree Ker-
nel Joint Inference. In Proceedings of the Tenth
Conference on Computational Natural Language
Learning (CoNLL-X), pages 61–68, New York City,
June. Association for Computational Linguistics.

Alessandro Moschitti. 2006. Efficient Convolution
Kernels for Dependency and Constituent Syntactic
Trees. In 17th European Conference on Machine
Learning, pages 318–329. Springer.

Alessandro Moschitti. 2010. Kernel Engineering for
Fast and Easy Design of Natural Language Applica-
tions. In COLING (Tutorials), pages 1–91.

Alessandro Moschitti. 2012. State-of-the-Art Kernels
for Natural Language Processing. In Tutorial Ab-
stracts of ACL 2012, page 2, Jeju Island, Korea, July.
Association for Computational Linguistics.

Alessandro Moschitti. 2013. Kernel-based Learning
to Rank with Syntactic and Semantic Structures. In
SIGIR, page 1128.

Daniele Pighin and Alessandro Moschitti. 2009. Re-
verse Engineering of Tree Kernel Feature Spaces. In
EMNLP, pages 111–120.

Daniele Pighin and Alessandro Moschitti. 2010. On
Reverse Feature Engineering of Syntactic Tree Ker-
nels. In Proceedings of the Fourteenth Confer-
ence on Computational Natural Language Learning,
pages 223–233, Uppsala, Sweden, July. Association
for Computational Linguistics.

Aliaksei Severyn and Alessandro Moschitti. 2011.
Fast Support Vector Machines for Structural Ker-
nels. In ECML/PKDD (3), pages 175–190.

Aliaksei Severyn and Alessandro Moschitti. 2012.
Fast Support Vector Machines for Convolution Tree
Kernels. Data Min. Knowl. Discov., 25(2):325–357.

John Shawe-Taylor and Nello Cristianini. 2004. Ker-
nel Methods for Pattern Analysis. Cambridge Uni-
versity Press.

2059



Radu Soricut and Daniel Marcu. 2003. Sentence Level
Discourse Parsing Using Syntactic and Lexical In-
formation. In Proceedings of the 2003 Conference
of the North American Chapter of the Association
for Computational Linguistics on Human Language
Technology - Volume 1, NAACL’03, pages 149–156,
Edmonton, Canada. ACL.

Caroline Sporleder and Mirella Lapata. 2005. Dis-
course Chunking and its Application to Sentence
Compression. In Proceedings of the conference
on Human Language Technology and Empirical
Methods in Natural Language Processing, HLT-
EMNLP’05, pages 257–264, Vancouver, British
Columbia, Canada. ACL.

Charles Sutton, Andrew McCallum, and Khashayar
Rohanimanesh. 2007. Dynamic Conditional Ran-
dom Fields: Factorized Probabilistic Models for La-
beling and Segmenting Sequence Data. Journal of
Machine Learning Research (JMLR), 8:693–723.

2060


