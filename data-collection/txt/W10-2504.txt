










































Millstream Systems - a Formal Model for Linking Language Modules by Interfaces


Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing, ACL 2010, pages 28–36,
Uppsala, Sweden, 16 July 2010. c©2010 Association for Computational Linguistics

Millstream Systems – a Formal Model for
Linking Language Modules by Interfaces

Suna Bensch

Department of Computing Science,

Umeå University, Umeå, Sweden

suna@cs.umu.se

Frank Drewes

Department of Computing Science,

Umeå University, Umeå, Sweden

drewes@cs.umu.se

Abstract

We introduce Millstream systems, a for-

mal model consisting of modules and an

interface, where the modules formalise

different aspects of language, and the in-

terface links these aspects with each other.

1 Credits

This work is partially supported by the project

Tree Automata in Computational Language Tech-

nology within the Sweden – South Africa Re-

search Links Programme. A preliminary but more

detailed version of this article is available as a

technical report (Bensch and Drewes, 2009).

2 Introduction

Modern linguistic theories (Sadock, 1991; Jack-

endoff, 2002) promote the view that different as-

pects of language, such as phonology, morphol-

ogy, syntax, and semantics should be viewed as

autonomous modules that work simultaneously

and are linked with each other by interfaces that

describe their interaction and interdependency.

Formalisms in modern computational linguistics

which establish interfaces between different as-

pects of language are the Combinatory Categorical

Grammar (CCG), the Functional Generative De-

scription (FGD), the Head-Driven Phrase Struc-

ture Grammar (HPSG), the Lexical Functional

Grammar (LFG), and the Extensible Dependency

Grammar (XDG).1 Here, we propose Millstream

systems, an approach from a formal language the-

oretic point of view which is based on the same

ideas as XDG, but uses tree-generating modules

of arbitrary kinds.

Let us explain in slightly more detail what a

Millstream system looks like. A Millstream sys-

tem contains any number of tree generators, called

1See, e.g., (Dalrymple, 2001; Sgall et al., 1986; Pollard
and Sag, 1994; Steedman, 2000; Debusmann, 2006; Debus-
mann and Smolka, 2006).

its modules. Such a tree generator is any device

that specifies a tree language. For example, a tree

generator may be a context-free grammar, tree ad-

joining grammar, a finite-state tree automaton, a

dependency grammar, a corpus, human input, etc.

Even within a single Millstream system, the mod-

ules need not be of the same kind, since they are

treated as “black boxes”. The Millstream system

links the trees generated by the modules by an in-

terface consisting of logical formulas.

Suppose that a Millstream system has k mod-
ules. Then the interface consists of interface rules

in the form of logical expressions that establish

links between the (nodes of the) trees t1, . . . , tk
that are generated by the individual modules.

Thus, a valid combination of trees is not just any

collection of trees t1, . . . , tk generated by the k
modules. It also includes, between these struc-

tures, interconnecting links that represent their

relationships and that must follow the rules ex-

pressed by the interface. Grammaticality, in terms

of a Millstream system, means that the individ-

ual structures must be valid (i.e., generated by the

modules) and are linked in such a way that all in-

terface rules are logically satisfied. A Millstream

system can thus be considered to perform indepen-

dent concurrent derivations of autonomous mod-

ules, enriched by an interface that establishes links

between the outputs of the modules, thus con-

straining the acceptable configurations.

Millstream systems may, for example, be of in-

terest for natural language understanding and nat-

ural language generation. Simply put, the task

of natural language understanding is to construct

a suitable semantic representation of a sentence

that has been heard (phonology) and parsed (syn-

tax). Within the framework of Millstream sys-

tems this corresponds to the problem where we are

given a syntactic tree (and possibly a phonologi-

cal tree if such a module is involved) and the goal

is to construct an appropriate semantic tree. Con-

28



versely, natural language generation can be seen as

the problem to construct an appropriate syntactic

(and/or phonological) tree from a given semantic

tree. In abstract terms, the situations just described

are identical. We refer to the problem as the

completion problem. While the current paper is

mainly devoted to the introduction and motivation

of Millstream systems, in (Bensch et al., 2010) the

completion problem is investigated for so-called

regular MSO Millstream systems, i.e. systems in

which the modules are regular tree grammars (or,

equivalently, finite tree automata) and the interface

conditions are expressed in monadic second-order

(MSO) logic. In Section 7, the results obtained so

far are briefly summarised.

Now, let us roughly compare Millstream sys-

tems with XDG. Conceptually, the k modules of a
Millstream system correspond to the k dimensions
of an XDG. In an XDG, a configuration consists

of dependency structures t1, . . . , tk. The interface
of a Millstream system corresponds to the princi-

ples of the XDG. The latter are logical formulas

that express conditions that the collection of de-

pendency structures must fulfill.

The major difference between the two for-

malisms lies in the fact that XDG inherently builds

upon dependency structures, whereas the modules

of a Millstream system are arbitrary tree genera-

tors. In XDG, each of t1, . . . , tk is a dependency
analysis of the sentence considered. In particu-

lar, they share the yield and the set of nodes (as

the nodes of a dependency tree correspond to the

words in the sentence analysed, and its yield is that

sentence). Millstream systems do not make simi-

lar assumptions, which means that they may give

rise to new questions and possibilities:

• The purpose of a Millstream system is not
necessarily the analysis of sentences. For ex-

ample, a Millstream system with two mod-

ules could translate one language into an-

other. For this, tree grammars representing

the source and target languages could be used

as modules, with an interface expressing that

t2 is a correct translation of t1. This sce-
nario makes no sense in the context of XDG,

because the sentences represented by t1 and
t2 differ. Many similar applications of Mill-
stream system may the thought of, for exam-

ple correction or simplification of sentences.

• As the modules may be arbitrary devices
specifying tree languages, they contribute

their own generative power and theoretical

properties to the whole (in contrast to XDG,

which does not have such a separation). This

makes it possible to apply known results from

tree language theory, and to study the inter-

play between different kinds of modules and

interface logics.

• The fact that the individual modules of a
Millstream system may belong to different

classes of tree generators could be linguis-

tically valuable. For example, a Millstream

system combining a dependency grammar

module with a regular tree grammar module,

could be able to formalise aspects of a given

natural language that cannot be formalised by

using only one of these formalisms.

• For Millstream systems whose modules are
generative grammar formalisms (such as reg-

ular tree grammars, tree-adjoining grammars

and context-free tree grammars), it will be in-

teresting to study conditions under which the

Millstream system as a whole becomes gen-

erative, in the sense that well-formed config-

urations can be constructed in a step-by-step

manner based on the derivation relations of

the individual modules.

Let us finally mention another, somewhat sub-

tle difference between XDG and Millstream sys-

tems. In XDG, the interfaces are dimensions

on their own. For example, an XDG captur-

ing the English syntax and semantics would have

three dimensions, namely syntax, semantics, and

the syntax-semantics interface. An analysis of a

sentence would thus consist of three dependency

trees, where the third one represents the relation

between the other two. In contrast, a correspond-

ing Millstream system would only have two mod-

ules. The interface between them is considered

to be conceptually different and establishes direct

links between the trees that are generated by the

two modules. One of our tasks (which is, however,

outside the scope of this contribution) is a study of

the formal relation between XDG and Millstream

systems, to achieve a proper understanding of their

similarities and differences.

The rest of the paper is organised as follows.

In the next section, we discuss an example illus-

trating the linguistic notions and ideas that Mill-

stream systems attempt to provide a formal basis

for. After some mathematical preliminaries, which

29



are collected in Section 4, the formal definition of

Millstream systems is presented in Section 5. Sec-

tion 6 contains examples and remarks related to

Formal Language Theory. Finally, Section 7 dis-

cusses preliminary results and future work.

3 Linguistical Background

In this section, we discuss an example, roughly

following (Jackendoff, 2002), that illustrates the

linguistic ideas that have motivated our approach.

Figure 1 shows the phonological, syntactical and

semantical structure, depicted as trees (a), (b) and

(c), respectively of the sentence Mary likes Peter.

Trees are defined formally in the next section, for

the time being we assume the reader to be familiar

with the general notion of a tree as used in linguis-

tics and computer science.

s

w1

mE@ri

w2

w3

laIk

cl4

s

w5

pit@r

Morphophonology

Segmental structure

(a)

S

NP1 VP

V2

V3 infl4

NP5

(b) s

pres situation4

likestate3

maryagent1 peter
patient
5

(c)

Figure 1: Phonological, syntactical and semantical

structure of Mary likes Peter.

The segmental structure in the phonological

tree (a) is the basic pronunciation of the sentence

Mary likes Peter, where each symbol represents

a speech sound. This string of speech sound sym-

bols is structured into phonological words by mor-

phophonolgy. The morphophonological structure

in our example consists of the three full phono-

logical words mE@ri, laIk, pit@r and of the clitic s.
The clitic is attached to the adjacent phonologi-

cal word, thus forming a larger phonological con-

stituent. The syntactical tree (b) depicts the syn-

tactical constituents. The sentence S is divided
into a noun phrase NP and a verb phrase VP.
The verb phrase VP is divided into an inflected
verb V and a noun phrase NP. The inflected verb

consists of its uninflected form and its inflection,

which refers, in our example, to the grammatical

features present tense and third person singular.

The semantical tree (c) depicts the semantical con-

stituents. In our example, like is a function of type
state and takes two arguments, namely mary and
peter which are of type agent and patient .

The structure of Mary likes Peter is not just the

sum of its phonological, syntactical and semanti-

cal structures. It also includes the relationships be-

tween certain constituents in these tree structures.

To illustrate these relationships we use indices in

Figure 1. The sole role of the indices here is to

express the linguistic relationships among coin-

dexed constituents. The indices do not occur in the

formalisation, where they are replaced by logical

links relating the nodes that, in the figure, carry the

same indices.2 The morphophonological wordw1,
for example, is linked with the noun phrase NP1
in the syntactical tree and with the conceptual con-

stituent maryagent1 in the semantical tree. This il-
lustrates that w1, NP1, and mary

agent
1 are the cor-

responding morphophonological, syntactical and

semantical representations of Mary, respectively.

But there are also correspondences that concern

only the phonological and syntactical trees, ex-

cluding the semantical tree. For example, the in-

flected word V2 in the syntactical structure corre-
sponds to the phonological word w2, but has no
link to the semantical structure whatsoever.

4 Preliminaries

The set of non-negative integers is denoted by N,
and N+ = N \ {0}. For k ∈ N, we let [k] =
{1, . . . , k}. For a set S, the set of all nonempty
finite sequences (or strings) over S is denoted by
S+; if the empty sequence � is included, we write
S∗. As usual, A1×· · ·×Ak denotes the Cartesian
product of sets A1, . . . , Ak. The transitive and re-
flexive closure of a binary relation⇒ ⊆ A×A on
a set A is denoted by ⇒∗. A ranked alphabet is
a finite set Σ of pairs (f, k), where f is a symbol
and k ∈ N is its rank. We denote (f, k) by f (k), or
simply by f if k is understood or of lesser impor-
tance. Further, we let Σ(k) = {f (n) ∈ Σ | n = k}.
We define trees over Σ in one of the standard ways,
by identifying the nodes of a tree t with sequences
of natural numbers. Intuitively, such a sequence

2The reader is referred to (Bensch and Drewes, 2009) for
the proper formalisation of the example in terms of a Mill-
stream system.

30



shows that path from the root of the tree to the

node in question. In particular, the root is the

empty sequence �.
Formally, the set TΣ of trees over Σ consists of

all mappings t : V (t) → Σ (called trees) with the
following properties:

• The set V (t) of nodes of t is a finite and non-
empty prefix-closed subset of N∗+. Thus, for
every node vi ∈ V (t) (where i ∈ N+), its
parent v is in V (t) as well.

• For every node v ∈ V (t), if t(v) = f (k), then
{i ∈ N | vi ∈ V (t)} = [k]. In other words,
the children of v are v1, . . . , vk.

Let t ∈ TΣ be a tree. The root of t is the node
�. For every node v ∈ V (t), the subtree of t
rooted at v is denoted by t/v. It is defined by
V (t/v) = {v′ ∈ N∗ | vv′ ∈ V (t)} and, for all
v′ ∈ V (t/v), (t/v)(v′) = t(vv′). We shall de-
note a tree t as f [t1, . . . , tk] if t(�) = f (k) and
t/i = ti for i ∈ [k]. In the special case where
k = 0 (i.e., V (t) = {�}), the brackets may be
omitted, thus denoting t as f . For a set S of trees,
the set of all trees of the form f [t1, . . . , tk] such
that f (k) ∈ Σ and t1, . . . , tk ∈ S is denoted by
Σ(S). For a tuple T ∈ TkΣ, we let V (T ) denote
the set {(i, v) | i ∈ [k] and v ∈ V (ti)}. Thus,
V (T ) is the disjoint union of the sets V (ti). Fur-
thermore, we let V (T, i) denote the ith component
of this disjoint union, i.e., V (T, i) = {i} × V (ti)
for all i ∈ [k]. A tree language is a subset of TΣ,
for a ranked alphabet Σ, and a Σ-tree generator (or
simply tree generator) is any sort of formal device

G that determines a tree language L(G) ⊆ TΣ. A
typical sort of tree generator, which we will use in

our examples, is the regular tree grammar.

Definition 1 (regular tree grammar). A regular

tree grammar is a tuple G = (N,Σ, R, S) con-
sisting of disjoint ranked alphabets N and Σ of
nonterminals and terminals, where N = N (0), a
finite set R of rules A → r, where A ∈ N and
r ∈ TΣ∪N , and an initial nonterminal S ∈ N .

Given trees t, t′ ∈ TΣ∪N , there is a derivation
step t ⇒ t′ if t′ is obtained from t by replacing
a single occurrence of a nonterminal A with r,
where A → r is a rule in R. The regular tree
language generated by G is

L(G) = {t ∈ TΣ | S
∗⇒ t}.

It is well known that a string language L is
context-free if and only if there is a regular tree

language L′, such that L = yield(L′). Here,
yield(L′) = {yield(t) | t ∈ L′} denotes the set of
all yields of trees in L′, the yield yield(t) of a tree
t being the string obtained by reading its leaves
from left to right.

5 Millstream Systems

Throughout the rest of this paper, let Λ denote any
type of predicate logic that allows us to make use

of n-ary predicates symbols. We indicate the ar-
ity of predicate symbols in the same way as the

rank of symbols in ranked alphabets, i.e., by writ-

ing P (n) if P is a predicate symbol of arity n. The
set of all well-formed formulas in Λ without free
variables (i.e., the set of sentences of Λ) is denoted
by FΛ. If S is a set, we say that a predicate symbol
P (n) is S-typed if it comes with an associated type
(s1, . . . , sn) ∈ Sn. We write P : s1 × · · · × sn to
specify the type of P . Recall that an n-ary predi-
cate ψ on D is a function ψ : Dn → {true, false}.
Alternatively, ψ can be viewed as a subset of Dn,
namely the set of all (d1, . . . , dn) ∈ Dn such that
ψ(d1, . . . , dn) = true. We use these views in-
terchangeably, selecting whichever is more conve-

nient. Given a (finite) set P of predicate symbols,
a logical structure 〈D; (ψP )P∈P〉 consists of a set
D called the domain and, for each P (n) ∈ P , a
predicate ψP ⊆ Dn. If an existing structure Z
is enriched with additional predicates (ψP )P∈P ′
(where P∩P ′ = ∅), we denote the resulting struc-
ture by 〈Z; (ψP )P∈P ′〉. In this paper, we will only
consider structures with finite domains. To repre-

sent (tuples of) trees as logical structures, consider

a ranked alphabet Σ, and let r be the maximum
rank of symbols in Σ. A tuple T = (t1, . . . , tk) ∈
TkΣ will be represented by the structure

|T | = 〈V (T ); (Vi)i∈[k], (labg)g∈Σ, (↓i)i∈[r]〉

consisting of the domain V (T ) and the predicates
V

(1)
i (i ∈ [k]), lab

(1)
g (g ∈ Σ) and ↓(2)i (i ∈ [r]).

The predicates are given as follows:

• For every i ∈ [k], Vi = V (T, i). Thus, Vi(d)
expresses that d is a node in ti (or, to be pre-
cise, that d represents a node of ti in the dis-
joint union V (T )).

• For every g ∈ Σ, labg = {(i, v) ∈ V (T ) |
i ∈ [k] and ti(v) = g}. Thus, labg(d) ex-
presses that the label of d is g.

• For every j ∈ [r], ↓j = {((i, v), (i, vj)) |
i ∈ [k] and v, vj ∈ V (ti)}. Thus, ↓j(d, d′)

31



expresses that d′ is the jth child of d in one
of the trees t1, . . . , tk. In the following, we
write d ↓j d′ instead of ↓j(d, d′).

Note that, in the definition of |T |, we have
blurred the distinction between predicate symbols

and their interpretation as predicates, because this

interpretation is fixed. Especially in intuitive ex-

planations, we shall sometimes also identify the

logical structure |T | with the tuple T it represents.
To define Millstream systems, we start by for-

malising our notion of interfaces. The idea is that

a tuple T = (t1, . . . , tk) of trees, represented by
the structure |T |, is augmented with additional in-
terface links that are subject to logical conditions.

An interface may contain finitely many different

kinds of interface links. Formally, the collection

of all interface links of a given kind is viewed as

a logical predicate. The names of the predicates

are called interface symbols. Each interface sym-

bol is given a type that indicates which trees it is

intended to link with each other.

For example, if we want to make use of ternary

links called TIE, each linking a node of t1 with
a node of t3 and a node of t4, we use the in-
terface symbol TIE : 1 × 3 × 4. This interface
symbol would then be interpreted as a predicate

ψTIE ⊆ V (T, 1)× V (T, 3)× V (T, 4). Each triple
in ψTIE would thus be an interface link of type TIE
that links a node in V (t1) with a node in V (t3) and
a node in V (t4).

Definition 2 (interface). Let Σ be a ranked al-
phabet. An interface on TkΣ (k ∈ N) is a pair
INT = (I,Φ), such that

• I is a finite set of [k]-typed predicate symbols
called interface symbols, and

• Φ is a finite set of formulas in FΛ that may,
in addition to the fixed vocabulary of Λ, con-
tain the predicate symbols in I and those of
the structures |T | (where T ∈ TkΣ). These
formulas are called interface conditions.

A configuration (w.r.t. INT ) is a structure C =
〈|T |; (ψI)I∈I〉, such that

• T ⊆ TkΣ,

• ψI ⊆ V (T, i1)× · · · × V (T, il) for every in-
terface symbol I : i1 × · · · × il in I, and

• C satisfies the interface conditions in Φ (if
each symbol I ∈ I is interpreted as ψI ).

Note that several interfaces can always be com-

bined into one by just taking the union of their sets

of interface symbols and interface conditions.

Definition 3 (Millstream system). Let Σ be a
ranked alphabet and k ∈ N. A Millstream sys-
tem (MS, for short) is a system of the form MS =
(M1, . . . ,Mk; INT ) consisting of Σ-tree genera-
tors M1, . . . ,Mk, called the modules of MS , and
an interface INT on TkΣ. The language L(MS )
generated by MS is the set of all configurations
〈|T |; (ψI)I∈I〉 such that T ∈ L(M1) × · · · ×
L(Mk).

Sometimes we consider only some of the trees

in these tuples. For this, if MS is as above and
1 ≤ i1 < · · · < il ≤ k, we define the notation

LMi1×···×Mil (MS ) = {(ti1 , . . . , til) |
〈|(t1, . . . , tk); (ψI)I∈I |〉 ∈ L(MS )}.

The reader should note that, intentionally, Mill-

stream systems are not a priori “generative”. Even

less so, they are “derivational” by nature. This is

because there is no predefined notion of derivation

that allows us to create configurations by means

of a stepwise (though typically nondeterministic)

procedure. In fact, there cannot be one, unless we

make specific assumptions regarding the way in

which the modules work, but also regarding the

logic Λ and the form of the interface conditions
that may be used. Similarly, as mentioned in the

introduction, there is no predefined order of im-

portance or priority among the modules.

6 Examples and Remarks Related to

Formal Language Theory

The purpose of this section is to indicate, by

means of examples and easy observations, that

Millstream systems are not only linguistically well

motivated, but also worth studying from the point

of view of computer science, most notably regard-

ing their algorithmic and language-theoretic prop-

erties. While this kind of study is beyond the scope

of the current article, part of our future research on

Millstream systems will be devoted to such ques-

tions.

Example 1. Let Λ be ordinary first-order logic
with equality, and consider the Millstream system

MS over Σ = {◦(2), a(0), b(0), c(0), d(0)} which
consists of two identical modules M1 = M2 that
simply generate TΣ (e.g., using the regular tree
grammar with the single nonterminal S and the

32



rules3 S → ◦[S, S] | a | b | c | d) and a sin-
gle interface symbol BIJ : 1 × 2 with the interface
conditions

∀x : lab{a,b,c,d}(x)↔
∃y : BIJ(x, y) ∨ BIJ(y, x),

∀x, y, z : (BIJ(x, y) ∧ BIJ(x, z)∨
BIJ(y, x) ∧ BIJ(z, x))→ y = z,

∀x, y : BIJ(x, y)→∨
z∈{a,b,c,d}

(labz(x) ∧ labz(y)).

The first interface condition expresses that all

and only the leaves of both trees are linked. The

second expresses that no leaf is linked with two or

more leaves. In effect, this amounts to saying that

BIJ is a bijection between the leaves of the two

trees. The third interface condition expresses that

this bijection is label preserving. Altogether, this

amounts to saying that the yields of the two trees

are permutations of each other; see Figure 2.

◦

◦

b ◦

c d

◦

a c

◦

d ◦

◦

c b

◦

c a

bij

bij

bij

bij

bij

Figure 2: An element of L(MS ) in Example 1.

Now, let us replace the modules by slightly

more interesting ones. For a string w over {A,B,
a, b, c, d}, let w denote any tree over {◦(2), A(0),
B(0), a(0), b(0), c(0), d(0)} with yield(w) = w.
(For example, we may choose w to be the left
comb whose leaf symbols are given by w.) Let the
Millstream system MS ′ be defined as MS , but us-
ing the modules M ′1 = ({A,B,C,D},Σ, R1, A)
and M ′2 = ({A,B},Σ, R2, A) with the following
rules:

R′1 = {A→ aA | aB, B → bB | bC,
C → cC | cD, D → dD | d},

R′2 = {A→ acA | acB, B → bdB | bd}.

Thus, M ′1 and M
′
2 are the “standard” grammars

(written as regular tree grammars) that generate

the regular languages {akblcmdn | k, l,m, n ≥
3As usual, A → r | r′ stands for A → r, A → r′.

1} and {(ac)m(bd)n | m,n ≥ 1}. The inter-
face makes sure that LM

′
1×M ′2(MS ′) contains only

those pairs of trees t1, t2 in which yield(t1) is a
permutation of yield(t2). As a consequence, it
follows that yield(LM

′
1(MS )) = {ambncmdn |

m,n ≥ 1}.
The next example discusses how top-down tree

transductions can be implemented as Millstream

systems.

Example 2 (top-down tree transduction). Recall

that a tree transduction is a binary relation τ ⊆
TΣ × TΣ′ , where Σ and Σ′ are ranked alpha-
bets. The set of trees that a tree t ∈ TΣ is trans-
formed into is given by τ(t) = {t′ ∈ TΣ′ |
(t, t′) ∈ τ}. Obviously, every Millstream system
of the form MS = (M1,M2; INT ) defines a tree
transduction, namely LM1×M2(MS ). Let us con-
sider a very simple instance of a deterministic top-

down tree transduction τ (see, e.g., (Gécseg and
Steinby, 1997; Fülöp and Vogler, 1998; Comon et

al., 2007) for definitions and references regarding

top-down tree transductions), where Σ = Σ′ =
{f (2), g(2), a(0)}. We transform a tree t ∈ TΣ into
the tree obtained from t by interchanging the sub-
trees of all top-most fs (i.e., of all nodes that are
labelled with f and do not have an ancestor that
is labelled with f as well) and turning the f at
hand into a g. To accomplish this, a top-down
tree transducer would use two states, say SWAP

and COPY, to traverse the input tree from the top

down, starting in state SWAP. Whenever an f is
reached in this state, its subtrees are interchanged

and the traversal continues in parallel on each of

the subtrees in state COPY. The only purpose of

this state is to copy the input to the output without

changing it. Formally, this would be expressed by

the following term rewrite rules, viewing the states

as symbols of rank 1:

SWAP[f [x1, x2]] → g[COPY[x2], COPY[x1]],
COPY[f [x1, x2]] → f [COPY[x1], COPY[x2]],
SWAP[g[x1, x2]] → g[SWAP[x1], SWAP[x2]],
COPY[g[x1, x2]] → g[COPY[x1], COPY[x2]],

SWAP[a] → a,
COPY[a] → a.

(We hope that these rules are intuitive enough to

be understood even by readers who are unfamiliar

with top-down tree transducers, as giving the for-

mal definition of top-down tree transducers would

be out of the scope of this article.) We mimic

the behaviour of the top-down tree transducer us-

33



ing a Millstream system with interface symbols

SWAP : 1 × 2 and COPY : 1 × 2. Since the mod-
ules simply generate TΣ, they are not explicitly
discussed. The idea behind the interface is that an

interface link labelled q ∈ {SWAP, COPY} links a
node v in the input tree with a node v′ in the output
tree if the simulated computation of the tree trans-

ducer reaches v in state q, resulting in node v′ in
the output tree. First, we specify that the initial

state is SWAP, which simply means that the roots

of the two trees are linked by a SWAP link:

∀x, y : root1(x) ∧ root2(y)→ SWAP(x, y),

where root i is defined as root i(x) ≡ Vi(x) ∧
@y : y ↓1 x. It expresses that x is the root of
tree i. The next interface condition corresponds to
the first rule of the simulated top-down tree trans-

ducer:

∀x, y, x1, x2 : SWAP(x, y)∧labf (x)∧ x ↓1 x1∧
x ↓2 x2 → labg(y)∧∃y1, y2 : y ↓1 y1∧y ↓2 y2∧
COPY(x1, y2) ∧ COPY(x2, y1).

In a similar way, the remaining rules are turned

into interface conditions, e.g.,

∀x, y, x1, x2 : COPY(x, y)∧labf (x)∧ x ↓1 x1∧
x ↓2 x2 → labf (y)∧∃y1, y2 : y ↓1 y1∧y ↓2 y2∧
COPY(x1, y1) ∧ COPY(x2, y2).

The reader should easily be able to figure out

the remaining interface conditions required.

One of the elements of L(MS ) is shown in Fig-
ure 3. It should not be difficult to see that, indeed,

LM1×M2(MS ) = τ .

g

f

a f

a a

a

g

g

f

a a

a

a

swap

swap

copy

copy

copy copy

swap

Figure 3: An element of L(MS ) in Example 2.

Extending the previous example, one can eas-

ily see that all top-down and bottom-up tree trans-

ductions can be turned into Millstream systems

in a way similar to the construction above. A

similar remark holds for many other types of tree

transductions known from the literature. Most no-

tably, monadic second-order definable tree trans-

ductions (Engelfriet and Maneth, 1999; Engelfriet

and Hoogeboom, 2001; Engelfriet and Maneth,

2003) can be expressed as Millstream systems.

Since the mentioned types of tree transductions

are well studied, and much is known about their

algorithmic properties, future research on Mill-

stream systems should investigate the relation-

ship between different types of tree transductions

and Millstream systems in detail. In particular,

it should be tried to formulate requirements on

the interface conditions that can be used to ob-

tain characterisations of various classes of tree

transductions. We note here that results of this

type would not only be interesting from a purely

mathematical point of view, since tree transduc-

ers have turned out to be a valuable tool in, for

example, machine translation (Knight and Graehl,

2005; May and Knight, 2006; Graehl et al., 2008).

7 Preliminary Results and Future Work

Millstream systems, as introduced in this article,

are formal devices that allow to model situations

in which several tree-generating modules are inter-

connected by logical interfaces. In a forthcoming

paper (Bensch et al., 2010), we investigate the the-

oretical properties of regular MSO Millstream sys-

tems, i.e., Millstream systems in which the mod-

ules are regular tree grammars and the logic used

is monadic second-order logic. In particular, we

study the so-called completion problem. Given

a Millstream system with k modules and l ≤ k
known trees ti1 , . . . , til (1 ≤ i1 < · · · < il ≤ k),
the task is to find a completion, i.e., a configura-

tion whose ij th tree is tij for all j ∈ [l]. Thus, if
viewed as a pure decision problem, the completion

problem corresponds to the membership problem

for LMi1×···×Mil (MS ). To be useful in applica-
tions, algorithms solving the completion problem

should, of course, be required to explicitly con-

struct a completion rather than just answering yes.

Let us briefly summarize the results of (Bensch

et al., 2010).

1. In general, the completion problem is unde-

cidable for k − l ≥ 2 even in the case where
only the use of first-order logic is permitted.

This can be shown by reducing Post’s corre-

spondence problem (PCP) to the emptiness

problem for a regular FO Millstream system

with k = 2. The Millstream system con-
structed is somewhat similar to the one in Ex-

ample 1, as it establishes bijective correspon-

dences between the nodes of two trees (that

34



represent the two parts of a solution to a PCP

instance).

2. If there are no direct links between unknown

trees (i.e., |{j1, . . . , jm} \ {i1, . . . , il}| ≤ 1
for each interface symbol I : j1 × · · · × jm),
then the completion problem is solvable for

all regular MSO Millstream systems.

3. Applying some well-known results, the com-

pletion problem is solvable for all regular

MSO Millstream systems for which L(MS )
is of bounded tree width. Thus, it is of inter-

est to establish conditions that guarantee the

configurations in L(MS ) to be of bounded
tree width. Two such conditions, are given

in (Bensch et al., 2010). Roughly speaking,

they require that the links respect the struc-

ture of the trees. Let us informally describe

one of them, called nestedness. Say that a

link I ′(u1, . . . , um) is directly below a link
I(v1, . . . , vl) if there are i, j such that uj is
a descendant of vi and none of the nodes in
between carries a link. Now, fix a constant

h. A configuration is nested if the roots are
linked with each other and the following hold

for every link λ = I(v1, . . . , vl):

(a) There are at most h links I ′(u1, . . . , um)
directly below λ.

(b) Each of the nodes uj in (a) is a descen-
dant of one of the nodes vi.

As mentioned above, L(MS ) is of bounded
tree width if its configurations are nested

(with respect to the same constant h).

Nestedness, and also the second sufficient con-

dition for bounded tree width studied in (Bensch

et al., 2010) restrict the configurations themselves.

While such conditions may be appropriate in many

practical cases (where one knows what the config-

urations look like), future research should also at-

tempt to find out whether it is possible to put some

easily testable requirements on the interface con-

ditions in order to force the configurations to be

of bounded tree width. Note that, since the prop-

erty of being of tree width at most d is expressible
in monadic second-order logic, one can always ar-

tificially force the configurations of a given MSO

Millstream system to be of bounded tree width, but

this is not very useful as it would simply exclude

those configurations whose tree width is greater

than the desired constant d, thus changing the se-
mantics of the given Millstream system in a usu-

ally undesired manner.

Future work should also investigate properties

that make it possible to obtain or complete config-

urations in a generative way. For example, for reg-

ular MSO Millstream systems with interface con-

ditions of a suitable type, it should be possible to

generate the configurations in L(MS ) by generat-
ing the k trees in a parallel top-down manner, at
the same time establishing the interface links. Re-

sults of this kind could also be used for solving

the completion problem in an efficient manner. In

general, it is clear that efficiency must be an im-

portant aspect of future theoretical investigations

into Millstream systems.

In addition to theoretical results, a good imple-

mentation of Millstream systems is needed in or-

der to make it possible to implement nontrivial ex-

amples. While this work should, to the extent pos-

sible, be application independent, it will also be

necessary to seriously attempt to formalise and im-

plement linguistic theories as Millstream systems.

This includes exploring various such theories with

respect to their appropriateness.

To gain further insight into the usefulness and

limitations of Millstream systems for Computa-

tional Linguistics, future work should elaborate if

and how it is possible to translate formalisms such

as HPSG, LFG, CCG, FDG and XDG into Mill-

stream systems.

Acknowledgments

We thank Dot and Danie van der Walt for pro-

viding us with a calm and relaxed atmosphere at

Millstream Guest House in Stellenbosch (South

Africa), where the first ideas around Millstream

systems were born in April 2009. Scientifically,

we would like to thank Henrik Björklund, Stephen

J. Hegner, and Brink van der Merwe for discus-

sions and constructive input. Furthermore, we

would like to thank one of the referees for valu-

able comments.

References

Suna Bensch and Frank Drewes. 2009. Mill-
stream systems. Report UMINF 09.21,
Umeå University. Available at http:
//www8.cs.umu.se/research/uminf/

index.cgi?year=2009&number=21.

35



Suna Bensch, Henrik Björklund, and Frank Drewes.
2010. Algorithmic properties of Millstream sys-
tems. In Sheng Yu, editor, Proc. 14th Intl. Conf.
on Developments in Language Theory (DLT 2010),
Lecture Notes in Computer Science. To appear.

Hubert Comon, Max Dauchet, Rémi Gilleron, Flo-
rent Jacquemard, Christof Löding, Denis Lugiez,
Sophie Tison, and Marc Tommasi. 2007. Tree
Automata Techniques and Applications. Internet
publication available at http://tata.gforge.
inria.fr. Release October 2007.

Mary Dalrymple. 2001. Lexical Functional Gram-
mar, volume 34 of Syntax and Semantics. Academic
Press.

Ralph Debusmann and Gert Smolka. 2006. Multi-
dimensional dependency grammar as multigraph de-
scription. In Proceedings of FLAIRS Conference,
pages 740–745.

Ralph Debusmann. 2006. Extensible Dependency
Grammar: A Modular Grammar Formalism Based

On Multigraph Description. Ph.D. thesis, Univer-
sität des Saarlandes. Available at http://www.
ps.uni-sb.de/˜rade/papers/diss.pdf.

Joost Engelfriet and Henrik Jan Hoogeboom. 2001.
MSO definable string transductions and two-way
finite-state transducers. ACM Transactions on Com-
putational Logic, 2:216–254.

Joost Engelfriet and Sebastian Maneth. 1999. Macro
tree transducers, attribute grammars, and MSO de-
finable tree translations. Information and Computa-
tion, 154:34–91.

Joost Engelfriet and Sebastian Maneth. 2003. Macro
tree translations of linear size increase are MSO de-
finable. SIAM Journal on Computing, 32:950–1006.

Zoltán Fülöp and Heiko Vogler. 1998. Syntax-Directed
Semantics: Formal Models Based on Tree Transduc-

ers. Springer.

Ferenc Gécseg and Magnus Steinby. 1997. Tree lan-
guages. In G. Rozenberg and A. Salomaa, editors,
Handbook of Formal Languages. Vol. 3: Beyond
Words, chapter 1, pages 1–68. Springer.

Jonathan Graehl, Kevin Knight, and Jonathan May.
2008. Training tree transducers. Computational
Linguistics, 34(3):391–427.

Ray Jackendoff. 2002. Foundations of Language:
Brain, Meaning, Grammar, Evolution. Oxford Uni-
versity Press, Oxford.

Kevin Knight and Jonathan Graehl. 2005. An
overview of probabilistic tree transducers for natural
language processing. In Alexander F. Gelbukh, edi-
tor, Proc. 6th Intl. Conf. on Computational Linguis-
tics and Intelligent Text Processing (CICLing 2005),
volume 3406 of Lecture Notes in Computer Science,
pages 1–24. Springer.

Jonathan May and Kevin Knight. 2006. Tiburon:
A weighted tree automata toolkit. In Oscar H.
Ibarra and Hsu-Chun Yen, editors, Proc. 11th Intl.
Conf. on Implementation and Application of Au-

tomata (CIAA 2006), volume 4094 of Lecture Notes
in Computer Science, pages 102–113. Springer.

Carl Pollard and Ivan Sag. 1994. Head-Driven Phrase
Structure Grammar. Chicago University Press.

Jerrold Sadock. 1991. Autolexical Syntax - A Theory
of Parallel Grammatical Representations. The Uni-
versity of Chicago Press, Chicago & London.

Petr Sgall, Eva Hajičová, and Jarmila Panevová. 1986.
The meaning of the sentence in its semantic and

pragmatic aspects. Reidel, Dordrecht.

Mark Steedman. 2000. The Syntactic Process (Lan-
guage, Speech, and Communication). MIT Press.

36


