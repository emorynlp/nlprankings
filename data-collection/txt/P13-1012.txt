



















































Decentralized Entity-Level Modeling for Coreference Resolution


Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 114–124,
Sofia, Bulgaria, August 4-9 2013. c©2013 Association for Computational Linguistics

Decentralized Entity-Level Modeling for Coreference Resolution

Greg Durrett, David Hall, and Dan Klein
Computer Science Division

University of California, Berkeley
{gdurrett,dlwh,klein}@cs.berkeley.edu

Abstract

Efficiently incorporating entity-level in-
formation is a challenge for coreference
resolution systems due to the difficulty of
exact inference over partitions. We de-
scribe an end-to-end discriminative prob-
abilistic model for coreference that, along
with standard pairwise features, enforces
structural agreement constraints between
specified properties of coreferent men-
tions. This model can be represented as
a factor graph for each document that ad-
mits efficient inference via belief propaga-
tion. We show that our method can use
entity-level information to outperform a
basic pairwise system.

1 Introduction

The inclusion of entity-level features has been a
driving force behind the development of many
coreference resolution systems (Luo et al., 2004;
Rahman and Ng, 2009; Haghighi and Klein, 2010;
Lee et al., 2011). There is no polynomial-time dy-
namic program for inference in a model with ar-
bitrary entity-level features, so systems that use
such features typically rely on making decisions
in a pipelined manner and sticking with them, op-
erating greedily in a left-to-right fashion (Rahman
and Ng, 2009) or in a multi-pass, sieve-like man-
ner (Raghunathan et al., 2010). However, such
systems may be locked into bad coreference deci-
sions and are difficult to directly optimize for stan-
dard evaluation metrics.

In this work, we present a new structured model
of entity-level information designed to allow effi-
cient inference. We use a log-linear model that can
be expressed as a factor graph. Pairwise features
appear in the model as unary factors, adjacent
to nodes representing a choice of antecedent (or
none) for each mention. Additional nodes model
entity-level properties on a per-mention basis, and

structural agreement factors softly drive properties
of coreferent mentions to agree with one another.
This is a key feature of our model: mentions man-
age their partial membership in various corefer-
ence chains, so that information about entity-level
properties is decentralized and propagated across
individual mentions, and we never need to explic-
itly instantiate entities.

Exact inference in this factor graph is in-
tractable, but efficient approximate inference can
be carried out with belief propagation. Our model
is the first discriminatively-trained model that both
makes joint decisions over an entire document and
models specific entity-level properties, rather than
simply enforcing transitivity of pairwise decisions
(Finkel and Manning, 2008; Song et al., 2012).

We evaluate our system on the dataset from
the CoNLL 2011 shared task using three differ-
ent types of properties: synthetic oracle proper-
ties, entity phi features (number, gender, animacy,
and NER type), and properties derived from un-
supervised clusters targeting semantic type infor-
mation. In all cases, our transitive model of en-
tity properties equals or outperforms our pairwise
system and our reimplementation of a previous
entity-level system (Rahman and Ng, 2009). Our
final system is competitive with the winner of the
CoNLL 2011 shared task (Lee et al., 2011).

2 Example

We begin with an example motivating our use of
entity-level features. Consider the following ex-
cerpt concerning two famous auction houses:

When looking for [art items], [people] go
to [Sotheby’s and Christie’s] because [they]A
believe [they]B can get the best price for
[them].

The first three mentions are all distinct entities,
theyA and theyB refer to people, and them refers to
art items. The three pronouns are tricky to resolve

114



automatically because they could at first glance re-
solve to any of the preceding mentions. We focus
in particular on the resolution of theyA and them.
In order to correctly resolve theyA to people rather
than Sotheby’s and Christie’s, we must take ad-
vantage of the fact that theyA appears as the sub-
ject of the verb believe, which is much more likely
to be attributed to people than to auction houses.

Binding principles prevent them from attaching
to theyB. But how do we prevent it from choos-
ing as its antecedent the next closest agreeing pro-
noun, theyA? One way is to exploit the correct
coreference decision we have already made, theyA
referring to people, since people are not as likely
to have a price as art items are. This observa-
tion argues for enforcing agreement of entity-level
semantic properties during inference, specifically
properties relating to permitted semantic roles.
Because even these six mentions have hundreds
of potential partitions into coreference chains, we
cannot search over partitions exhaustively, and
therefore we must design our model to be able to
use this information while still admitting an effi-
cient inference scheme.

3 Models

We will first present our BASIC model (Sec-
tion 3.1) and describe the features it incorporates
(Section 3.2), then explain how to extend it to use
transitive features (Sections 3.3 and 3.4).

Throughout this section, let x be a variable con-
taining the words in a document along with any
relevant precomputed annotation (such as parse in-
formation, semantic roles, etc.), and let n denote
the number of mentions in a given document.

3.1 BASIC Model
Our BASIC model is depicted in Figure 1 in stan-
dard factor graph notation. Each mention i has
an associated random variable ai taking values in
the set {1, . . . , i−1, <new>}; this variable spec-
ifies mention i’s selected antecedent or indicates
that it begins a new coreference chain. Let a =
(a1, ..., an) be the vector of the ai. Note that a set
of coreference chains C (the final desired output)
can be uniquely determined from a, but a is not
uniquely determined by C.

We use a log linear model of the conditional dis-
tribution P (a|x) as follows:

P (a|x) ∝ exp
(

n∑

i=1

wT fA(i, ai, x)

)

When looking for [art items], [people] go to [Sotheby's 
and Christie's] because [they]A believe [they]B can get 

the best price for [them].

art items 0.15

people 0.4

Sotheby’s and 
Christie’s 0.4

<new> 0.05

a2 a3 a4a1

A1 A2 A3 A4

art items 0.05

<new> 0.95

antecedent 
choices

antecedent 
factors

}
}

Figure 1: Our BASIC coreference model. A de-
cision ai is made independently for each men-
tion about what its antecedent mention should
be or whether it should start a new coreference
chain. Each unary factor Ai has a log-linear form
with features examining mention i, its selected an-
tecedent ai, and the document context x.

where fA(i, ai, x) is a feature function that exam-
ines the coreference decision ai for mention i with
document context x; note that this feature function
can include pairwise features based on mention i
and the chosen antecedent ai, since information
about each mention is contained in x.

Because the model factors completely over the
individual ai, these feature functions fA can be ex-
pressed as unary factors Ai (see Figure 1), with
Ai(j) ∝ exp

(
wT fA(i, j, x)

)
. Given a setting of

w, we can determine â = argmaxa P (a|x) and
then deterministically compute C(a), the final set
of coreference chains.

While the features of this model factor over
coreference links, this approach differs from clas-
sical pairwise systems such as Bengtson and Roth
(2008) or Stoyanov et al. (2010). Because poten-
tial antecedents compete with each other and with
the non-anaphoric hypothesis, the choice of ai ac-
tually represents a joint decision about i−1 pair-
wise links, as opposed to systems that use a pair-
wise binary classifier and a separate agglomera-
tion step, which consider one link at a time during
learning. This approach is similar to the mention-
ranking model of Rahman and Ng (2009).

3.2 Pairwise Features

We now present the set of features fA used by our
unary factors Ai. Each feature examines the an-

115



tecedent choice ai of the current mention as well
as the observed information x in the document.
For each of the features we present, two conjoined
versions are included: one with an indicator of the
type of the current mention being resolved, and
one with an indicator of the types of the current
and antecedent mentions. Mention types are either
NOMINAL, PROPER, or, if the mention is pronom-
inal, a canonicalized version of the pronoun ab-
stracting away case.1

Several features, especially those based on the
precise constructs (apposition, etc.) and those in-
corporating phi feature information, are computed
using the machinery in Lee et al. (2011). Other
features were inspired by Song et al. (2012) and
Rahman and Ng (2009).

Anaphoricity features: Indicator of anaphoric-
ity, indicator on definiteness.

Configurational features: Indicator on distance
in mentions (capped at 10), indicator on dis-
tance in sentences (capped at 10), does the an-
tecedent c-command the current mention, are the
two mentions in a subject/object construction, are
the mentions nested, are the mentions in determin-
istic appositive/role appositive/predicate nomina-
tive/relative pronoun constructions.

Match features: Is one mention an acronym of
the other, head match, head contained (each way),
string match, string contained (each way), relaxed
head match features from Lee et al. (2011).

Agreement features: Gender, number, ani-
macy, and NER type of the current mention and
the antecedent (separately and conjoined).

Discourse features: Speaker match conjoined
with an indicator of whether the document is an
article or conversation.

Because we use conjunctions of these base fea-
tures together with the antecedent and mention
type, our system can capture many relationships
that previous systems hand-coded, especially re-
garding pronouns. For example, our system has
access to features such as “it is non-anaphoric”,
“it has as its antecedent a geopolitical entity”, or
“I has as its antecedent I with the same speaker.”

1While this canonicalization could theoretically impair
our ability to resolve, for example, reflexive pronouns, con-
joining features with raw pronoun strings does not improve
performance.

We experimented with synonymy and hyper-
nymy features from WordNet (Miller, 1995), but
these did not empirically improve performance.

3.3 TRANSITIVE Model
The BASIC model can capture many relationships
between pairs of mentions, but cannot necessarily
capture entity-level properties like those discussed
in Section 2. We could of course model entities
directly (Luo et al., 2004; Rahman and Ng, 2009),
saying that each mention refers to some prior en-
tity rather than to some prior mention. However,
inference in this model would require reasoning
about all possible partitions of mentions, which is
computationally infeasible without resorting to se-
vere approximations like a left-to-right inference
method (Rahman and Ng, 2009).

Instead, we would like to try to preserve the
tractability of the BASIC model while still being
able to exploit entity-level information. To do so,
we will allow each mention to maintain its own
distributions over values for a number of proper-
ties; these properties could include gender, named-
entity type, or semantic class. Then, we will re-
quire each anaphoric mention to agree with its an-
tecedent on the value of each of these properties.

Our TRANSITIVE model which implements this
scheme is shown in Figure 2. Each mention i
has been augmented with a single property node
pi ∈ {1, ..., k}. The unary Pi factors encode prior
knowledge about the setting of each pi; these fac-
tors may be hard (I will not refer to a plural entity),
soft (such as a distribution over named entity types
output by an NER tagger), or practically uniform
(e.g. the last name Smith does not specify a partic-
ular gender).

To enforce agreement of a particular property,
we require a mention to have the same property
value as its antecedent. That is, for mentions i and
j, if ai = j, we want to ensure that pi and pj
agree. We can achieve this with the following set
of structural equality factors:

Ei−j(ai, pi, pj) = 1− I[ai = j ∧ pi 6= pj ]
In words, this factor is zero if both ai = j and
pi disagrees with pj . These equality factors es-
sentially provide a mechanism by which these pri-
ors Pi can influence the coreference decisions: if,
for example, the factors Pi and Pj disagree very
strongly, choosing ai 6= j will be preferred in or-
der to avoid forcing one of pi or pj to take an un-
desirable value. Moreover, note that although ai

116



E4-3

a2 a4

p4p3p2

E4-2

A2 A3 A4

P2 P3 P4

antecedent 
choices

antecedent 
factors

property 
factors

properties

equality 
factors

a3

}
}
}

}
}

people Sotheby's
and Christie's

they

Figure 2: The factor graph for our TRANSI-
TIVE coreference model. Each node ai now has
a property pi, which is informed by its own unary
factor Pi. In our example, a4 strongly indicates
that mentions 2 and 4 are coreferent; the factor
E4−2 then enforces equality between p2 and p4,
while the factor E4−3 has no effect.

only indicates a single antecedent, the transitive
nature of the E factors forces pi to agree with the
p nodes of all other mentions likely to be in the
same entity.

3.4 Property Projection

So far, our model as specified ensures agreement
of our entity-level properties, but strictly enforc-
ing agreement may not always be correct. Suppose
that we are using named entity type as an entity-
level property. Organizations and geo-political en-
tities are two frequently confused and ambiguous
tags, and in the gold-standard coreference chains
it may be the case that a single chain contains in-
stances of both. We might wish to learn that or-
ganizations and geo-political entities are “compat-
ible” in the sense that we should forgive entities
for containing both, but without losing the ability
to reject a chain containing both organizations and
people, for example.

To address these effects, we expand our model
as indicated in Figure 3. As before, we have a
set of properties pi and agreement factors Eij . On
top of that, we introduce the notion of raw prop-
erty values ri ∈ {1, ..., k} together with priors in
the form of the Ri factors. The ri and pi could in
principle have different domains, but for this work
we take them to have the same domain. The Pi
factors now have a new structure: they now rep-
resent a featurized projection of the ri onto the
pi, which can now be thought of as “coreference-

p4p3p2

r4r3r2

P2 P3 P4

R2 R3 R4
raw property 

factors

raw properties

projection 
factors

projected 
properties

}
}
}
}

a2 a4

A2 A3 A4

a3
E3-1 E4-1

Figure 3: The complete factor graph for our
TRANSITIVE coreference model. Compared to
Figure 2, the Ri contain the raw cluster posteriors,
and the Pi factors now project raw cluster values ri
into a set of “coreference-adapted” clusters pi that
are used as before. This projection allows men-
tions with different but compatible raw property
values to coexist in the same coreference chain.

adapted” properties. The Pi factors are defined by
Pi(pi, ri) ∝ exp(wT fP (pi, ri)), where fP is a fea-
ture vector over the projection of ri onto pi. While
there are many possible choices of fP , we choose
it to be an indicator of the values of pi and ri, so
that we learn a fully-parameterized projection ma-
trix.2 The Ri are constant factors, and may come
from an upstream model or some other source de-
pending on the property being modeled.

Our description thus far has assumed that we
are modeling only one type of property. In fact,
we can use multiple properties for each mention
by duplicating the r and p nodes and the R, P ,
and E factors across each desired property. We
index each of these by l ∈ {1, . . . ,m} for each of
m properties.

The final log-linear model is given by the fol-
lowing formula:

P (a|x) ∝
∑

p,r




∏

i,j,l

El,i−j(ai, pli, plj)




∏

i,l

Rli(rli)




exp

(
wT

∑

i

(
fA(i, ai, x) +

∑

l

fP (pli, rli)

))]

where i and j range over mentions, l ranges over
2Initialized to zero (or small values), this matrix actually

causes the transitive machinery to have no effect, since all
posteriors over the pi are flat and completely uninformative.
Therefore, we regularize the weights of the indicators of pi =
ri towards 1 and all other features towards 0 to give each raw
cluster a preference for a distinct projected cluster.

117



each of m properties, and the outer sum indicates
marginalization over all p and r variables.

4 Learning

Now that we have defined our model, we must
decide how to train its weights w. The first
issue to address is one of the supervision pro-
vided. Our model traffics in sets of labels a
which are more specified than gold coreference
chains C, which give cluster membership for each
mention but not antecedence. Let A(C) be the
set of labelings a that are consistent with a set
of coreference chains C. For example, if C =
{{1, 2, 3}, {4}}, then (<new>, 1, 2, <new>) ∈
A(C) and (<new>, 1, 1, <new>) ∈ A(C) but
(<new>, 1, <new>, 3) /∈ A(C), since this im-
plies the chains C = {{1, 2}, {3, 4}}

The most natural objective is a variant of
standard conditional log-likelihood that treats the
choice of a for the specified C as a latent variable
to be marginalized out:

`(w) =
t∑

i=1

log


 ∑

a∈A(Ci)
P (a|xi)


 (1)

where (xi, Ci) is the ith labeled training example.
This optimizes for the 0-1 loss; however, we are
much more interested in optimizing with respect
to a coreference-specific loss function.

To this end, we will use softmax-margin (Gim-
pel and Smith, 2010), which augments the proba-
bility of each example with a term proportional to
its loss, pushing the model to assign less mass to
highly incorrect examples. We modify Equation 1
to use a new probability distribution P ′ instead
of P , where P ′(a|xi) ∝ P (a|xi) exp (l(a,C))
and l(a,C) is a loss function. In order to
perform inference efficiently, l(a,C) must de-
compose linearly across mentions: l(a,C) =∑n

i=1 l(ai, C). Commonly-used coreference met-
rics such as MUC (Vilain et al., 1995) and B3

(Bagga and Baldwin, 1998) do not have this prop-
erty, so we instead make use of a parameterized
loss function that does and fit the parameters to
give good performance. Specifically, we take

l(a,C) =

n∑

i=1

[c1I(K1(ai, C)) + c2I(K2(ai, C))

+ c3I(K3(ai, C))]

where c1, c2, and c3 are real-valued weights, K1
denotes the event that ai is falsely anaphoric when

it should be non-anaphoric, K2 denotes the event
that ai is falsely non-anaphoric when it should be
anaphoric, and K3 denotes the event that ai is cor-
rectly determined to be anaphoric but . These can
be computed based on only ai and C. By setting
c1 low and c2 high relative to c3, we can force
the system to be less conservative about making
anaphoricity decisions and achieve a better bal-
ance with the final coreference metrics.

Finally, we incorporate L1 regularization, giv-
ing us our final objective:

`(w) =
t∑

i=1

log


 ∑

a∈A(Ci)
P ′(a|xi)


+ λ‖w‖1

We optimize this objective using AdaGrad
(Duchi et al., 2011); we found this to be faster and
give higher performance than L-BFGS using L2
regularization (Liu and Nocedal, 1989). Note that
because of the marginalization over A(Ci), even
the objective for the BASIC model is not convex.

5 Inference

Inference in the BASIC model is straightforward.
Given a set of weights w, we can predict

â = argmax
a

P (a|x)

We then report the corresponding chains C(a)
as the system output.3 For learning, the gradi-
ent takes the standard form of the gradient of a
log-linear model, a difference of expected feature
counts under the gold annotation and under no
annotation. This requires computing marginals
P ′(ai|x) for each mention i, but because the
model already factors this way, this step is easy.

The TRANSITIVE model is more complex. Ex-
act inference is intractable due to theE factors that
couple all of the ai by way of the pi nodes. How-
ever, we can compute approximate marginals for
the ai, pi, and ri using belief propagation. BP has
been effectively used on other NLP tasks (Smith
and Eisner, 2008; Burkett and Klein, 2012), and is
effective in cases such as this where the model is
largely driven by non-loopy factors (here, the Ai).

From marginals over each node, we can com-
pute the necessary gradient and decode as before:

â = argmax
a

P̂ (a|x)

3One could use ILP-based decoding in the style of Finkel
and Manning (2008) and Song et al. (2012) to attempt to ex-
plicitly find the optimal C with choice of a marginalized out,
but we did not explore this option.

118



This corresponds to minimum-risk decoding with
respect to the Hamming loss over antecedence pre-
dictions.

Pruning. The TRANSITIVE model requires in-
stantiating a factor for each potential setting of
each ai. This factor graph grows quadratically in
the size of the document, and even approximate in-
ference becomes slow when a document contains
over 200 mentions. Therefore, we use our BA-
SIC model to prune antecedent choices for each
ai in order to reduce the size of the factor graph
that we must instantiate. Specifically, we prune
links between pairs of mentions that are of men-
tion distance more than 100, as well as values for
ai that fall below a particular odds ratio threshold
with respect to the best setting of that ai in the
BASIC model; that is, those for which

log

(
PBASIC (ai|x)

maxj PBASIC (ai = j|x)

)

is below a cutoff γ.

6 Related Work

Our BASIC model is a mention-ranking approach
resembling models used by Denis and Baldridge
(2008) and Rahman and Ng (2009), though it is
trained using a novel parameterized loss function.
It is also similar to the MLN-JOINT(BF) model
of Song et al. (2012), but we enforce the single-
parent constraint at a deeper structural level, al-
lowing us to treat non-anaphoricity symmetrically
with coreference as in Denis and Baldridge (2007)
and Stoyanov and Eisner (2012). The model of
Fernandes et al. (2012) also uses the single-parent
constraint structurally, but with learning via la-
tent perceptron and ILP-based one-best decod-
ing rather than logistic regression and BP-based
marginal computation.

Our TRANSITIVE model is novel; while Mc-
Callum and Wellner (2004) proposed the idea of
using attributes for mentions, they do not actu-
ally implement a model that does so. Other sys-
tems include entity-level information via hand-
written rules (Raghunathan et al., 2010), induced
rules (Yang et al., 2008), or features with learned
weights (Luo et al., 2004; Rahman and Ng, 2011),
but all of these systems freeze past coreference de-
cisions in order to compute their entities.

Most similar to our entity-level approach is
the system of Haghighi and Klein (2010), which

also uses approximate global inference; however,
theirs is an unsupervised, generative system and
they attempt to directly model multinomials over
words in each mention. Their system could be ex-
tended to handle property information like we do,
but our system has many other advantages, such as
freedom from a pre-specified list of entity types,
the ability to use multiple input clusterings, and
discriminative projection of clusters.

7 Experiments

We use the datasets, experimental setup, and scor-
ing program from the CoNLL 2011 shared task
(Pradhan et al., 2011), based on the OntoNotes
corpus (Hovy et al., 2006). We use the standard
automatic parses and NER tags for each docu-
ment. Our mentions are those output by the sys-
tem of Lee et al. (2011); we also use their postpro-
cessing to remove appositives, predicate nomina-
tives, and singletons before evaluation. For each
experiment, we report MUC (Vilain et al., 1995),
B3 (Bagga and Baldwin, 1998), and CEAFe (Luo,
2005), as well as their average.

Parameter settings. We take the regularization
constant λ = 0.001 and the parameters of our
surrogate loss (c1, c2, c3) = (0.15, 2.5, 1) for all
models.4 All models are trained for 20 iterations.
We take the pruning threshold γ = −2.

7.1 Systems
Besides our BASIC and TRANSITIVE systems, we
evaluate a strictly pairwise system that incorpo-
rates property information by way of indicator fea-
tures on the current mention’s most likely property
value and the proposed antecedent’s most likely
property value. We call this system PAIRPROP-
ERTY; it is simply the BASIC system with an ex-
panded feature set.

Furthermore, we compare against a LEFT-
TORIGHT entity-level system like that of Rahman
and Ng (2009).5 Decoding now operates in a se-
quential fashion, with BASIC features computed
as before and entity features computed for each
mention based on the coreference decisions made
thus far. Following Rahman and Ng (2009), fea-
tures for each property indicate whether the cur-

4Additional tuning of these hyper parameters did not sig-
nificantly improve any of the models under any of the exper-
imental conditions.

5Unfortunately, their publicly-available system is closed-
source and performs poorly on the CoNLL shared task
dataset, so direct comparison is difficult.

119



rent mention agrees with no mentions in the an-
tecedent cluster, at least one mention, over half of
the mentions, or all of the mentions; antecedent
clusters of size 1 or 2 fire special-cased features.
These additional features beyond those in Rah-
man and Ng (2009) were helpful, but more in-
volved conjunction schemes and fine-grained fea-
tures were not. During training, entity features of
both the gold and the prediction are computed us-
ing the Viterbi clustering of preceding mentions
under the current model parameters.6

All systems are run in a two-pass manner:
first, the BASIC model is run, then antecedent
choices are pruned, then our second-round model
is trained from scratch on the pruned data.7

7.2 Noisy Oracle Features
We first evaluate our model’s ability to exploit syn-
thetic entity-level properties. For this experiment,
mention properties are derived from corrupted or-
acle information about the true underlying corefer-
ence cluster. Each coreference cluster is assumed
to have one underlying value for each of m coref-
erence properties, each taking values over a do-
main D. Mentions then sample distributions over
D from a Dirichlet distribution peaked around the
true underlying value.8 These posteriors are taken
as the Ri for the TRANSITIVE model.

We choose this setup to reflect two important
properties of entity-level information: first, that it
may come from a variety of disparate sources, and
second, that it may be based on the determinations
of upstream models which produce posteriors nat-
urally. A strength of our model is that it can accept
such posteriors as input, naturally making use of
this information in a model-based way.

Table 1 shows development results averaged
across ten train-test splits with m = 3 proper-
ties, each taking one of |D| = 5 values. We em-
phasize that these parameter settings give fairly
weak oracle information: a document may have
hundreds of clusters, so even in the absence of
noise these oracle properties do not have high dis-

6Using gold entities for training as in Rahman and Ng
(2009) resulted in a lower-performing system.

7We even do this for the BASIC model, since we found
that performance of the pruned and retrained model was gen-
erally higher.

8Specifically, the distribution used is a Dirichlet with
α = 3.5 for the true underlying cluster and α = 1 for other
values, chosen so that 25% of samples from the distribution
did not have the correct mode. Though these parameters af-
fect the quality of the oracle information, varying them did
not change the relative performance of the different models.

NOISY ORACLE
MUC B3 CEAFe Avg.

BASIC 61.96 70.66 47.30 59.97
PAIRPROPERTY 66.31 72.68 49.08 62.69
LEFTTORIGHT 66.49 73.14 49.46 63.03

TRANSITIVE 67.37 74.05 49.68 63.70

Table 1: CoNLL metric scores for our four dif-
ferent systems incorporating noisy oracle data.
This information helps substantially in all cases.
Both entity-level models outperform the PAIR-
PROPERTY model, but we observe that the TRAN-
SITIVE model is more effective than the LEFT-
TORIGHT model at using this information.

criminating power. Still, we see that all mod-
els are able to benefit from incorporating this in-
formation; however, our TRANSITIVE model out-
performs both the PAIRPROPERTY model and the
LEFTTORIGHT model. There are a few reasons
for this: first, our model is able to directly use soft
posteriors, so it is able to exploit the fact that more
peaked samples from the Dirichlet are more likely
to be correct. Moreover, our model can propagate
information backwards in a document as well as
forwards, so the effects of noise can be more eas-
ily mitigated. By contrast, in the LEFTTORIGHT
model, if the first or second mention in a cluster
has the wrong property value, features indicating
high levels of property agreement will not fire on
the next few mentions in those clusters.

7.3 Phi Features

As we have seen, our TRANSITIVE model can ex-
ploit high-quality entity-level features. How does
it perform using real features that have been pro-
posed for entity-level coreference?

Here, we use hard phi feature determinations
extracted from the system of Lee et al. (2011).
Named-entity type and animacy are both com-
puted based on the output of a named-entity tag-
ger, while number and gender use the dataset of
Bergsma and Lin (2006). Once this informa-
tion is determined, the PAIRPROPERTY and LEFT-
TORIGHT systems can compute features over it di-
rectly. In the TRANSITIVE model, each of the Ri
factors places 34 of its mass on the determined la-
bel and distributes the remainder uniformly among
the possible options.

Table 2 shows results when adding entity-level
phi features on top of our BASIC pairwise system
(which already contains pairwise features) and on
top of an ablated BASIC system without pairwise

120



PHI FEATURES
MUC B3 CEAFe Avg.

BASIC 61.96 70.66 47.30 59.97
LEFTTORIGHT 61.34 70.41 47.64 59.80

TRANSITIVE 62.66 70.92 46.88 60.16
PHI FEATURES (ABLATED BASIC)

BASIC-PHI 59.45 69.21 46.02 58.23
PAIRPROPERTY 61.88 70.66 47.14 59.90
LEFTTORIGHT 61.42 70.53 47.49 59.81

TRANSITIVE 62.23 70.78 46.74 59.92

Table 2: CoNLL metric scores for our systems in-
corporating phi features. Our standard BASIC sys-
tem already includes phi features, so no results are
reported for PAIRPROPERTY. Here, our TRAN-
SITIVE system does not give substantial improve-
ment on the averaged metric. Over a baseline
which does not include phi features, all systems
are able to incorporate them comparably.

phi features. Our entity-level systems successfully
captures phi features when they are not present in
the baseline, but there is only slight benefit over
pairwise incorporation, a result which has been
noted previously (Luo et al., 2004).

7.4 Clustering Features

Finally, we consider mention properties derived
from unsupervised clusterings; these properties
are designed to target semantic properties of nom-
inals that should behave more like the oracle fea-
tures than the phi features do.

We consider clusterings that take as input pairs
(n, r) of a noun head n and a string r which con-
tains the semantic role of n (or some approxima-
tion thereof) conjoined with its governor. Two dif-
ferent algorithms are used to cluster these pairs: a
NAIVEBAYES model, where c generates n and r,
and a CONDITIONAL model, where c is generated
conditioned on r and then n is generated from c.
Parameters for each can be learned with the ex-
pectation maximization (EM) algorithm (Demp-
ster et al., 1977), with symmetry broken by a small
amount of random noise at initialization.

Similar models have been used to learn sub-
categorization information (Rooth et al., 1999)
or properties of verb argument slots (Yao et al.,
2011). We choose this kind of clustering for its rel-
ative simplicity and because it allows pronouns to
have more informed properties (from their verbal
context) than would be possible using a model that
makes type-level decisions about nominals only.
Though these specific cluster features are novel
to coreference, previous work has used similar

CLUSTERS
MUC B3 CEAFe Avg.

BASIC 61.96 70.66 47.30 59.97
PAIRPROPERTY 62.88 70.71 47.45 60.35
LEFTTORIGHT 61.98 70.19 45.77 59.31

TRANSITIVE 63.34 70.89 46.88 60.37

Table 3: CoNLL metric scores for our systems
incorporating clustering features. These features
are equally effectively incorporated by our PAIR-
PROPERTY system and our TRANSITIVE system.

government
officials
court

authorities

ARG0:said
ARG0:say
ARG0:found
ARG0:announced

prices
shares
index
rates

ARG1:rose
ARG1:fell
ARG1:cut
ARG1:closed

way
law

agreement
plan

ARG1:signed
ARG1:announced
ARG1:set
ARG1:approved

attack
problems
attacks
charges

ARG1:cause
ARG2:following
ARG1:reported
ARG1:filed... ...

... ...

... ...

... ... ...

Figure 4: Examples of clusters produced by the
NAIVEBAYES model on SRL-tagged data with
pronouns discarded.

types of fine-grained semantic class information
(Hendrickx and Daelemans, 2007; Ng, 2007; Rah-
man and Ng, 2010). Other approaches incorpo-
rate information from other sources (Ponzetto and
Strube, 2006) or compute heuristic scores for real-
valued features based on a large corpus or the web
(Dagan and Itai, 1990; Yang et al., 2005; Bansal
and Klein, 2012).

We use four different clusterings in our
experiments, each with twenty clusters:
dependency-parse-derived NAIVEBAYES clusters,
semantic-role-derived CONDITIONAL clusters,
SRL-derived NAIVEBAYES clusters generating
a NOVERB token when r cannot be determined,
and SRL-derived NAIVEBAYES clusters with all
pronoun tuples discarded. Examples of the latter
clusters are shown in Figure 4. Each clustering
is learned for 30 iterations of EM over English
Gigaword (Graff et al., 2007), parsed with the
Berkeley Parser (Petrov et al., 2006) and with
SRL determined by Senna (Collobert et al., 2011).

Table 3 shows results of modeling these cluster
properties. As in the case of oracle features, the
PAIRPROPERTY and LEFTTORIGHT systems use
the modes of the cluster posteriors, and the TRAN-
SITIVE system uses the posteriors directly as the
Ri. We see comparable performance from incor-
porating features in both an entity-level framework
and a pairwise framework, though the TRANSI-

121



MUC B3 CEAFe Avg.
Prec. Rec. F1 Prec. Rec. F1 Prec. Rec. F1 F1

BASIC 69.99 55.59 61.96 80.96 62.69 70.66 41.37 55.21 47.30 59.97
STANFORD 61.49 59.59 60.49 74.60 68.25 71.28 47.57 49.45 48.49 60.10

NOISY ORACLE
PAIRPROPERTY 76.49 58.53 66.31 84.98 63.48 72.68 41.84 59.36 49.08 62.69
LEFTTORIGHT 76.92 58.55 66.49 85.68 63.81 73.14 42.07 60.01 49.46 63.03

TRANSITIVE 76.48 60.20 *67.37 84.84 65.69 *74.05 42.89 59.01 *49.68 63.70
PHI FEATURES

LEFTTORIGHT 69.77 54.73 61.34 81.40 62.04 70.41 41.49 55.92 47.64 59.80
TRANSITIVE 70.27 56.54 *62.66 79.81 63.82 *70.92 41.17 54.44 46.88 60.16

PHI FEATURES (ABLATED BASIC)
BASIC-PHI 67.04 53.41 59.45 78.93 61.63 69.21 40.40 53.46 46.02 58.23

PAIRPROPERTY 70.24 55.31 61.88 81.10 62.60 70.66 41.04 55.38 47.14 59.90
LEFTTORIGHT 69.94 54.75 61.42 81.38 62.23 70.53 41.29 55.87 47.49 59.81

TRANSITIVE 70.06 55.98 *62.23 79.92 63.52 70.78 40.90 54.52 46.74 59.92
CLUSTERS

PAIRPROPERTY 71.77 55.95 62.88 81.76 62.30 70.71 40.98 56.35 47.45 60.35
LEFTTORIGHT 69.75 54.82 61.39 81.48 62.29 70.60 41.62 55.89 47.71 59.90

TRANSITIVE 71.54 56.83 *63.34 80.55 63.31 *70.89 40.77 55.14 46.88 60.37

Table 4: CoNLL metric scores averaged across ten different splits of the training set for each experiment.
We include precision, recall, and F1 for each metric for completeness. Starred F1 values on the individual
metrics for the TRANSITIVE system are significantly better than all other results in the same block at the
p = 0.01 level according to a bootstrap resampling test.

MUC B3 CEAFe Avg.
Prec. Rec. F1 Prec. Rec. F1 Prec. Rec. F1 F1

BASIC 68.84 56.08 61.81 77.60 61.40 68.56 38.25 50.57 43.55 57.97
PAIRPROPERTY 70.90 56.26 62.73 78.95 60.79 68.69 37.69 51.92 43.67 58.37
LEFTTORIGHT 68.84 55.56 61.49 78.64 61.03 68.72 38.97 51.74 44.46 58.22

TRANSITIVE 70.62 58.06 *63.73 76.93 62.24 68.81 38.00 50.40 43.33 58.62
STANFORD 60.91 62.13 61.51 70.61 67.75 69.15 45.79 44.55 45.16 58.61

Table 5: CoNLL metric scores for our best systems (including clustering features) on the CoNLL blind
test set, reported in the same manner as Table 4.

TIVE system appears to be more effective than the
LEFTTORIGHT system.

7.5 Final Results
Table 4 shows expanded results on our develop-
ment sets for the different types of entity-level
information we considered. We also show in in
Table 5 the results of our system on the CoNLL
test set, and see that it performs comparably to
the Stanford coreference system (Lee et al., 2011).
Here, our TRANSITIVE system provides modest
improvements over all our other systems.

Based on Table 4, our TRANSITIVE system ap-
pears to do better on MUC andB3 than on CEAFe.
However, we found no simple way to change the
relative performance characteristics of our various
systems; notably, modifying the parameters of the
loss function mentioned in Section 4 or changing
it entirely did not trade off these three metrics but
merely increased or decreased them in lockstep.
Therefore, the TRANSITIVE system actually sub-
stantially improves over our baselines and is not

merely trading off metrics in a way that could be
easily reproduced through other means.

8 Conclusion

In this work, we presented a novel coreference ar-
chitecture that can both take advantage of standard
pairwise features as well as use transitivity to en-
force coherence of decentralized entity-level prop-
erties within coreference clusters. Our transitive
system is more effective at using properties than
a pairwise system and a previous entity-level sys-
tem, and it achieves performance comparable to
that of the Stanford coreference resolution system,
the winner of the CoNLL 2011 shared task.

Acknowledgments

This work was partially supported by BBN under
DARPA contract HR0011-12-C-0014, by an NSF
fellowship for the first author, and by a Google fel-
lowship for the second. Thanks to the anonymous
reviewers for their insightful comments.

122



References
Amit Bagga and Breck Baldwin. 1998. Algorithms for

Scoring Coreference Chains. In Proceedings of the
Conference on Language Resources and Evaluation
Workshop on Linguistics Coreference.

Mohit Bansal and Dan Klein. 2012. Coreference Se-
mantics from Web Features. In Proceedings of the
Association for Computational Linguistics.

Eric Bengtson and Dan Roth. 2008. Understanding
the Value of Features for Coreference Resolution. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing.

Shane Bergsma and Dekang Lin. 2006. Bootstrap-
ping Path-Based Pronoun Resolution. In Proceed-
ings of the Conference on Computational Linguistics
and the Association for Computational Linguistics.

David Burkett and Dan Klein. 2012. Fast Inference in
Phrase Extraction Models with Belief Propagation.
In Proceedings of the North American Chapter of
the Association for Computational Linguistics.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural Language Processing (Almost) from
Scratch. Journal of Machine Learning Research,
12:2493–2537, November.

Ido Dagan and Alon Itai. 1990. Automatic Process-
ing of Large Corpora for the Resolution of Anaphora
References. In Proceedings of the Conference on
Computational Linguistics - Volume 3.

Arthur P. Dempster, Nan M. Laird, and Donald B. Ru-
bin. 1977. Maximum Likelihood from Incomplete
Data via the EM Algorithm. Journal of the Royal
Statistical Society, Series B, 39(1):1–38.

Pascal Denis and Jason Baldridge. 2007. Joint Deter-
mination of Anaphoricity and Coreference Resolu-
tion using Integer Programming. In Proceedings of
the North American Chapter of the Association for
Computational Linguistics.

Pascal Denis and Jason Baldridge. 2008. Specialized
Models and Ranking for Coreference Resolution. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive Subgradient Methods for Online Learning
and Stochastic Optimization. Journal of Machine
Learning Research, 12:2121–2159, July.

Eraldo Rezende Fernandes, Cı́cero Nogueira dos San-
tos, and Ruy Luiz Milidiú. 2012. Latent Structure
Perceptron with Feature Induction for Unrestricted
Coreference Resolution. In Proceedings of the Joint
Conference on Empirical Methods in Natural Lan-
guage Proceedings and Conference on Computa-
tional Natural Language Learning - Shared Task.

Jenny Rose Finkel and Christopher D. Manning. 2008.
Enforcing Transitivity in Coreference Resolution.
In Proceedings of the Association for Computational
Linguistics: Short Papers.

Kevin Gimpel and Noah A. Smith. 2010. Softmax-
Margin CRFs: Training Log-Linear Models with
Cost Functions. In Proceedings of the North Amer-
ican Chapter for the Association for Computational
Linguistics.

David Graff, Junbo Kong, Ke Chen, and Kazuaki
Maeda. 2007. English Gigaword Third Edi-
tion. Linguistic Data Consortium, Catalog Number
LDC2007T07.

Aria Haghighi and Dan Klein. 2010. Coreference Res-
olution in a Modular, Entity-Centered Model. In
Proceedings of the North American Chapter of the
Association for Computational Linguistics.

Iris Hendrickx and Walter Daelemans, 2007. Adding
Semantic Information: Unsupervised Clusters for
Coreference Resolution.

Eduard Hovy, Mitchell Marcus, Martha Palmer,
Lance Ramshaw, and Ralph Weischedel. 2006.
OntoNotes: the 90% solution. In Proceedings of
the North American Chapter of the Association for
Computational Linguistics: Short Papers.

Heeyoung Lee, Yves Peirsman, Angel Chang,
Nathanael Chambers, Mihai Surdeanu, and Dan Ju-
rafsky. 2011. Stanford’s Multi-Pass Sieve Corefer-
ence Resolution System at the CoNLL-2011 Shared
Task. In Proceedings of the Conference on Compu-
tational Natural Language Learning: Shared Task.

Dong C. Liu and Jorge Nocedal. 1989. On the Limited
Memory BFGS Method for Large Scale Optimiza-
tion. Mathematical Programming, 45(3):503–528,
December.

Xiaoqiang Luo, Abe Ittycheriah, Hongyan Jing, Nanda
Kambhatla, and Salim Roukos. 2004. A
Mention-Synchronous Coreference Resolution Al-
gorithm Based on the Bell Tree. In Proceedings of
the Association for Computational Linguistics.

Xiaoqiang Luo. 2005. On Coreference Resolution
Performance Metrics. In Proceedings of the Con-
ference on Empirical Methods in Natural Language
Processing.

Andrew McCallum and Ben Wellner. 2004. Condi-
tional Models of Identity Uncertainty with Applica-
tion to Noun Coreference. In Proceedings of Ad-
vances in Neural Information Processing Systems.

George A. Miller. 1995. WordNet: A Lexical
Database for English. Communications of the ACM,
38:39–41.

Vincent Ng. 2007. Semantic class induction and coref-
erence resolution. In Proceedings of the Association
for Computational Linguistics.

123



Slav Petrov, Leon Barrett, Romain Thibaux, and Dan
Klein. 2006. Learning Accurate, Compact, and In-
terpretable Tree Annotation. In Proceedings of the
Conference on Computational Linguistics and the
Association for Computational Linguistics.

Simone Paolo Ponzetto and Michael Strube. 2006.
Exploiting Semantic Role Labeling, WordNet and
Wikipedia for Coreference Resolution. In Proceed-
ings of the North American Chapter of the Associa-
tion of Computational Linguistics.

Sameer Pradhan, Lance Ramshaw, Mitchell Marcus,
Martha Palmer, Ralph Weischedel, and Nianwen
Xue. 2011. CoNLL-2011 Shared Task: Modeling
Unrestricted Coreference in OntoNotes. In Proceed-
ings of the Conference on Computational Natural
Language Learning: Shared Task.

Karthik Raghunathan, Heeyoung Lee, Sudarshan Ran-
garajan, Nathanael Chambers, Mihai Surdeanu, Dan
Jurafsky, and Christopher Manning. 2010. A Multi-
Pass Sieve for Coreference Resolution. In Proceed-
ings of the Conference on Empirical Methods in Nat-
ural Language Processing.

Altaf Rahman and Vincent Ng. 2009. Supervised
Models for Coreference Resolution. In Proceedings
of the Conference on Empirical Methods in Natural
Language Processing.

Altaf Rahman and Vincent Ng. 2010. Inducing Fine-
Grained Semantic Classes via Hierarchical and Col-
lective Classification. In Proceedings of the Interna-
tional Conference on Computational Linguistics.

Altaf Rahman and Vincent Ng. 2011. Narrowing
the Modeling Gap: A Cluster-Ranking Approach to
Coreference Resolution. Journal of Artificial Intel-
ligence Research, 40(1):469–521, January.

Mats Rooth, Stefan Riezler, Detlef Prescher, Glenn
Carroll, and Franz Beil. 1999. Inducing a Semanti-
cally Annotated Lexicon via EM-Based Clustering.
In Proceedings of the Association for Computational
Linguistics.

David A. Smith and Jason Eisner. 2008. Dependency
Parsing by Belief Propagation. In Proceedings of the
Conference on Empirical Methods in Natural Lan-
guage Processing.

Yang Song, Jing Jiang, Wayne Xin Zhao, Sujian Li, and
Houfeng Wang. 2012. Joint Learning for Corefer-
ence Resolution with Markov Logic. In Proceedings
of the Conference on Empirical Methods in Natural
Language Processing.

Veselin Stoyanov and Jason Eisner. 2012. Easy-first
Coreference Resolution. In Proceedings of the In-
ternational Conference on Computational Linguis-
tics.

Veselin Stoyanov, Claire Cardie, Nathan Gilbert, Ellen
Riloff, David Buttler, and David Hysom. 2010.

Coreference Resolution with Reconcile. In Pro-
ceedings of the Association for Computational Lin-
guistics: Short Papers.

Marc Vilain, John Burger, John Aberdeen, Dennis Con-
nolly, and Lynette Hirschman. 1995. A Model-
Theoretic Coreference Scoring Scheme. In Pro-
ceedings of the Conference on Message Understand-
ing.

Xiaofeng Yang, Jian Su, and Chew Lim Tan. 2005. Im-
proving Pronoun Resolution Using Statistics-Based
Semantic Compatibility Information. In Proceed-
ings of the Association for Computational Linguis-
tics.

Xiaofeng Yang, Jian Su, Jun Lang, Chew L. Tan, Ting
Liu, and Sheng Li. 2008. An Entity-Mention Model
for Coreference Resolution with Inductive Logic
Programming. In Proceedings of the Association for
Computational Linguistics.

Limin Yao, Aria Haghighi, Sebastian Riedel, and An-
drew McCallum. 2011. Structured Relation Discov-
ery Using Generative Models. In Proceedings of the
Conference on Empirical Methods in Natural Lan-
guage Processing.

124


