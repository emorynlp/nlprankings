



















































Unsupervised Dependency Parsing: Let's Use Supervised Parsers


Human Language Technologies: The 2015 Annual Conference of the North American Chapter of the ACL, pages 651–661,
Denver, Colorado, May 31 – June 5, 2015. c©2015 Association for Computational Linguistics

Unsupervised Dependency Parsing: Let’s Use Supervised Parsers

Phong Le and Willem Zuidema
Institute for Logic, Language, and Computation

University of Amsterdam, the Netherlands
{p.le,zuidema}@uva.nl

Abstract

We present a self-training approach to unsu-
pervised dependency parsing that reuses exist-
ing supervised and unsupervised parsing algo-
rithms. Our approach, called ‘iterated rerank-
ing’ (IR), starts with dependency trees gener-
ated by an unsupervised parser, and iteratively
improves these trees using the richer proba-
bility models used in supervised parsing that
are in turn trained on these trees. Our system
achieves 1.8% accuracy higher than the state-
of-the-part parser of Spitkovsky et al. (2013)
on the WSJ corpus.

1 Introduction

Unsupervised dependency parsing and its super-
vised counterpart have many characteristics in com-
mon: they take as input raw sentences, produce
dependency structures as output, and often use the
same evaluation metric (DDA, or UAS, the percent-
age of tokens for which the system predicts the cor-
rect head). Unsurprisingly, there has been much
more research on supervised parsing – producing a
wealth of models, datasets and training techniques
– than on unsupervised parsing, which is more dif-
ficult, much less accurate and generally uses very
simple probability models. Surprisingly, however,
there have been no reported attempts to reuse super-
vised approaches to tackle the unsupervised parsing
problem (an idea briefly mentioned in Spitkovsky et
al. (2010b)).

There are, nevertheless, two aspects of supervised
parsers that we would like to exploit in an unsuper-
vised setting. First, we can increase the model ex-

pressiveness in order to capture more linguistic reg-
ularities. Many recent supervised parsers use third-
order (or higher order) features (Koo and Collins,
2010; Martins et al., 2013; Le and Zuidema, 2014)
to reach state-of-the-art (SOTA) performance. In
contrast, existing models for unsupervised parsing
limit themselves to using simple features (e.g., con-
ditioning on heads and valency variables) in order
to reduce the computational cost, to identify consis-
tent patterns in data (Naseem, 2014, page 23), and
to avoid overfitting (Blunsom and Cohn, 2010). Al-
though this makes learning easier and more efficient,
the disadvantage is that many useful linguistic regu-
larities are missed: an upper bound on the perfor-
mance of such simple models – estimated by us-
ing annotated data – is 76.3% on the WSJ corpus
(Spitkovsky et al., 2013), compared to over 93% ac-
tual performance of the SOTA supervised parsers.

Second, we would like to make use of informa-
tion available from lexical semantics, as in Bansal
et al. (2014), Le and Zuidema (2014), and Chen and
Manning (2014). Lexical semantics is a source for
handling rare words and syntactic ambiguities. For
instance, if a parser can identify that “he” is a depen-
dent of “walks” in the sentence “He walks”, then,
even if “she” and “runs” do not appear in the train-
ing data, the parser may still be able to recognize
that “she” should be a dependent of “runs” in the
sentence “she runs”. Similarly, a parser can make
use of the fact that “sauce” and “John” have very
different meanings to decide that they have different
heads in the two phrases “ate spaghetti with sauce”
and “ate spaghetti with John”.

However, applying existing supervised parsing

651



techniques to the task of unsupervised parsing is,
unfortunately, not trivial. The reason is that those
parsers are optimally designed for being trained on
manually annotated data. If we use existing unsuper-
vised training methods (like EM), learning could be
easily misled by a large amount of ambiguity natu-
rally embedded in unannotated training data. More-
over, the computational cost could rapidly increase
if the training algorithm is not designed properly.
To overcome these difficulties we propose a frame-
work, iterated reranking (IR), where existing super-
vised parsers are trained without the need of manu-
ally annotated data, starting with dependency trees
provided by an existing unsupervised parser as ini-
tialiser. Using this framework, we can employ the
work of Le and Zuidema (2014) to build a new sys-
tem that outperforms the SOTA unsupervised parser
of Spitkovsky et al. (2013) on the WSJ corpus.

The contribution of this paper is twofold. First,
we show the benefit of using lexical semantics for
the unsupervised parsing task. Second, our work is
a bridge connecting the two research areas unsuper-
vised parsing and its supervised counterpart. Before
going to the next section, in order to avoid confusion
introduced by names, it is worth noting that we use
un-trained existing supervised parsers which will be
trained on automatically annotated treebanks.

2 Related Work

2.1 Unsupervised Dependency Parsing

The first breakthrough was set by Klein and Man-
ning (2004) with their dependency model with va-
lence (DMV), the first model to outperform the
right-branching baseline on the DDA metric: 43.2%
vs 33.6% on sentences up to length 10 in the WSJ
corpus. Nine years later, Spitkovsky et al. (2013)
achieved much higher DDAs: 72.0% on sentences
up to length 10, and 64.4% on all sentences in sec-
tion 23. During this period, many approaches have
been proposed to attempt the challenge.

Naseem and Barzilay (2011), Tu and Honavar
(2012), Spitkovsky et al. (2012), Spitkovsky et al.
(2013), and Marecek and Straka (2013) employ ex-
tensions of the DMV but with different learning
strategies. Naseem and Barzilay (2011) use seman-
tic cues, which are event annotations from an out-
of-domain annotated corpus, in their model during

training. Relying on the fact that natural language
grammars must be unambiguous in the sense that
a sentence should have very few correct parses, Tu
and Honavar (2012) incorporate unambiguity regu-
larisation to posterior probabilities. Spitkovsky et al.
(2012) bootstrap the learning by slicing up all input
sentences at punctuation. Spitkovsky et al. (2013)
propose a complete deterministic learning frame-
work for breaking out of local optima using count
transforms and model recombination. Marecek and
Straka (2013) make use of a large raw text corpus
(e.g., Wikipedia) to estimate stop probabilities, us-
ing the reducibility principle.

Differing from those works, Bisk and Hocken-
maier (2012) rely on Combinatory Categorial Gram-
mars with a small number of hand-crafted general
linguistic principles; whereas Blunsom and Cohn
(2010) use Tree Substitution Grammars with a hi-
erarchical non-parametric Pitman-Yor process prior
biasing the learning to a small grammar.

2.2 Reranking

Our work relies on reranking which is a technique
widely used in (semi-)supervised parsing. Rerank-
ing requires two components: a k-best parser and a
reranker. Given a sentence, the parser generates a
list of k best candidates, the reranker then rescores
those candidates and picks the one that has the high-
est score. Reranking was first successfully applied to
supervised constituent parsing (Collins, 2000; Char-
niak and Johnson, 2005). It was then employed in
the supervised dependency parsing approaches of
Sangati et al. (2009), Hayashi et al. (2013), and Le
and Zuidema (2014).

Closest to our work is the work series on semi-
supervised constituent parsing of McClosky and col-
leagues, e.g. McClosky et al. (2006), using self-
training. They use a k-best generative parser and
a discriminative reranker to parse unannotated sen-
tences, then add resulting parses to the training
treebank and re-train the reranker. Different from
their work, our work is for unsupervised dependency
parsing, without manually annotated data, and uses
iterated reranking instead of single reranking. In
addition, both two components, k-best parser and
reranker, are re-trained after each iteration.

652



3 The IR Framework

Existing training methods for the unsupervised de-
pendency task, such as Blunsom and Cohn (2010),
Gillenwater et al. (2011), and Tu and Honavar
(2012), are hypothesis-oriented search with the EM
algorithm or its variants: training is to move from
a point which represents a model hypothesis to an-
other point. This approach is feasible for optimising
models using simple features since existing dynamic
programming algorithms can compute expectations,
which are sums over all possible parses, or to find
the best parse in the whole parse space with low
complexities. However, the complexity increases
rapidly if rich, complex features are used. One way
to reduce the computational cost is to use approx-
imation methods like sampling as in Blunsom and
Cohn (2010).

3.1 Treebank-oriented Greedy Search

Believing that the difficulty of using EM is from
the fact that treebanks are ‘hidden’, leading to the
need of computing sum (or max) overall possible
treebanks, we propose a greedy local search scheme
based on another training philosophy: treebank-
oriented search. The key idea is to explicitly search
for concrete treebanks which are used to train pars-
ing models. This scheme thus allows supervised
parsers to be trained in an unsupervised parsing set-
ting since there is a (automatically annotated) tree-
bank at any time.

Given S a set of raw sentences, the search space
consists of all possible treebanksD = {d(s)|s ∈ S}
where d(s) is a dependency tree of sentence s. The
target of search is the optimal treebank D∗ that is as
good as human annotations. Greedy search with this
philosophy is as follows: starting at an initial point
D1, we pick up a point D2 among its neighbours
N(D1) such that

D2 = arg max
D∈N(D1)

fD1(D) (1)

where fD1(D) is an objective function measuring
the goodness of D (which may or may not be con-
ditioned on D1). We then continue this search until
some stop criterion is satisfied. The crucial factor
here is to define N(Di) and fDi(D). Below are two
special cases of this scheme.

Semi-supervised parsing using reranking (Mc-
Closky et al., 2006). This reranking is indeed one-
step greedy local search. In this scenario, N(D1) is
the Cartesian product of k-best lists generated by a
k-best parser, and fDi(D) is a reranker.

Unsupervised parsing with hard-EM
(Spitkovsky et al., 2010b) In hard-EM, the tar-
get is to maximise the following objective function
with respect to a parameter set Θ

L(S|Θ) =
∑
s∈S

max
d∈Dep(s)

log PΘ
(
d
)

(2)

where Dep(s) is the set of all possible dependency
structures of s. The two EM steps are thus

• Step 1: Di+1 = arg maxD PΘi(D)

• Step 2: Θi+1 = arg maxΘ PΘ(Di+1)

In this case, N(Di) is the whole treebank space and
fDi(D) = PΘi(D) = Parg maxΘ PΘ(Di)(D).

3.2 Iterated Reranking

We instantiate the greedy search scheme by iterated
reranking which requires two components: a k-best
parser P , and a reranker R. Firstly, D1 is used
to train these two components, resulting in P1 and
R1. The parser P1 then generates a set of lists of k
candidates kD1 (whose Cartesian product results in
N(D1)) for the set of training sentences S. The best
candidates, according to reranker R1, are collected
to form D2 for the next iteration. This process is
halted when a pre-defined stop criterion is met.1

It is certain that we can, as in the work of
Spitkovsky et al. (2010b) and many bootstrapping
approaches, employ only parser P . Reranking, how-
ever, brings us two benefits. First, it allows us to em-
ploy very expressive models like the ∞-order gen-
erative model proposed by Le and Zuidema (2014).
Second, it embodies a similar idea to co-training
(Blum and Mitchell, 1998): P and R play roles as
two views of the data.

1It is worth noting that, although N(Di) has the size O(kn)
where n is the number of sentences, reranking only needs to
process O(k × n) parses if these sentences are assumed to be
independent.

653



3.3 Multi-phase Iterated Reranking

Training in machine learning often uses starting big
which is to use up all training data at the same time.
However, Elman (1993) suggests that in some cases,
learning should start by training simple models on
small data and then gradually increase the model
complexity and add more difficult data. This is
called starting small.

In unsupervised dependency parsing, starting
small is intuitive. For instance, given a set of long
sentences, learning the fact that the head of a sen-
tence is its main verb is difficult because a long sen-
tence always contains many syntactic categories. It
would be much easier if we start with only length-
one sentences, e.g “Look!”, since there is only
one choice which is usually a verb. This training
scheme was successfully applied by Spitkovsky et
al. (2010a) under the name: Baby Step.

We adopt starting small to construct the multi-
phase iterated reranking (MPIR) framework. In
phase 0, a parser M with a simple model is trained
on a set of short sentences S(0) as in traditional ap-
proaches. This parser is used to parse a larger set
of sentences S(1) ⊇ S(0), resulting in D(1)1 . D(1)1 is
then used as the starting point for the iterated rerank-
ing in phase 1. We continue this process until phase
N finishes, with S(i) ⊇ S(i−1) (i = 1..N ). In gen-
eral, we use the resulting reranker in the previous
phase to generate the starting point for the iterated
reranking in the current phase.

4 Le and Zuidema (2014)’s Reranker

Le and Zuidema (2014)’s reranker is an exception
among supervised parsers because it employs an ex-
tremely expressive model whose features are ∞-
order2. To overcome the problem of sparsity, they
introduced the inside-outside recursive neural net-
work (IORNN) architecture that can estimate tree-
generating models including those proposed by Eis-
ner (1996) and Collins (2003a).

4.1 The∞-order Generative Model
Le and Zuidema (2014)’s reranker employs the gen-
erative model proposed by Eisner (1996). Intu-
itively, this model is top-down: starting with ROOT,

2In fact, the order is finite but unbound.

Figure 1: Inside-Outside Recursive Neural Network
(IORNN). Black/white rectangles correspond to in-
ner/outer representations.

we generate its left dependents and its right de-
pendents. We then generate dependents for each
ROOT’s dependent. The generative process recur-
sively continues until there is no dependent to gen-
erate. Formally, this model is described by the fol-
lowing formula

P (d(H)) =
L∏

l=1

P
(
HLl |C(HLl )

)
P
(
d(HLl )

)×
R∏

r=1

P
(
HRr |C(HRr )

)
P
(
d(HRr )

)
(3)

where H is the current head, d(N) is the fragment
of the dependency parse rooted at N , and C(N)
is the context to generate N . HL, HR are respec-
tively H’s left dependents and right dependents, plus
EOC (End-Of-Children), a special token to inform
that there are no more dependents to generate. Thus,
P (d(ROOT )) is the probability of generating the
entire dependency structure d.

Le and Zuidema’s ∞-order generative model is
defined as Eisner’s model in which the context
C∞(D) to generate D contains all of D’s generated
siblings, its ancestors and their siblings. Because
of very large fragments that contexts are allowed to
hold, traditional count-based methods are imprac-
tical (even if we use smart smoothing techniques).
They thus introduced the IORNN architecture to es-
timate the model.

4.2 Estimation with the IORNN

An IORNN (Figure 1) is a recursive neural network
whose topology is a tree. What make this network
different from traditional RNNs (Socher et al., 2010)
is that each tree node u caries two vectors: iu - the
inner representation, represents the content of the

654



phrase covered by the node, and ou - the outer repre-
sentation, represents the context around that phrase.
In addition, information in an IORNN is allowed to
flow not only bottom-up as in RNNs, but also top-
down. That makes IORNNs a natural tool for esti-
mating top-down tree-generating models.

Applying the IORNN architecture to dependency
parsing is straightforward, along the generative story
of the ∞-order generative model. First of all, the
“inside” part of this IORNN is simpler than what
is depicted in Figure 1: the inner representation of
a phrase is assumed to be the inner representation
of its head. This approximation is plausible since
the meaning of a phrase is often dominated by the
meaning of its head. The inner representation at
each node, in turn, is a function of a vector repre-
sentation for the word (in our case, the word vectors
are initially borrowed from Collobert et al. (2011)),
the POS-tag and capitalisation feature.

Without loss of generality and ignoring directions
for simplicity, they assume that the model is generat-
ing dependent u for node h conditioning on context
C∞(u) which contains all of u’s ancestors (includ-
ing h) and theirs siblings, and all of previously gen-
erated u’s sisters. Now there are two types of con-
texts: full contexts of heads (e.g., h) whose depen-
dents are being generated, and contexts to generate
nodes (e.g., C∞(u)). Contexts of the first type are
clearly represented by outer representations. Con-
texts of the other type are represented by partial
outer representations, denoted by ōu. Because the
context to generate a node can be constructed recur-
sively by combining the full context of its head and
its previously generated sisters, they can compute ōu
as a function of oh and the inner representations of
its previously generated sisters. On the top of ōu,
they put a softmax layer to estimate the probability
P (x|C∞(u)).

Training this IORNN is to minimise the cross en-
tropy over all dependents. This objective function is
indeed the negative log likelihood P (D) of training
treebank D.

4.3 The Reranker

Le and Zuidema’s (generative) reranker is given by

d∗ = arg max
d∈kDep(s)

P (d)

where P (Equation 3) is computed by the ∞-order
generative model which is estimated by an IORNN;
and kDep(s) is a k-best list.

5 Complete System

Our system is based on the multi-phase IR. In gen-
eral, any third-party parser for unsupervised depen-
dency parsing can be used in phase 0, and any third-
party parser that can generate k-best lists can be used
in the other phases. In our experiments, for phase 0,
we choose the parser using an extension of the DMV
model with stop-probability estimates computed on
a large corpus proposed by Marecek and Straka
(2013). This system has a moderate performance3

on the WSJ corpus: 57.1% vs the SOTA 64.4% DDA
of Spitkovsky et al. (2013). For the other phases, we
use the MSTParser4 (with the second-order feature
mode) (McDonald and Pereira, 2006).

Our system uses Le and Zuidema (2014)’s
reranker (Section 4.3). It is worth noting that, in
this case, each phase with iterated reranking could
be seen as an approximation of hard-EM (see Equa-
tion 2) where the first step is replaced by

Di+1 = arg max
D∈N(Di)

PΘi(D) (4)

In other words, instead of searching over the tree-
bank space, the search is limited in a neighbour set
N(Di) generated by k-best parser Pi.

5.1 Tuning Parser P

Parser Pi trained onDi defines neighbour set N(Di)
which is the Cartesian product of the k-best lists in
kDi. The position and shape of N(Di) is thus deter-
mined by two factors: how well Pi can fit Di, and k.
Intuitively, the lower the fitness is, the more N(Di)
goes far away fromDi; and the larger k is, the larger

3Marecek and Straka (2013) did not report any experimental
result on the WSJ corpus. We use their source code at http:
//ufal.mff.cuni.cz/udp with the setting presented in
Section 6.1. Because the parser does not provide the option to
parse unseen sentences, we merge the training sentences (up to
length 15) to all the test sentences to evaluate its performance.
Note that this result is close to the DDA (55.4%) that the authors
reported on CoNLL 2007 English dataset, which is a portion of
the WSJ corpus.

4http://sourceforge.net/projects/
mstparser/

655



N(Di) is. Moreover, the diversity of N(Di) is in-
versely proportional to the fitness. When the fitness
decreases, patterns existing in the training treebank
become less certain to the parser, patterns that do not
exist in the training treebank thus have more chances
to appear in k-best candidates. This leads to high di-
versity of N(Di). We blindly set k = 10 in all of
our experiments.

With the MSTParser, there are two hyper-
parameters: itersMST, the number of epochs, and
training-kMST, the k-best parse set size to cre-
ate constraints during training. training-kMST
is always 1 because constraints from k-best parses
with almost incorrect training parses are useless.

Because itersMST controls the fitness of the
parser to training treebank Di, it, as pointed out
above, determines the distance from N(Di) to Di
and the diversity of the former. Therefore, if we
want to encourage the local search to explore more
distant areas, we should set itersMST low. In our
experiments, we test two strategies: (i) MaxEnc,
itersMST = 1, maximal encouragement, and (ii)
MinEnc, itersMST = 10, minimal encouragement.

5.2 Tuning Reranker R

Tuning the reranker R is to set values for dimIORNN,
the dimensions of inner and outer representations,
and itersIORNN, the number of epochs to train the
IORNN. Because the∞-order model is very expres-
sive and feed-forward neural networks are universal
approximators (Cybenko, 1989), the reranker is ca-
pable of perfectly remembering all training parses.
In order to avoid this, we set dimIORNN = 50, and
set itersIORNN = 5 for very early stopping.

5.3 Tuning multi-phase IR

Because Marecek and Straka (2013)’s parser does
not distinguish training data from test data, we pos-
tulate S0 = S1. Our system has N phases such that
S0,S1 contain all sentences up to length l1 = 15,
Si (i = 2..N ) contains all sentences up to length
li = li−1 + 1, and SN contains all sentences up to
length 25. Phase 1 halts after 100 iterations whereas
all the following phases run with one iteration. Note
that we force the local search in phase 1 to run in-
tensively because we hypothesise that most of the
important patterns for dependency parsing can be
found within short sentences.

6 Experiments

6.1 Setting
We use the Penn Treebank WSJ corpus: sections
02-21 for training, and section 23 for testing. We
then apply the standard pre-processing5 for unsu-
pervised dependency parsing task (Klein and Man-
ning, 2004): we strip off all empty sub-trees, punc-
tuation, and terminals (tagged # and $) not pro-
nounced where they appear; we then convert the re-
maining trees to dependencies using Collins’s head
rules (Collins, 2003b). Both word forms and gold
POS tags are used. The directed dependency accu-
racy (DDA) metric is used for evaluation.

The vocabulary is taken as a list of words occur-
ring more than two times in the training data. All
other words are labelled ‘UNKNOWN’ and every
digit is replaced by ‘0’. We initialise the IORNN
with the 50-dim word embeddings from Collobert et
al. (2011) 6 , and train it with the learning rate 0.1,

6.2 Results
We compare our system against recent systems (Ta-
ble 1 and Section 2.1). Our system with the two en-
couragement levels, MinEnc and MaxEnc, achieves
the highest reported DDAs on section 23: 1.8% and
1.2% higher than Spitkovsky et al. (2013) on all sen-
tences and up to length 10, respectively. Our im-
provements over the system’s initialiser (Marecek
and Straka, 2013) are 9.1% and 4.4%.

6.3 Analysis
In this section, we analyse our system along two as-
pects. First, we examine three factors which deter-
mine the performance of the whole system: encour-
agement level, lexical semantics, and starting point.
We then search for what IR (with the MaxEnc op-
tion) contributes to the overall performance by com-
paring the quality of the treebank resulted in the end
of phase 1 against the quality of the treebank given
by its initialier, i.e. Marecek and Straka (2013).

The effect of encouragement level
Figure 2 shows the differences in DDA between

using MaxEnc and MinEnc in each phase: we com-
5http://www.cs.famaf.unc.edu.ar/

˜francolq/en/proyectos/dmvccm
6http://ml.nec-labs.com/senna/. These word

embeddings were unsupervisedly learnt from Wikipedia.

656



System DDA (@10)
Bisk and Hockenmaier (2012) 53.3 (71.5)

Blunsom and Cohn (2010) 55.7 (67.7)
Tu and Honavar (2012) 57.0 (71.4)

Marecek and Straka (2013)3 57.1 (68.8)
Naseem and Barzilay (2011) 59.4 (70.2)

Spitkovsky et al. (2012) 61.2 (71.4)
Spitkovsky et al. (2013) 64.4 (72.0)

Our system (MinEnc) 66.2 (72.7)
Our system (MaxEnc) 65.8 (73.2)

Table 1: Performance on section 23 of the WSJ cor-
pus (all sentences and up to length 10) for recent sys-
tems and our system. MinEnc and MaxEnc denote
itersMST = 10 and itersMST = 1 respectively.

Figure 2: DDAMaxEnc − DDAMinEnc of all phases
on the their training sets (e.g., phase 3 with S(3) con-
taining all training sentences up to length 17).

pute DDAMaxEnc−DDAMinEnc of each phase on its
training set (e.g., phase 3 with S(3) containing all
training sentences up to length 17). MinEnc outper-
forms MaxEnc within phases 1, 2, 3, and 4. How-
ever, from phase 5, the latter surpasses the former. It
suggests that exploring areas far away from the cur-
rent point with long sentences is risky. The reason
is that long sentences contain more ambiguities than
short ones; thus rich diversity, high difference from
the current point, but small size (i.e., small k) could
easily lead the learning to a wrong path.

The performance of the system with the two en-
couragement levels on section 23 (Table 1) also sug-
gests the same. MaxEnc strategy helps the system
achieve the highest accuracy on short sentences (up
to length 10). However, it is less helpful than Mi-
nEnc when performing on long sentences.

Figure 3: DDA of phase 1 (MaxEnc), with and with-
out the word embeddings (denoted by w/ sem and
wo/ sem, respectively), on training sentences up to
length 15 (i.e. S(1)).

Figure 4: DDA of phase 1 (MaxEnc) before and af-
ter training with three different starting points pro-
vided by three parsers used in phase 0: MS (Mare-
cek and Straka, 2013), GGGPT (Gillenwater et al.,
2011), and Harmonic (Klein and Manning, 2004).

The role of lexical semantics

We examine the role of the lexical semantics,
which is given by the word embeddings. Fig-
ure 3 shows DDAs on training sentences up to
length 15 (i.e. S(1)) of phase 1 (MaxEnc) with
and without the word-embeddings. With the word-
embeddings, phase 1 achieves 71.11%. When the
word-embeddings are not given, i.e. the IORNN
uses randomly generated word vectors, the accuracy
drops 4.2%. It shows that lexical semantics plays a
decisive role in the performance of the system.

However, it is worth noting that, even without that
knowledge (i.e., with the∞-order generative model
alone), the DDA of phase 1 is 2% higher than before
being trained (66.89% vs 64.9%). It suggests that
phase 1 is capable of discovering some useful de-
pendency patterns that are invisible to the parser in
phase 0. This, we conjecture, is thanks to high-order
features captured by the IORNN.

The importance of the starting point

Starting point is claimed to be important in lo-
cal search. We examine this by using three differ-
ent parsers in phase 0: (i) MS (Marecek and Straka,

657



Figure 5: Precision (top) and recall (bottom) over
binned HEAD distance of iterated reranking (IR)
and its initializer (MS) on the training sentences in
phase 1 (≤ 15 words).

2013), the parser used in the previous experiments,
(ii) GGGPT (Gillenwater et al., 2011)7 employing
an extension of the DMV model and posterior reg-
ularization framework for training, and (iii) Har-
monic, the harmonic initializer proposed by Klein
and Manning (2004).

Figure 4 shows DDAs of phase 1 (MaxEnc)
on training sentences up to length 15 with three
starting-points given by those parsers. Starting point
is clearly very important to the performance of the
iterated reranking: the better the starting point is,
the higher performance phase 1 has. However, a
remarkable point here is that the iterated reranking
of phase 1 always finds out more useful patterns for
parsing whatever the starting point is in this experi-
ment. It is certainly due to the high order features
and lexical semantics, which are not exploited in
those parsers.

The contribution of Iterated Reranking
We compare the quality of the treebank resulted in

the end of phase 1 against the quality of the treebank
given by the initialier Marecek and Straka (2013).
Figure 5 shows precision (top) and recall (bottom)

7code.google.com/p/pr-toolkit

over binned HEAD distance. IR helps to improve
the precision on all distance bins, especially on the
bins corresponding to long distances (≥ 3). The re-
call is also improved, except on the bin correspond-
ing to≥ 7 (but the F1-score on this bin is increased).
We attribute this improvement to the∞-order model
which uses very large fragments as contexts thus be
able to capture long dependencies.

Figure 6 shows the correct-head accuracies over
POS-tags. IR helps to improve the accuracies over
almost all POS-tags, particularly nouns (e.g. NN,
NNP, NNS), verbs (e.g. VBD, VBZ, VBN, VBG)
and adjectives (e.g. JJ, JJR). However, as being af-
fected by the initializer, IR performs poorly on con-
junction (CC) and modal auxiliary (MD). For in-
stance, in the treebank given by the initializer, al-
most all modal auxilaries are dependents of their
verbs instead of the other way around.

7 Discussion

Our system is different from the other systems
shown in Table 1 as it uses an extremely expressive
model, the∞-order generative model, in which con-
ditioning contexts are very large fragments. Only
the work of Blunsom and Cohn (2010), whose re-
sulting grammar rules can contain large tree frag-
ments, shares this property. The difference is that
their work needs a pre-defined prior, namely hierar-
chical non-parametric Pitman-Yor process prior, to
avoid large, rare fragments and for smoothing. The
IORNN of our system, in contrast, does that auto-
matically. It learns by itself how to deal with dis-
tant conditioning nodes, which are often less infor-
mative than close conditioning nodes on computing
P (x|C∞(u)). In addition, smoothing is given free:
recursive neural nets are able to map ‘similar’ frag-
ments onto close points (Socher et al., 2010) thus
an unseen fragment tends to be mapped onto a point
close to points corresponding to ‘similar’ seen frag-
ments.

Another difference is that our system exploits lex-
ical semantics via word embeddings, which were
learnt unsupervisedly. By initialising the IORNN
with these embeddings, the use of this knowledge
turns out easy and transparent. Spitkovsky et al.
(2013) also exploit lexical semantics but in a limited
way, using a context-based polysemous unsuper-

658



Figure 6: Correct-head accuracies over POS-tags (sorted in the descending order by frequency) of iterated
reranking (IR) and its initializer (MS) on the training sentences in phase 1 (≤ 15 words).

vised clustering method to tag words. Although their
approach can distinguish polysemes (e.g., ‘cool’ in
‘to cool the selling panic’ and in ‘it is cool’), it is not
able to make use of word meaning similarities (e.g.,
the meaning of ‘dog’ is closer to ‘animal’ than to
‘table’). Naseem and Barzilay (2011)’s system uses
semantic cues from an out-of-domain annotated cor-
pus, thus is not fully unsupervised.

We have showed that IR with a generative
reranker is an approximation of hard-EM (see Equa-
tion 4). Our system is thus related to the works of
Spitkovsky et al. (2013) and Tu and Honavar (2012).
However, what we have proposed is more than
that: IR is a general framework that we can have
more than one option for choosing k-best parser and
reranker. For instance, we can make use of a gener-
ative k-best parser and a discriminative reranker that
are used for supervised parsing. Our future work is
to explore this.

The experimental results reveal that starting point
is very important to the iterated reranking with the
∞-order generative model. On the one hand, that
is a disadvantage compared to the other systems,
which use uninformed or harmonic initialisers. But
on the other hand, that is an innovation as our ap-
proach is capable of making use of existing systems.
The results shown in Figure 4 suggest that if phase 0
uses a better parser which uses less expressive model
and/or less external knowledge than our model, such
as the one proposed by Spitkovsky et al. (2013), we
can expect even a higher performance. The other
systems, except Blunsom and Cohn (2010), how-
ever, might not benefit from using good existing

parsers as initializers because their models are not
significantly more expressive than others 8.

8 Conclusion

We have proposed a new framework, iterated rerank-
ing (IR), which trains supervised parsers without the
need of manually annotated data by using a unsu-
pervised parser as an initialiser. Our system, em-
ploying Marecek and Straka (2013)’s unsupervised
parser as the initialiser, the k-best MSTParser, and
Le and Zuidema (2014)’s reranker, achieved 1.8%
DDA higher than the SOTA parser of Spitkovsky et
al. (2013) on the WSJ corpus. Moreover, we also
showed that unsupervised parsing benefits from lex-
ical semantics through using word-embeddings.

Our future work is to exploit other existing super-
vised parsers that fit our framework. Besides, taking
into account the fast development of the word em-
bedding research (Mikolov et al., 2013; Pennington
et al., 2014), we will try different word embeddings.

Acknowledgments

We thank Remko Scha and three anonymous re-
viewers for helpful comments. Le thanks Milos̆
Stanojević for helpful discussion.

8In an experiment, we used the Marecek and Straka (2013)’s
parser as an initializer for the Gillenwater et al. (2011)’s parser.
As we expected, the latter was not able to make use of this.

659



References

Mohit Bansal, Kevin Gimpel, and Karen Livescu. 2014.
Tailoring continuous word representations for depen-
dency parsing. In Proceedings of the Annual Meeting
of the Association for Computational Linguistics.

Yonatan Bisk and Julia Hockenmaier. 2012. Simple ro-
bust grammar induction with combinatory categorial
grammars. In AAAI.

Avrim Blum and Tom M. Mitchell. 1998. Combining
labeled and unlabeled sata with co-training. In COLT,
pages 92–100.

Phil Blunsom and Trevor Cohn. 2010. Unsupervised in-
duction of tree substitution grammars for dependency
parsing. In Proceedings of the 2010 Conference on
Empirical Methods in Natural Language Processing,
pages 1204–1213. Association for Computational Lin-
guistics.

Eugene Charniak and Mark Johnson. 2005. Coarse-to-
fine n-best parsing and maxent discriminative rerank-
ing. In ACL.

Danqi Chen and Christopher D Manning. 2014. A
fast and accurate dependency parser using neural net-
works. In Empirical Methods in Natural Language
Processing (EMNLP).

Michael Collins. 2000. Discriminative reranking for nat-
ural language parsing. In ICML, pages 175–182.

Michael Collins. 2003a. Head-driven statistical models
for natural language parsing. Computational linguis-
tics, 29(4):589–637.

Michael Collins. 2003b. Head-driven statistical models
for natural language parsing. Computational Linguis-
tics, 29(4):589–637.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa. 2011.
Natural language processing (almost) from scratch.
The Journal of Machine Learning Research, 12:2493–
2537.

George Cybenko. 1989. Approximation by superposi-
tions of a sigmoidal function. Mathematics of control,
signals and systems, 2(4):303–314.

Jason M Eisner. 1996. Three new probabilistic mod-
els for dependency parsing: An exploration. In Pro-
ceedings of the 16th conference on Computational
linguistics-Volume 1, pages 340–345. Association for
Computational Linguistics.

Jeffrey L Elman. 1993. Learning and development in
neural networks: The importance of starting small.
Cognition, 48(1):71–99.

Jennifer Gillenwater, Kuzman Ganchev, João Graça, Fer-
nando Pereira, and Ben Taskar. 2011. Posterior spar-
sity in unsupervised dependency parsing. The Journal
of Machine Learning Research, 12:455–490.

Katsuhiko Hayashi, Shuhei Kondo, and Yuji Matsumoto.
2013. Efficient stacked dependency parsing by forest
reranking. Transactions of the Association for Com-
putational Linguistics, 1(1):139–150.

Dan Klein and Christopher D. Manning. 2004. Corpus-
based induction of syntactic structure: Models of de-
pendency and constituency. In ACL, pages 478–485.

Terry Koo and Michael Collins. 2010. Efficient third-
order dependency parsers. In Proceedings of the 48th
Annual Meeting of the Association for Computational
Linguistics, pages 1–11. Association for Computa-
tional Linguistics.

Phong Le and Willem Zuidema. 2014. The inside-
outside recursive neural network model for depen-
dency parsing. In Proceedings of the 2014 Conference
on Empirical Methods in Natural Language Process-
ing. Association for Computational Linguistics.

David Marecek and Milan Straka. 2013. Stop-
probability estimates computed on a large corpus im-
prove unsupervised dependency parsing. In ACL (1),
pages 281–290.

André FT Martins, Miguel B Almeida, and Noah A
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proc. of ACL.

David McClosky, Eugene Charniak, and Mark Johnson.
2006. Effective self-training for parsing. In Proceed-
ings of the main conference on human language tech-
nology conference of the North American Chapter of
the Association of Computational Linguistics, pages
152–159. Association for Computational Linguistics.

Ryan T. McDonald and Fernando C. N. Pereira. 2006.
Online learning of approximate dependency parsing
algorithms. In EACL.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Cor-
rado, and Jeff Dean. 2013. Distributed representations
of words and phrases and their compositionality. In
Advances in Neural Information Processing Systems,
pages 3111–3119.

Tahira Naseem and Regina Barzilay. 2011. Using se-
mantic cues to learn syntax. In AAAI.

Tahira Naseem. 2014. Linguistically Motivated Mod-
els for Lightly-Supervised Dependency Parsing. Ph.D.
thesis, Massachusetts Institute of Technology.

Jeffrey Pennington, Richard Socher, and Christopher D
Manning. 2014. Glove: Global vectors for word rep-
resentation. Proceedings of the Empiricial Methods in
Natural Language Processing (EMNLP 2014), 12.

Federico Sangati, Willem Zuidema, and Rens Bod. 2009.
A generative re-ranking model for dependency pars-
ing. In Proceedings of the 11th International Confer-
ence on Parsing Technologies, pages 238–241. Asso-
ciation for Computational Linguistics.

660



Richard Socher, Christopher D. Manning, and Andrew Y.
Ng. 2010. Learning continuous phrase representa-
tions and syntactic parsing with recursive neural net-
works. In Proceedings of the NIPS-2010 Deep Learn-
ing and Unsupervised Feature Learning Workshop.

Valentin I. Spitkovsky, Hiyan Alshawi, and Daniel Ju-
rafsky. 2010a. From Baby Steps to Leapfrog: How
“Less is More” in unsupervised dependency parsing.
In Proc. of NAACL-HLT.

Valentin I. Spitkovsky, Hiyan Alshawi, Daniel Jurafsky,
and Christopher D. Manning. 2010b. Viterbi training
improves unsupervised dependency parsing. In Pro-
ceedings of the Fourteenth Conference on Computa-
tional Natural Language Learning (CoNLL-2010).

Valentin I. Spitkovsky, Hiyan Alshawi, and Daniel Ju-
rafsky. 2012. Bootstrapping dependency grammar in-
ducers from incomplete sentence fragments via austere
models. In Proceedings of the 11th International Con-
ference on Grammatical Inference.

Valentin I. Spitkovsky, Hiyan Alshawi, and Daniel Ju-
rafsky. 2013. Breaking out of local optima with
count transforms and model recombination: A study
in grammar induction. In EMNLP, pages 1983–1995.

Kewei Tu and Vasant Honavar. 2012. Unambiguity reg-
ularization for unsupervised learning of probabilistic
grammars. In Proceedings of the 2012 Joint Confer-
ence on Empirical Methods in Natural Language Pro-
cessing and Computational Natural Language Learn-
ing, pages 1324–1334. Association for Computational
Linguistics.

661


