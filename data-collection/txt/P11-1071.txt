










































The impact of language models and loss functions on repair disfluency detection


Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics, pages 703–711,
Portland, Oregon, June 19-24, 2011. c©2011 Association for Computational Linguistics

The impact of language models and loss functions on repair disfluency
detection

Simon Zwarts and Mark Johnson
Centre for Language Technology

Macquarie University
{simon.zwarts|mark.johnson|}@mq.edu.au

Abstract

Unrehearsed spoken language often contains
disfluencies. In order to correctly inter-
pret a spoken utterance, any such disfluen-
cies must be identified and removed or other-
wise dealt with. Operating on transcripts of
speech which contain disfluencies, we study
the effect of language model and loss func-
tion on the performance of a linear reranker
that rescores the 25-best output of a noisy-
channel model. We show that language mod-
els trained on large amounts of non-speech
data improve performance more than a lan-
guage model trained on a more modest amount
of speech data, and that optimising f-score
rather than log loss improves disfluency detec-
tion performance.

Our approach uses a log-linear reranker, oper-
ating on the top n analyses of a noisy chan-
nel model. We use large language models,
introduce new features into this reranker and
examine different optimisation strategies. We
obtain a disfluency detection f-scores of 0.838
which improves upon the current state-of-the-
art.

1 Introduction

Most spontaneous speech contains disfluencies such
as partial words, filled pauses (e.g., “uh”, “um”,
“huh”), explicit editing terms (e.g., “I mean”), par-
enthetical asides and repairs. Of these, repairs
pose particularly difficult problems for parsing and
related Natural Language Processing (NLP) tasks.
This paper presents a model of disfluency detec-
tion based on the noisy channel framework, which

specifically targets the repair disfluencies. By com-
bining language models and using an appropriate
loss function in a log-linear reranker we are able to
achieve f-scores which are higher than previously re-
ported.

Often in natural language processing algorithms,
more data is more important than better algorithms
(Brill and Banko, 2001). It is this insight that drives
the first part of the work described in this paper. This
paper investigates how we can use language models
trained on large corpora to increase repair detection
accuracy performance.

There are three main innovations in this paper.
First, we investigate the use of a variety of language
models trained from text or speech corpora of vari-
ous genres and sizes. The largest available language
models are based on written text: we investigate the
effect of written text language models as opposed to
language models based on speech transcripts. Sec-
ond, we develop a new set of reranker features ex-
plicitly designed to capture important properties of
speech repairs. Many of these features are lexically
grounded and provide a large performance increase.
Third, we utilise a loss function, approximate ex-
pected f-score, that explicitly targets the asymmetric
evaluation metrics used in the disfluency detection
task. We explain how to optimise this loss func-
tion, and show that this leads to a marked improve-
ment in disfluency detection. This is consistent with
Jansche (2005) and Smith and Eisner (2006), who
observed similar improvements when using approx-
imate f-score loss for other problems. Similarly we
introduce a loss function based on the edit-f-score in
our domain.703



Together, these three improvements are enough to
boost detection performance to a higher f-score than
previously reported in literature. Zhang et al. (2006)
investigate the use of ‘ultra large feature spaces’ as
an aid for disfluency detection. Using over 19 mil-
lion features, they report a final f-score in this task of
0.820. Operating on the same body of text (Switch-
board), our work leads to an f-score of 0.838, this is
a 9% relative improvement in residual f-score.

The remainder of this paper is structured as fol-
lows. First in Section 2 we describe related work.
Then in Section 3 we present some background on
disfluencies and their structure. Section 4 describes
appropriate evaluation techniques. In Section 5 we
describe the noisy channel model we are using. The
next three sections describe the new additions: Sec-
tion 6 describe the corpora used for language mod-
els, Section 7 describes features used in the log-
linear model employed by the reranker and Section 8
describes appropriate loss functions which are criti-
cal for our approach. We evaluate the new model in
Section 9. Section 10 draws up a conclusion.

2 Related work

A number of different techniques have been pro-
posed for automatic disfluency detection. Schuler
et al. (2010) propose a Hierarchical Hidden Markov
Model approach; this is a statistical approach which
builds up a syntactic analysis of the sentence and
marks those subtrees which it considers to be made
up of disfluent material. Although they are inter-
ested not only in disfluency but also a syntactic anal-
ysis of the utterance, including the disfluencies be-
ing analysed, their model’s final f-score for disflu-
ency detection is lower than that of other models.

Snover et al. (2004) investigate the use of purely
lexical features combined with part-of-speech tags
to detect disfluencies. This approach is compared to
approaches which use primarily prosodic cues, and
appears to perform equally well. However, the au-
thors note that this model finds it difficult to identify
disfluencies which by themselves are very fluent. As
we will see later, the individual components of a dis-
fluency do not have to be disfluent by themselves.
This can occur when a speaker edits her speech for
meaning-related reasons, rather than errors that arise
from performance. The edit repairs which are the fo-

cus of our work typically have this characteristic.
Noisy channel models have done well on the dis-

fluency detection task in the past; the work of John-
son and Charniak (2004) first explores such an ap-
proach. Johnson et al. (2004) adds some hand-
written rules to the noisy channel model and use a
maximum entropy approach, providing results com-
parable to Zhang et al. (2006), which are state-of-the
art results.

Kahn et al. (2005) investigated the role of
prosodic cues in disfluency detection, although the
main focus of their work was accurately recovering
and parsing a fluent version of the sentence. They
report a 0.782 f-score for disfluency detection.

3 Speech Disfluencies

We follow the definitions of Shriberg (1994) regard-
ing speech disfluencies. She identifies and defines
three distinct parts of a speech disfluency, referred
to as the reparandum, the interregnum and the re-
pair. Consider the following utterance:

I want a flight

reparandum︷ ︸︸ ︷
to Boston,

uh, I mean
︸ ︷︷ ︸

interregnum

to Denver
︸ ︷︷ ︸

repair

on Friday
(1)

The reparandum to Boston is the part of the utterance
that is ‘edited out’; the interregnum uh, I mean is a
filled pause, which need not always be present; and
the repair to Denver replaces the reparandum.

Shriberg and Stolcke (1998) studied the location
and distribution of repairs in the Switchboard cor-
pus (Godfrey and Holliman, 1997), the primary cor-
pus for speech disfluency research, but did not pro-
pose an actual model of repairs. They found that the
overall distribution of speech disfluencies in a large
corpus can be fit well by a model that uses only in-
formation on a very local level. Our model, as ex-
plained in section 5, follows from this observation.

As our domain of interest we use the Switchboard
corpus. This is a large corpus consisting of tran-
scribed telephone conversations between two part-
ners. In the Treebank III (Marcus et al., 1999) cor-
pus there is annotation available for the Switchboard
corpus, which annotates which parts of utterances
are in a reparandum, interregnum or repair.704



4 Evaluation metrics for disfluency
detection systems

Disfluency detection systems like the one described
here identify a subset of the word tokens in each
transcribed utterance as “edited” or disfluent. Per-
haps the simplest way to evaluate such systems is
to calculate the accuracy of labelling they produce,
i.e., the fraction of words that are correctly labelled
(i.e., either “edited” or “not edited”). However,
as Charniak and Johnson (2001) observe, because
only 5.9% of words in the Switchboard corpus are
“edited”, the trivial baseline classifier which assigns
all words the “not edited” label achieves a labelling
accuracy of 94.1%.

Because the labelling accuracy of the trivial base-
line classifier is so high, it is standard to use a dif-
ferent evaluation metric that focuses more on the de-
tection of “edited” words. We follow Charniak and
Johnson (2001) and report the f-score of our disflu-
ency detection system. The f-score f is:

f =
2c

g + e
(2)

where g is the number of “edited” words in the gold
test corpus, e is the number of “edited” words pro-
posed by the system on that corpus, and c is the num-
ber of the “edited” words proposed by the system
that are in fact correct. A perfect classifier which
correctly labels every word achieves an f-score of
1, while the trivial baseline classifiers which label
every word as “edited” or “not edited” respectively
achieve a very low f-score.

Informally, the f-score metric focuses more on
the “edited” words than it does on the “not edited”
words. As we will see in section 8, this has implica-
tions for the choice of loss function used to train the
classifier.

5 Noisy Channel Model

Following Johnson and Charniak (2004), we use a
noisy channel model to propose a 25-best list of
possible speech disfluency analyses. The choice of
this model is driven by the observation that the re-
pairs frequently seem to be a “rough copy” of the
reparandum, often incorporating the same or very
similar words in roughly the same word order. That

is, they seem to involve “crossed” dependencies be-
tween the reparandum and the repair. Example (3)
shows the crossing dependencies. As this exam-
ple also shows, the repair often contains many of
the same words that appear in the reparandum. In
fact, in our Switchboard training corpus we found
that 62reparandum also appeared in the associated
repair,

to Boston uh, I mean, to Denver︸ ︷︷ ︸
reparandum

︸ ︷︷ ︸
interregnum

︸ ︷︷ ︸
repair

(3)

5.1 Informal Description

Given an observed sentence Y we wish to find the
most likely source sentence X̂ , where

X̂ = argmax
X

P (Y |X)P (X) (4)

In our model the unobserved X is a substring of the
complete utterance Y .

Noisy-channel models are used in a similar way
in statistical speech recognition and machine trans-
lation. The language model assigns a probability
P (X) to the string X , which is a substring of the
observed utterance Y . The channel model P (Y |X)
generates the utterance Y , which is a potentially dis-
fluent version of the source sentence X . A repair
can potentially begin before any word of X . When
a repair has begun, the channel model incrementally
processes the succeeding words from the start of the
repair. Before each succeeding word either the re-
pair can end or else a sequence of words can be in-
serted in the reparandum. At the end of each re-
pair, a (possibly null) interregnum is appended to the
reparandum.

We will look at these two components in the next
two Sections in more detail.

5.2 Language Model

Informally, the task of language model component
of the noisy channel model is to assess fluency of
the sentence with disfluency removed. Ideally we
would like to have a model which assigns a very
high probability to disfluency-free utterances and a
lower probability to utterances still containing dis-
fluencies. For computational complexity reasons, as
described in the next section, inside the noisy chan-
nel model we use a bigram language model. This705



bigram language model is trained on the fluent ver-
sion of the Switchboard corpus (training section).

We realise that a bigram model might not be able
to capture more complex language behaviour. This
motivates our investigation of a range of additional
language models, which are used to define features
used in the log-linear reranker as described below.

5.3 Channel Model

The intuition motivating the channel model design
is that the words inserted into the reparandum are
very closely related to those in the repair. Indeed,
in our training data we find that 62% of the words
in the reparandum are exact copies of words in the
repair; this identity is strong evidence of a repair.
The channel model is designed so that exact copy
reparandum words will have high probability.

Because these repair structures can involve an un-
bounded number of crossed dependencies, they can-
not be described by a context-free or finite-state
grammar. This motivates the use of a more expres-
sive formalism to describe these repair structures.

We assume that X is a substring of Y , i.e., that the
source sentence can be obtained by deleting words
from Y , so for a fixed observed utterance Y there
are only a finite number of possible source sen-
tences. However, the number of possible source sen-
tences, X , grows exponentially with the length of Y ,
so exhaustive search is infeasible. Tree Adjoining
Grammars (TAG) provide a systematic way of for-
malising the channel model, and their polynomial-
time dynamic programming parsing algorithms can
be used to search for likely repairs, at least when
used with simple language models like a bigram
language model. In this paper we first identify the
25 most likely analyses of each sentence using the
TAG channel model together with a bigram lan-
guage model.

Further details of the noisy channel model can be
found in Johnson and Charniak (2004).

5.4 Reranker

To improve performance over the standard noisy
channel model we use a reranker, as previously sug-
gest by Johnson and Charniak (2004). We rerank a
25-best list of analyses. This choice is motivated by
an oracle experiment we performed, probing for the
location of the best analysis in a 100-best list. This

experiment shows that in 99.5% of the cases the best
analysis is located within the first 25, and indicates
that an f-score of 0.958 should be achievable as the
upper bound on a model using the first 25 best anal-
yses. We therefore use the top 25 analyses from the
noisy channel model in the remainder of this paper
and use a reranker to choose the most suitable can-
didate among these.

6 Corpora for language modelling

We would like to use additional data to model
the fluent part of spoken language. However, the
Switchboard corpus is one of the largest widely-
available disfluency-annotated speech corpora. It is
reasonable to believe that for effective disfluency de-
tection Switchboard is not large enough and more
text can provide better analyses. Schwartz et al.
(1994), although not focusing on disfluency detec-
tion, show that using written language data for mod-
elling spoken language can improve performance.
We turn to three other bodies of text and investi-
gate the use of these corpora for our task, disfluency
detection. We will describe these corpora in detail
here.

The predictions made by several language models
are likely to be strongly correlated, even if the lan-
guage models are trained on different corpora. This
motivates the choice for log-linear learners, which
are built to handle features which are not necessar-
ily independent. We incorporate information from
the external language models by defining a reranker
feature for each external language model. The value
of this feature is the log probability assigned by the
language model to the candidate underlying fluent
substring X

For each of our corpora (including Switchboard)
we built a 4-gram language model with Kneser-Ney
smoothing (Kneser and Ney, 1995). For each analy-
sis we calculate the probability under that language
model for the candidate underlying fluent substring
X . We use this log probability as a feature in the
reranker. We use the SRILM toolkit (Stolcke, 2002)
both for estimating the model from the training cor-
pus as well as for computing the probabilities of the
underlying fluent sentences X of the different anal-
ysis.

As previously described, Switchboard is our pri-706



mary corpus for our model. The language model
part of the noisy channel model already uses a bi-
gram language model based on Switchboard, but in
the reranker we would like to also use 4-grams for
reranking. Directly using Switchboard to build a 4-
gram language model is slightly problematic. When
we use the training data of Switchboard both for lan-
guage fluency prediction and the same training data
also for the loss function, the reranker will overesti-
mate the weight associated with the feature derived
from the Switchboard language model, since the flu-
ent sentence itself is part of the language model
training data. We solve this by dividing the Switch-
board training data into 20 folds. For each fold we
use the 19 other folds to construct a language model
and then score the utterance in this fold with that
language model.

The largest widely-available corpus for language
modelling is the Web 1T 5-gram corpus (Brants and
Franz, 2006). This data set, collected by Google
Inc., contains English word n-grams and their ob-
served frequency counts. Frequency counts are pro-
duced from this billion-token corpus of web text.
Because of the noise1 present in this corpus there is
an ongoing debate in the scientific community of the
use of this corpus for serious language modelling.

The Gigaword Corpus (Graff and Cieri, 2003)
is a large body of newswire text. The corpus con-
tains 1.6 · 109 tokens, however fluent newswire text
is not necessarily of the same domain as disfluency
removed speech.

The Fisher corpora Part I (David et al., 2004) and
Part II (David et al., 2005) are large bodies of tran-
scribed text. Unlike Switchboard there is no disflu-
ency annotation available for Fisher. Together the
two Fisher corpora consist of 2.2 · 107 tokens.

7 Features

The log-linear reranker, which rescores the 25-best
lists produced by the noisy-channel model, can
also include additional features besides the noisy-
channel log probabilities. As we show below, these
additional features can make a substantial improve-
ment to disfluency detection performance. Our
reranker incorporates two kinds of features. The first

1We do not mean speech disfluencies here, but noise in web-
text; web-text is often poorly written and unedited text.

are log-probabilities of various scores computed by
the noisy-channel model and the external language
models. We only include features which occur at
least 5 times in our training data.

The noisy channel and language model features
consist of:

1. LMP: 4 features indicating the probabilities of
the underlying fluent sentences under the lan-
guage models, as discussed in the previous sec-
tion.

2. NCLogP: The Log Probability of the entire
noisy channel model. Since by itself the noisy
channel model is already doing a very good job,
we do not want this information to be lost.

3. LogFom: This feature is the log of the “fig-
ure of merit” used to guide search in the noisy
channel model when it is producing the 25-best
list for the reranker. The log figure of merit is
the sum of the log language model probability
and the log channel model probability plus 1.5
times the number of edits in the sentence. This
feature is redundant, i.e., it is a linear combina-
tion of other features available to the reranker
model: we include it here so the reranker has
direct access to all of the features used by the
noisy channel model.

4. NCTransOdd: We include as a feature parts of
the noisy channel model itself, i.e. the channel
model probability. We do this so that the task
to choosing appropriate weights of the channel
model and language model can be moved from
the noisy channel model to the log-linear opti-
misation algorithm.

The boolean indicator features consist of the fol-
lowing 3 groups of features operating on words and
their edit status; the latter indicated by one of three
possible flags: when the word is not part of a dis-
fluency or E when it is part of the reparandum or I
when it is part of the interregnum.

1. CopyFlags X Y: When there is an exact copy
in the input text of length X (1 ≤ X ≤ 3) and
the gap between the copies is Y (0 ≤ Y ≤ 3)
this feature is the sequence of flags covering the
two copies. Example: CopyFlags 1 0 (E707



) records a feature when two identical words
are present, directly consecutive and the first
one is part of a disfluency (Edited) while the
second one is not. There are 745 different in-
stances of these features.

2. WordsFlags L n R: This feature records the
immediate area around an n-gram (n ≤ 3).
L denotes how many flags to the left and R
(0 ≤ R ≤ 1) how many to the right are includes
in this feature (Both L and R range over 0 and
1). Example: WordsFlags 1 1 0 (need
) is a feature that fires when a fluent word is

followed by the word ‘need’ (one flag to the
left, none to the right). There are 256808 of
these features present.

3. SentenceEdgeFlags B L: This feature indi-
cates the location of a disfluency in an ut-
terance. The Boolean B indicates whether
this features records sentence initial or sen-
tence final behaviour, L (1 ≤ L ≤ 3)
records the length of the flags. Example
SentenceEdgeFlags 1 1 (I) is a fea-
ture recording whether a sentence ends on an
interregnum. There are 22 of these features
present.

We give the following analysis as an example:

but E but that does n’t work

The language model features are the probability
calculated over the fluent part. NCLogP, Log-
Fom and NCTransOdd are present with their asso-
ciated value. The following binary flags are present:
CopyFlags 1 0 (E )
WordsFlags:0:1:0 (but E)
WordsFlags:0:1:0 (but )
WordsFlags:1:1:0 (E but )
WordsFlags:1:1:0 ( that )
WordsFlags:0:2:0 (but E but ) etc.2

SentenceEdgeFlags:0:1 (E)
SentenceEdgeFlags:0:2 (E )
SentenceEdgeFlags:0:3 (E )

These three kinds of boolean indicator features to-
gether constitute the extended feature set.

2An exhaustive list here would be too verbose.

8 Loss functions for reranker training

We formalise the reranker training procedure as fol-
lows. We are given a training corpus T containing
information about n possibly disfluent sentences.
For the ith sentence T specifies the sequence of
words xi, a set Yi of 25-best candidate “edited” la-
bellings produced by the noisy channel model, as
well as the correct “edited” labelling y⋆i ∈ Yi.

3

We are also given a vector f = (f1, . . . , fm)
of feature functions, where each fj maps a word
sequence x and an “edit” labelling y for x to a
real value fj(x, y). Abusing notation somewhat,
we write f(x, y) = (f1(x, y), . . . , fm(x, y)). We
interpret a vector w = (w1, . . . , wm) of feature
weights as defining a conditional probability distri-
bution over a candidate set Y of “edited” labellings
for a string x as follows:

Pw(y | x,Y) =
exp(w · f(x, y))

∑
y′∈Y exp(w · f(x, y

′))

We estimate the feature weights w from the train-
ing data T by finding a feature weight vector ŵ that
optimises a regularised objective function:

ŵ = argmin
w

LT (w) + α
m∑

j=1

w2j

Here α is the regulariser weight and LT is a loss
function. We investigate two different loss functions
in this paper. LogLoss is the negative log conditional
likelihood of the training data:

LogLossT (w) =
m∑

i=1

− log P(y⋆i | xi,Yi)

Optimising LogLoss finds the ŵ that define (regu-
larised) conditional Maximum Entropy models.

It turns out that optimising LogLoss yields sub-
optimal weight vectors ŵ here. LogLoss is a sym-
metric loss function (i.e., each mistake is equally
weighted), while our f-score evaluation metric
weights “edited” labels more highly, as explained
in section 4. Because our data is so skewed (i.e.,
“edited” words are comparatively infrequent), we

3In the situation where the true “edited” labelling does not
appear in the 25-best list Yi produced by the noisy-channel
model, we choose y⋆i to be a labelling in Yi closest to the true
labelling.708



can improve performance by using an asymmetric
loss function.

Inspired by our evaluation metric, we devised an
approximate expected f-score loss function FLoss .

FLossT (w) = 1 −
2Ew[c]

g + Ew[e]

This approximation assumes that the expectations
approximately distribute over the division: see Jan-
sche (2005) and Smith and Eisner (2006) for other
approximations to expected f-score and methods for
optimising them. We experimented with other asym-
metric loss functions (e.g., the expected error rate)
and found that they gave very similar results.

An advantage of FLoss is that it and its deriva-
tives with respect to w (which are required for
numerical optimisation) are easy to calculate ex-
actly. For example, the expected number of correct
“edited” words is:

Ew[c] =
n∑

i=1

Ew[cy⋆
i
| Yi], where:

Ew[cy⋆
i
| Yi] =

∑

y∈Yi

cy⋆
i
(y) Pw(y | xi,Yi)

and cy⋆(y) is the number of correct “edited” labels
in y given the gold labelling y⋆. The derivatives of
FLoss are:
∂FLossT

∂wj
(w) =

1

g + Ew[e]

(

FLossT (w)
∂Ew[e]

∂wj
− 2

∂Ew[c]

∂wj

)

where:

∂Ew[c]

∂wj
=

n∑

i=1

∂Ew[cy⋆
i
| xi,Yi]

∂wj

∂Ew[cy⋆ | x,Y]

∂wj
=

Ew[fjcy⋆ | x,Y] − Ew[fj | x,Y] Ew[cy⋆ | x,Y].

∂E[e]/∂wj is given by a similar formula.

9 Results

We follow Charniak and Johnson (2001) and split
the corpus into main training data, held-out train-
ing data and test data as follows: main training con-
sisted of all sw[23]∗.dps files, held-out training con-
sisted of all sw4[5-9]∗.dps files and test consisted of

all sw4[0-1]∗.dps files. However, we follow (John-
son and Charniak, 2004) in deleting all partial words
and punctuation from the training and test data (they
argued that this is more realistic in a speech process-
ing application).

Table 1 shows the results for the different models
on held-out data. To avoid over-fitting on the test
data, we present the f-scores over held-out training
data instead of test data. We used the held-out data
to select the best-performing set of reranker features,
which consisted of features for all of the language
models plus the extended (i.e., indicator) features,
and used this model to analyse the test data. The f-
score of this model on test data was 0.838. In this
table, the set of Extended Features is defined as all
the boolean features as described in Section 7.

We first observe that adding different external lan-
guage models does increase the final score. The
difference between the external language models is
relatively small, although the differences in choice
are several orders of magnitude. Despite the pu-
tative noise in the corpus, a language model built
on Google’s Web1T data seems to perform very
well. Only the model where Switchboard 4-grams
are used scores slightly lower, we explain this be-
cause the internal bigram model of the noisy chan-
nel model is already trained on Switchboard and so
this model adds less new information to the reranker
than the other models do.

Including additional features to describe the prob-
lem space is very productive. Indeed the best per-
forming model is the model which has all extended
features and all language model features. The dif-
ferences among the different language models when
extended features are present are relatively small.
We assume that much of the information expressed
in the language models overlaps with the lexical fea-
tures.

We find that using a loss function related to our
evaluation metric, rather than optimising LogLoss ,
consistently improves edit-word f-score. The stan-
dard LogLoss function, which estimates the “max-
imum entropy” model, consistently performs worse
than the loss function minimising expected errors.

The best performing model (Base + Ext. Feat.
+ All LM, using expected f-score loss) scores an f-
score of 0.838 on test data. The results as indicated
by the f-score outperform state-of-the-art models re-709



Model F-score
Base (noisy channel, no reranking) 0.756
Model log loss expected f-score loss
Base + Switchboard 0.776 0.791
Base + Fisher 0.771 0.797
Base + Gigaword 0.777 0.797
Base + Web1T 0.781 0.798
Base + Ext. Feat. 0.824 0.827
Base + Ext. Feat. + Switchboard 0.827 0.828
Base + Ext. Feat. + Fisher 0.841 0.856
Base + Ext. Feat. + Gigaword 0.843 0.852
Base + Ext. Feat. + Web1T 0.843 0.850
Base + Ext. Feat. + All LM 0.841 0.857

Table 1: Edited word detection f-score on held-out data for a variety of language models and loss functions

ported in literature operating on identical data, even
though we use vastly less features than other do.

10 Conclusion and Future work

We have described a disfluency detection algorithm
which we believe improves upon current state-of-
the-art competitors. This model is based on a noisy
channel model which scores putative analyses with
a language model; its channel model is inspired by
the observation that reparandum and repair are of-
ten very similar. As Johnson and Charniak (2004)
noted, although this model performs well, a log-
linear reranker can be used to increase performance.

We built language models from a variety of
speech and non-speech corpora, and examine the ef-
fect they have on disfluency detection. We use lan-
guage models derived from different larger corpora
effectively in a maximum reranker setting. We show
that the actual choice for a language model seems
to be less relevant and newswire text can be used
equally well for modelling fluent speech.

We describe different features to improve disflu-
ency detection even further. Especially these fea-
tures seem to boost performance significantly.

Finally we investigate the effect of different loss
functions. We observe that using a loss function di-
rectly optimising our interest yields a performance
increase which is at least at large as the effect of us-
ing very large language models.

We obtained an f-score which outperforms other
models reported in literature operating on identical

data, even though we use vastly fewer features than
others do.

Acknowledgements

This work was supported was supported under Aus-
tralian Research Council’s Discovery Projects fund-
ing scheme (project number DP110102593) and
by the Australian Research Council as part of the
Thinking Head Project the Thinking Head Project,
ARC/NHMRC Special Research Initiative Grant #
TS0669874. We thank the anonymous reviewers for
their helpful comments.

References

Thorsten Brants and Alex Franz. 2006. Web 1T 5-gram
Version 1. Published by Linguistic Data Consortium,
Philadelphia.

Erik Brill and Michele Banko. 2001. Mitigating the
Paucity-of-Data Problem: Exploring the Effect of
Training Corpus Size on Classifier Performance for
Natural Language Processing. In Proceedings of the
First International Conference on Human Language
Technology Research.

Eugene Charniak and Mark Johnson. 2001. Edit detec-
tion and parsing for transcribed speech. In Proceed-
ings of the 2nd Meeting of the North American Chap-
ter of the Association for Computational Linguistics,
pages 118–126.

Christopher Cieri David, David Miller, and Kevin
Walker. 2004. Fisher English Training Speech Part
1 Transcripts. Published by Linguistic Data Consor-
tium, Philadelphia.710



Christopher Cieri David, David Miller, and Kevin
Walker. 2005. Fisher English Training Speech Part
2 Transcripts. Published by Linguistic Data Consor-
tium, Philadelphia.

John J. Godfrey and Edward Holliman. 1997.
Switchboard-1 Release 2. Published by Linguistic
Data Consortium, Philadelphia.

David Graff and Christopher Cieri. 2003. English gi-
gaword. Published by Linguistic Data Consortium,
Philadelphia.

Martin Jansche. 2005. Maximum Expected F-Measure
Training of Logistic Regression Models. In Proceed-
ings of Human Language Technology Conference and
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 692–699, Vancouver, British
Columbia, Canada, October. Association for Compu-
tational Linguistics.

Mark Johnson and Eugene Charniak. 2004. A TAG-
based noisy channel model of speech repairs. In Pro-
ceedings of the 42nd Annual Meeting of the Associa-
tion for Computational Linguistics, pages 33–39.

Mark Johnson, Eugene Charniak, and Matthew Lease.
2004. An Improved Model for Recognizing Disfluen-
cies in Conversational Speech. In Proceedings of the
Rich Transcription Fall Workshop.

Jeremy G. Kahn, Matthew Lease, Eugene Charniak,
Mark Johnson, and Mari Ostendorf. 2005. Effective
Use of Prosody in Parsing Conversational Speech. In
Proceedings of Human Language Technology Confer-
ence and Conference on Empirical Methods in Natu-
ral Language Processing, pages 233–240, Vancouver,
British Columbia, Canada.

Reinhard Kneser and Hermann Ney. 1995. Improved
backing-off for m-gram language modeling. In Pro-
ceedings of the IEEE International Conference on
Acoustics, Speech, and Signal Processing, pages 181–
184.

Mitchell P. Marcus, Beatrice Santorini, Mary Ann
Marcinkiewicz, and Ann Taylor. 1999. Treebank-3.
Published by Linguistic Data Consortium, Philadel-
phia.

William Schuler, Samir AbdelRahman, Tim Miller, and
Lane Schwartz. 2010. Broad-Coverage Parsing us-
ing Human-Like Memory Constraints. Computational
Linguistics, 36(1):1–30.

Richard Schwartz, Long Nguyen, Francis Kubala,
George Chou, George Zavaliagkos, and John
Makhoul. 1994. On Using Written Language
Training Data for Spoken Language Modeling. In
Proceedings of the Human Language Technology
Workshop, pages 94–98.

Elizabeth Shriberg and Andreas Stolcke. 1998. How
far do speakers back up in repairs? A quantitative

model. In Proceedings of the International Confer-
ence on Spoken Language Processing, pages 2183–
2186.

Elizabeth Shriberg. 1994. Preliminaries to a Theory of
Speech Disuencies. Ph.D. thesis, University of Cali-
fornia, Berkeley.

David A. Smith and Jason Eisner. 2006. Minimum Risk
Annealing for Training Log-Linear Models. In Pro-
ceedings of the 21st International Conference on Com-
putational Linguistics and the 44th annual meeting of
the Association for Computational Linguistics, pages
787–794.

Matthew Snover, Bonnie Dorr, and Richard Schwartz.
2004. A Lexically-Driven Algorithm for Disfluency
Detection. In Proceedings of Human Language Tech-
nologies and North American Association for Compu-
tational Linguistics, pages 157–160.

Andreas Stolcke. 2002. SRILM - An Extensible Lan-
guage Modeling Toolkit. In Proceedings of the Inter-
national Conference on Spoken Language Processing,
pages 901–904.

Qi Zhang, Fuliang Weng, and Zhe Feng. 2006. A pro-
gressive feature selection algorithm for ultra large fea-
ture spaces. In Proceedings of the 21st International
Conference on Computational Linguistics and the 44th
annual meeting of the Association for Computational
Linguistics, pages 561–568.

711


