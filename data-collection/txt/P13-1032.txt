



















































Advancements in Reordering Models for Statistical Machine Translation


Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 322–332,
Sofia, Bulgaria, August 4-9 2013. c©2013 Association for Computational Linguistics

Advancements in Reordering Models for Statistical Machine Translation

Minwei Feng and Jan-Thorsten Peter and Hermann Ney
Human Language Technology and Pattern Recognition

Computer Science Department, RWTH Aachen University, Aachen, Germany
<surname>@cs.rwth-aachen.de

Abstract
In this paper, we propose a novel re-
ordering model based on sequence label-
ing techniques. Our model converts the
reordering problem into a sequence label-
ing problem, i.e. a tagging task. Results
on five Chinese-English NIST tasks show
that our model improves the baseline sys-
tem by 1.32 BLEU and 1.53 TER on av-
erage. Results of comparative study with
other seven widely used reordering mod-
els will also be reported.

1 Introduction

The systematic word order difference between two
languages poses a challenge for current statistical
machine translation (SMT) systems. The system
has to decide in which order to translate the given
source words. This problem is known as the re-
ordering problem. As shown in (Knight, 1999), if
arbitrary reordering is allowed, the search problem
is NP-hard.

Many ideas have been proposed to address
the reordering problem. Within the phrase-based
SMT framework there are mainly three stages
where improved reordering could be integrated:
In the preprocessing: the source sentence is re-
ordered by heuristics, so that the word order of
source and target sentences is similar. (Wang et
al., 2007) use manually designed rules to reorder
parse trees of the source sentences. Based on shal-
low syntax, (Zhang et al., 2007) use rules to re-
order the source sentences on the chunk level and
provide a source-reordering lattice instead of a sin-
gle reordered source sentence as input to the SMT
system. Designing rules to reorder the source sen-
tence is conceptually clear and usually easy to im-
plement. In this way, syntax information can be in-
corporated into phrase-based SMT systems. How-
ever, one disadvantage is that the reliability of the
rules is often language pair dependent.

In the decoder: we can add constraints or mod-
els into the decoder to reward good reordering op-
tions or penalize bad ones. For reordering con-
straints, early work includes ITG constraints (Wu,
1995) and IBM constraints (Berger et al., 1996).
(Zens and Ney, 2003) did comparative study over
different reordering constraints. This paper fo-
cuses on reordering models. For reordering mod-
els, we can further roughly divide the existing
methods into three genres:
• The reordering is a classification problem.

The classifier will make decision on next
phrase’s relative position with current phrase.
The classifier can be trained with maximum
likelihood like Moses lexicalized reordering
(Koehn et al., 2007) and hierarchical lexical-
ized reordering model (Galley and Manning,
2008) or be trained under maximum entropy
framework (Zens and Ney, 2006).
• The reordering is a decoding order problem.

(Mariño et al., 2006) present a translation
model that constitutes a language model of
a sort of bilanguage composed of bilingual
units. From the reordering point of view, the
idea is that the correct reordering is a suit-
able order of translation units. (Feng et al.,
2010) present a simpler version of (Mariño et
al., 2006)’s model which utilize only source
words to model the decoding order.
• The reordering can be solved by outside

heuristics. We can put human knowledge into
the decoder. For example, the simple jump
model using linear distance tells the decoder
that usually the long range reordering should
be avoided. (Cherry, 2008) uses information
from dependency trees to make the decod-
ing process keep syntactic cohesion. (Feng
et al., 2012) present a method that utilizes
predicate-argument structures from semantic
role labeling results as soft constraints.

In the reranking framework: in principle, all

322



the models in previous category can be used in
the reranking framework, because in the rerank-
ing we have all the information (source and tar-
get words/phrases, alignment) about the transla-
tion process. (Och et al., 2004) describe the use of
syntactic features in the rescoring step. However,
they report the syntactic features contribute very
small gains. One disadvantage of carrying out re-
ordering in reranking is the representativeness of
the N-best list is often a question mark.

In this paper, we propose a novel tagging style
reordering model which is under the category
“The reordering is a decoding order problem”.
Our model converts the decoding order problem
into a sequence labeling problem, i.e. a tagging
task. The remainder of this paper is organized
as follows: Section 2 introduces the basement
of this research: the principle of statistical ma-
chine translation. Section 3 describes the proposed
model. Section 4 briefly describes several reorder-
ing models with which we compare our method.
Section 5 provides the experimental configuration
and results. Conclusion will be given in Section 6.

2 Translation System Overview

In statistical machine translation, we are given a
source language sentence fJ1 = f1 . . . fj . . . fJ .
The objective is to translate the source into a tar-
get language sentence eI1 = e1 . . . ei . . . eI . The
strategy is to choose the target sentence with the
highest probability among all others:

êÎi = argmax
I,eI1

{Pr(eI1|fJ1 )} (1)

We model Pr(eI1|fJ1 ) directly using a log-linear
combination of several models (Och and Ney,
2002):

Pr(eI1|fJ1 ) =
exp

( M∑
m=1

λmhm(e
I
1, f

J
1 )
)

∑

I′ ,e′
I
′

1

exp
( M∑
m=1

λmhm(e
′I′

1 , f
J
1 )
)

(2)
The denominator is to make the Pr(eI1|fJ1 ) to be a
probability distribution and it depends only on the
source sentence fJ1 . For search, the decision rule
is simply:

êÎi = argmax
I,eI1

{ M∑

m=1

λmhm(e
I
1, f

J
1 )
}

(3)

The model scaling factors λM1 are trained with
Minimum Error Rate Training (MERT). In this pa-
per, the phrase-based machine translation system

is utilized (Och et al., 1999; Zens et al., 2002;
Koehn et al., 2003).

3 Tagging-style Reordering Model

In this section, we describe the proposed novel
model. First we will describe the training process.
Then we explain how to use the model in the de-
coder.

3.1 Modeling

Figure 1 shows the modeling steps. The first step
is word alignment training. Figure 1(a) is an ex-
ample after GIZA++ training. If we regard this
alignment as a translation result, i.e. given the
source sentence f71 , the system translates it into
the target sentence e71, then the alignment link set
{a1 = 3, a3 = 2, a4 = 4, a4 = 5, a5 = 7, a6 =
6, a7 = 6} reveals the decoding process, i.e. the
alignment implies the order in which the source
words should be translated, e.g. the first generated
target word e1 has no alignment, we can regard it
as a translation from a NULL source word; then
the second generated target word e2 is translated
from f3. We reorder the source side of the align-
ment to get Figure 1(b). Figure 1(b) implies the
source sentence decoding sequence information,
which is depicted in Figure 1(c). Using this ex-
ample we describe the strategies we used for spe-
cial cases in the transformation from Figure 1(b)
to Figure 1(c):
• ignore the unaligned target word, e.g. e1
• the unaligned source word should follow its

preceding word, the unaligned feature is kept
with a ∗ symbol, e.g. f∗2 is after f1
• when one source word is aligned to multi-

ple target words, only keep the alignment that
links the source word to the first target word,
e.g. f4 is linked to e5 and e6, only f4 − e5
is kept. In other words, we use this strategy
to guarantee that every source word appears
only once in the source decoding sequence.

• when multiple source words are aligned to
one target word, put together the source
words according to their original relative po-
sitions, e.g. e6 is linked to f6 and f7. So in
the decoding sequence, f6 is before f7.

Now Figure 1(c) shows the original source sen-
tence and its decoding sequence. By using the
strategies above, it is guaranteed that the source
sentence and its decoding sequence have the ex-

323



f1 f2 f3 f4 f5 f6 f7

e1 e2 e3 e4 e5 e6 e7

(a)

f3 f1 f2 f4 f6 f7 f5

e1 e2 e3 e4 e5 e6 e7

(b)

f1 f
∗
2 f3 f4 f5 f6 f7

f3 f1 f2 f4 f6 f7 f5

(c)

f1 f
∗
2 f3 f4 f5 f6 f7

+1 +1 −2 0 +2 −1 −1

(d)
BEGIN-Rmono Unalign Lreorder-Rmono Lmono-Rmono Lmono-Rreorder Lreorder-Rmono END-Lmono

f1 f
∗
2 f3 f4 f5 f6 f7

(e)
Figure 1: modeling process illustration.

actly same length. Hence the relation can be mod-
eled by a function F (f) which assigns a value for
each source word f . Figure 1(d) manifests this
function. The positive function values mean that
compared to the original position in the source
sentence, its position in the decoding sequence
should move rightwards. If the function value is
0, the word’s position in original source sentence
and its decoding sequence is same. For example,
f1 is the first word in the source sentence but it is
the second word in the decoding sequence. So its
function value is +1 (move rightwards one posi-
tion).

Now Figure 1(d) converts the reordering prob-
lem into a sequence labeling or tagging problem.
To make the computational cost to a reasonable
level, we do a final step simplification in Figure
1(e). Suppose the longest sentence length is 100,
then according to Figure 1(d), there are 200 tags
(from -99 to +99 plus the unalign tag). As we will
see later, this number is too large for our task. We
instead design nine tags. For a source word fj in
one source sentence fJ1 , the tag of fj will be one
of the following:
Unalign fj is an unaligned source word
BEGIN-Rmono j = 1 and fj+1 is translated af-

ter fj (Rmono for right monotonic)
BEGIN-Rreorder j = 1 and fj+1 is translated

before fj (Rreorder for right reordered)
END-Lmono j = J and fj−1 translated before

fj (Lmono for left monotonic)
END-Lreorder j = J and fj−1 translated after

fj (Lreorder for left reordered)
Lmono-Rmono 1 < j < J and fj−1 translated

before fj and fj translated before fj+1
Lreorder-Rmono 1 < j < J and fj−1 translated

after fj and fj translated before fj+1
Lmono-Rreorder 1 < j < J and fj−1 translated

before fj and fj translated after fj+1
Lreorder-Rreorder 1 < j < J and fj−1 trans-

lated after fj and fj translated after fj+1
Up to this point, we have converted the reorder-

ing problem into a tagging problem with nine tags.
The transformation in Figure 1 is conducted for
all the sentence pairs in the bilingual training cor-
pus. After that, we have built an “annotated” cor-
pus for the training. For this supervised learning
task, we choose the approach conditional random
fields (CRFs) (Lafferty et al., 2001; Sutton and
Mccallum, 2006; Lavergne et al., 2010) and recur-
rent neural network (RNN) (Elman, 1990; Jordan,
1990; Lang et al., 1990).

For the first method, we adopt the linear-chain
CRFs. However, even for the simple linear-chain
CRFs, the complexity of learning and inference
grows quadratically with respect to the number of
output labels and the amount of structural features
which are with regard to adjacent pairs of labels.
Hence, to make the computational cost as low as
possible, two measures have been taken. Firstly,
as described above we reduce the number of tags
to nine. Secondly, we add source sentence part-of-
speech (POS) tags to the input. For features with
window size one to three, both source words and
its POS tags are used. For features with window
size four and five, only POS tags are used.

As the second method, we use recurrent neu-
ral network (RNN). RNN is closely related with
Multilayer Perceptrons (MLP) (Rumelhart et al.,
1986), but the output of one ore more hidden lay-
ers is reused as additional inputs for the network in
the next time step. This structure allows the RNN
to learn whole sequences without restricting itself
to a fixed input window. A plain RNN has only ac-
cess to the previous events in the input sequence.
Hence we adopt the bidirectional RNN (BRNN)
(Schuster and Paliwal, 1997) which reads the input
sequence from both directions before making the
prediction. The long short-term memory (LSTM)
(Hochreiter and Schmidhuber, 1997) is applied to

324



counter the effects that long distance dependen-
cies are hard to learn with gradient descent. This
is often referred to as vanishing gradient problem
(Bengio et al., 1994).

3.2 Decoding

Once the model training is finished, we make in-
ference on develop and test corpora which means
that we get the labels of the source sentences that
need to be translated. In the decoder, we add
a new model which checks the labeling consis-
tency when scoring an extended state. During
the search, a sentence pair (fJ1 , e

I
1) will be for-

mally splitted into a segmentation SK1 which con-
sists of K phrase pairs. Each sk = (ik; bk, jk)
is a triple consisting of the last position ik of
the kth target phrase ẽk. The start and end po-
sition of the kth source phrase f̃k are bk and jk.
Suppose the search state is now extended with a
new phrase pair (f̃k, ẽk): f̃k := fbk . . . fjk and
ẽk := eik−1+1 . . . eik . We have access to the
old coverage vector, from which we know if the
new phrase’s left neighboring source word fbk−1
and right neighboring source word fjk+1 have
been translated. We also have the word alignment
within the new phrase pair, which is stored dur-
ing the phrase extraction process. Based on the
old coverage vector and alignment, we can repeat
the transformation in Figure 1 to calculate the la-
bels for the new phrase. The added model will
then check the consistence between the calculated
labels and the labels predicted by the reordering
model. The number of source words that have in-
consistent labels is the penalty and is then added
into the log-linear framework as a new feature.

4 Comparative Study

The second part of this paper is comparative study
on reordering models. Here we briefly describe
those models which will be compared to later.

4.1 Moses lexicalized reordering model

A B

Figure 2: lexicalized reordering model illustration.

Moses (Koehn et al., 2007) contains a word-
based orientation model, which has three types of
reordering: (m) monotone order, (s) switch with
previous phrase and (d) discontinuous. Figure 2
is an example. The definitions of reordering types
are as follows:

monotone for current phrase, if a word alignment
to the bottom left (point A) exists and there is no
word alignment point at the bottom right position
(point B) .
swap for current phrase, if a word alignment to
the bottom right (point B) exists and there is no
word alignment point at the bottom left position
(point A) .
discontinuous all other cases

Our implementation is same with the default
behavior of Moses lexicalized reordering model.
We count how often each extracted phrase pair is
found with each of the three reordering types. The
add-0.5 smoothing is then applied. Finally, the
probability is estimated with maximum likelihood
principle.

4.2 Maximum entropy reordering model

Figure 3 is an illustration of (Zens and Ney, 2006) .
j is the source word position which is aligned to
the last target word of the current phrase. j

′
is

the last source word position of the current phrase.
j
′′

is the source word position which is aligned to
the first target word position of the next phrase.
(Zens and Ney, 2006) proposed a maximum en-
tropy classifier to predict the orientation of the
next phrase given the current phrase. The orien-
tation class cj,j′ ,j′′ is defined as:

cj,j′ ,j′′=





left, if j
′′
<j

right, if j
′′
>j and j′′ − j′>1

monotone, if j
′′
>j and j′′ − j′=1

(4)
The orientation probability is modeled in a log-
linear framework using a set of N feature func-
tions hn(fJ1 , e

I
1, i, j, cj,j′ ,j′′ ), n = 1, . . . , N . The

whole model is:
pλN1

(cj,j′ ,j′′ |fJ1 , eI1, i, j)

=
exp(

N∑
n=1

λnhn(fJ1 ,e
I
1,i,j,cj,j′ ,j′′ ))

∑

c
′
exp(

N∑
n=1

λnhn(fJ1 ,e
I
1,i,j,c

′ ))

(5)

Different features can be used, we use the source
and target word features to train the model.

325



Figure 3: phrase orientation: left, right and monotone. j is the source word position aligned to the last target word of current
phrase. j

′
is the last source word position of current phrase. j

′′
is the source word position aligned to the first target word

position of the next phrase.

f1 f2 f3 f4 f5 f6 f7

e1 e2 e3 e4 e5 e6 e7

Figure 4: bilingual LM illustration. The bilingual sequence
is e1 , e2 f3 , e3 f1 , e4 f4 , e5 f4 , e6 f6 f7 , e7 f5 .

4.3 Bilingual LM

The previous two models belong to “The reorder-
ing is a classification problem”. Now we turn
to “The reordering is a decoding order problem”.
(Mariño et al., 2006) implement a translation
model using n-grams. In this way, the translation
system can take full advantage of the smoothing
and consistency provided by standard back-off n-
gram models. Figure 4 is an example. The in-
terpretation is that given the sentence pair (f71 , e

7
1)

and its alignment, the correct translation order is
e1 , e2 f3 , e3 f1 , e4 f4 , e5 f4 , e6 f6 f7 , e7 f5 .
Notice the bilingual units have been ordered ac-
cording to the target side, as the decoder writes
the translation in a left-to-right way. Using the ex-
ample we describe the strategies used for special
cases:
• keep the unaligned target word, e.g. e1
• remove the unaligned source word, e.g. f2
• when one source word aligned to multiple

target words, duplicate the source word for
each target word, e.g. e4 f4 , e5 f4
• when multiple source words aligned to one

target word, put together the source words for
that target word, e.g. e6 f6 f7

After the operation in Figure 4 was done for
all bilingual sentence pairs, we get a decoding
sequence corpus. We build a 9-gram LM us-
ing SRILM toolkit (Stolcke, 2002) with modified
Kneser-Ney smoothing.

The model is added as an additional feature in
Equation (2). To use the bilingual LM, the search
state must be augmented to keep the bilingual unit

decoding sequence. In search, the bilingual LM
is applied similar to the standard target side LM.
The bilingual sequence of phrase pairs will be ex-
tracted using the same strategy in Figure 4 . Sup-
pose the search state is now extended with a new
phrase pair (f̃ , ẽ). F̃ is the bilingual sequence for
the new phrase pair (f̃ , ẽ) and F̃ i is the ith unit
within F̃ . F̃

′
is the bilingual sequence history

for current state. We compute the feature score
hbilm(F̃ , F̃

′
) of the extended state as follows:

hbilm(F̃ , F̃
′
)=λ ·

|F̃ |∑

i=1

log p(F̃ i|F̃ ′ , F̃ 1, · · · , F̃ i−1)

(6)
λ is the scaling factor for this model. |F̃ | is the
length of the bilingual decoding sequence.

4.4 Source decoding sequence LM

(Feng et al., 2010) present an simpler version of
the above bilingual LM where they use only the
source side to model the decoding order. The
source word decoding sequence in Figure 4 is then
f3 , f1 , f2 , f4 , f6 , f7 , f5 . We also build a 9-gram
LM based on the source word decoding sequences.
The usage of the model is same as bilingual LM.

4.5 Syntactic cohesion model

The previous two models belong to “The reorder-
ing is a decoding order problem”. Now we turn to
“The reordering can be solved by outside heuris-
tics”. (Cherry, 2008) proposed a syntactic cohe-
sion model. The core idea is that the syntactic
structure of the source sentence should be pre-
served during translation. This structure is repre-
sented by a source sentence dependency tree. The
algorithm is as follows: given the source sentence
and its dependency tree, during the translation pro-
cess, once a hypothesis is extended, check if the
source dependency tree contains a subtree T such
that:

326



• Its translation is already started (at least one
node is covered)
• It is interrupted by the new added phrase (at

least one word in the new source phrase is not
in T )
• It is not finished (after the new phrase is

added, there is still at least one free node in
T )

If so, we say this hypothesis violates the subtree
T , and the model returns the number of subtrees
that this hypothesis violates.

4.6 Semantic cohesion model

(Feng et al., 2012) propose two structure features
from semantic role labeling (SRL) results. Simi-
lar to the previous model, the SRL information is
used as soft constraints. During decoding process,
the first feature will report how many event layers
that one search state violates and the second fea-
ture will report the amount of semantic roles that
one search state violates. In this paper, the two
features have been used together. So when the se-
mantic cohesion model is used, both features will
be triggered.

4.7 Tree-based jump model

(Wang et al., 2007) present a pre-reordering
method for Chinese-English translation task. In
Section 3.6 of (Zhang, 2013), instead of doing
hard reordering decision, the author uses the rules
as soft constraints in the decoder. In this paper,
we use the similar method as described in (Zhang,
2013). Our strategy is: firstly, we parse the source
sentences to get constituency trees. Then we ma-
nipulate the trees using heuristics described by
(Wang et al., 2007) . The leaf nodes in the revised
tree constitute the reordered source sentence. Fi-
nally, in the log-linear framework (Equation 2) a
new jump model is added which uses the reordered
source sentence to calculate the cost. For example,
the original sentence f1f2f3f4f5 is now converted
by rules into the new sentence f1f5f3f2f4 . For
decoding, we still use the original sentence. Sup-
pose previously translated source phrase is f1 and
the current phrase is f5 . Then the standard jump
model gives cost qDist = 4 and the new tree-based
jump model will return a cost qDist new = 1 .

5 Experiments

In this section, we describe the baseline setup, the
CRFs training results, the RNN training results

and translation experimental results.

5.1 Experimental Setup
Our baseline is a phrase-based decoder, which in-
cludes the following models: an n-gram target-
side language model (LM), a phrase translation
model and a word-based lexicon model. The latter
two models are used for both directions: p(f |e)
and p(e|f). Additionally we use phrase count
features, word and phrase penalty. The reorder-
ing model for the baseline system is the distance-
based jump model which uses linear distance.
This model does not have hard limit. We list the
important information regarding the experimental
setup below. All those conditions have been kept
same in this work.
• lowercased training data from the GALE task

(Table 1, UN corpus not included)
alignment trained with GIZA++
• tuning corpus: NIST06

test corpora: NIST02 03 04 05 and 08
• 5-gram LM (1 694 412 027 running words)

trained by SRILM toolkit (Stolcke, 2002)
with modified Kneser-Ney smoothing
training data: target side of bilingual data.
• BLEU (Papineni et al., 2001) and TER

(Snover et al., 2005) reported
all scores calculated in lowercase way.
• Wapiti toolkit (Lavergne et al., 2010) used for

CRFs; RNN is built by the RNNLIB toolkit.

Chinese English
Sentences 5 384 856
Running Words 115 172 748 129 820 318
Vocabulary 1 125 437 739 251

Table 1: translation model and LM training data statistics

Table 1 contains the data statistics used for
translation model and LM. For the reordering
model, we take two further filtering steps. Firstly,
we delete the sentence pairs if the source sentence
length is one. When the source sentence has only
one word, the translation will be always mono-
tonic and the reordering model does not need to
learn this. Secondly, we delete the sentence pairs if
the source sentence contains more than three con-
tiguous unaligned words. When this happens, the
sentence pair is usually low quality hence not suit-
able for learning. The main purpose of the two
filtering steps is to further lay down the computa-
tional burden. The label distribution is depicted in
Figure 5. We can see that most words are mono-
tonic. We then divide the corpus to three parts:

327



0 0.5 1 1.5 2 2.5 3 3.5 4 4.5 5
·107

BEGIN-Rmono
BEGIN-Rreorder

END-Lmono
END-Lreorder

Lmono-Rmono
Lmono-Rreorder
Lreorder-Rmono

Lreorder-Rreorder
UNALIGN

Amount of Tags

Figure 5: Tags distribution illustration.

train, validation and test. The source side data
statistics for the reordering model training is given
in Table 2 (target side has only nine labels).

train validation test
Sentences 2 973 519 400 000 400 000
Running Words 62 263 295 8 370 361 8 382 086
Vocabulary 454 951 149686 150 007

Table 2: tagging-style model training data statistics

5.2 CRFs Training Results
The toolkit Wapiti (Lavergne et al., 2010) is used
in this paper. We choose the classical optimization
algorithm limited memory BFGS (L-BFGS) (Liu
and Nocedal, 1989). For regularization, Wapiti
uses both the `1 and `2 penalty terms, yielding the
elastic-net penalty of the form

ρ1· ‖ θ ‖1 +
ρ2
2
· ‖ θ ‖22 (7)

In this work, we use as many features as pos-
sible because `1 penalty ρ1 ‖ θ ‖1 is able to
yield sparse parameter vectors, i.e. using a `1

penalty term implicitly performs the feature selec-
tion. The computational costs are given here: on
a cluster with two AMD Opteron(tm) Processor
6176 (total 24 cores), the training time is about 16
hours, peak memory is around 120G. Several ex-
periments have been done to find the suitable hy-
perparameter ρ1 and ρ2, we choose the model with
lowest error rate on validation corpus for trans-
lation experiments. The error rate of the chosen
model on test corpus (the test corpus in Table 2)
is 25.75% for token error rate and 69.39% for se-
quence error rate. Table 3 is the feature template
we set initially which generates 722 999 637 fea-
tures. Some examples are given in Table 4. After
training 36 902 363 features are kept.

5.3 RNN Training Results
We also applied RNN to the task as an alternative
approach to CRFs. The here used RNN implemen-
tation is RNNLIB which has support for long short
term memory (LSTM) (Graves, 2008). We used
a one of k encoding for the input word and also
for the labels. After testing several configurations
over the validation corpus we used a network with

Feature Templates

1-gram source word features
x[-4,0], x[-3,0], x[-2,0], x[-1,0]

x[0,0], x[1,0], x[2,0], x[3,0], x[4,0]

1-gram source POS features
x[-4,1], x[-3,1], x[-2,1], x[-1,1]

x[0,1], x[1,1], x[2,1], x[3,1], x[4,1]

2-gram source word features
x[-1,0]/x[0,0], x[ 0,0]/x[1,0]
x[-1,1]/x[0,1], x[0,1]/x[1,1]

3-gram source word features
x[-1,0]/x[0,0]/x[1,0]
x[-2,0]/x[-1,0]/x[0,0]
x[0,0]/x[1,0]/x[2,0]

3-gram source POS features
x[0,1]/x[1,1]/x[2,1]

x[-2,1]/x[-1,1]/x[0,1]
x[-1,1]/x[0,1]/x[1,1]

4-gram source POS features
x[0,1]/x[1,1]/x[2,1]/x[3,1]

x[0,1]/x[-1,1]/x[-2,1]/x[-3,1]
x[-1,1]/x[0,1]/x[1,1]/x[2,1]
x[-2,1]/x[-1,1]/x[0,1]/x[1,1]

5-gram source POS features
x[0,1]/x[1,1]/x[2,1]/x[3,1]/x[4,1]

x[-4,1]/x[-3,1]/x[-2,1]/x[-1,1]/x[0,1]
x[-2,1]/x[-1,1]/x[0,1]/x[1,1]/x[2,1]

bigram output label feature
x[-1,2]/x[0,2]

Table 3: feature templates for CRFs training

Words POS Label

基于 P BEGIN-Rmono
这 DT Lmono-Rmono
种 M Lmono-Rmono
看法 NN Lmono-Rmono
, PU Lmono-Rmono
本人 PN Lmono-Rmono
是 VC UNALIGN � Current label
支持 VV Lmono-Rmono
修正案 NN Lmono-Rmono
的 DEC UNALIGN
。 PU END-Lmono

Table 4: feature examples. x[row,col] specifies a token in the
input data. row specfies the relative position from the cur-
rent label and col specifies the absolute position of the col-
umn. So for the current lable in this table, x[−1, 2]/x[0, 2]
is Lmono-Rmono/UNALIGN and x[−1, 1]/x[0, 1]/x[1, 1] is
PN/VC/VV.

LSTM 200 nodes in the hidden layer. The RNN
has a token error rate of 27.31% and a sentence
error rate of 77.00% over the test corpus in Ta-
ble 2. The RNN is trained on a similar computer
as above. RNNLIB utilizes only one thread. The
training time is about three and a half days and
peak memory consumption is 1G .

5.4 Comparison of CRFs and RNN errors

CRFs performs better than RNN (token error rate
25.75% vs 27.31%). Both error rate values are
much higher than what we usually see in part-of-
speech tagging task. The main reason is that the
“annotated” corpus is converted from word align-
ment which contains lots of error. However, as we

328



hhhhhhhhhhReference
Prediction Unalign BEGIN-Rm BEGIN-Rr END-Lm END-Lr Lm-Rm Lr-Rm Lm-Rr Lr-Rr

Unalign 687724 15084 850 7347 716 493984 107364 43457 9194
BEGIN-Rmono 3537 338315 6209 0 0 0 0 0 0
BEGIN-Rreorder 419 12557 17054 0 0 0 0 0 0
END-Lmono 1799 0 0 365635 3196 0 0 0 0
END-Lreorder 510 0 0 5239 7913 0 0 0 0
Lmomo-Rmono 188627 0 0 0 0 4032738 176682 150952 13114
Lreorder-Rmono 88177 0 0 0 0 369232 433027 27162 15275
Lmomo-Rreorder 32342 0 0 0 0 268570 24558 296033 10645
Lreorder-Rreorder 9865 0 0 0 0 34746 20382 16514 45342

Recall 50.36% 97.20% 56.79% 98.65% 57.92% 88.40% 46.42% 46.83% 35.74%
Precision 67.89% 92.45% 70.73% 96.67% 66.92% 77.56% 56.83% 55.42% 48.46%

Table 5: CRF Confusion Matrix. Abbreviations: Lmono(Lm) Lreorder(Lr) Rmono(Rm) Rreorder(Rr)
hhhhhhhhhhReference

Prediction Unalign BEGIN-Rm BEGIN-Rr END-Lm END-Lr Lm-Rm Lr-Rm Lm-Rr Lr-Rr

Unalign 589100 17299 901 7870 1000 639555 82413 24277 3305
BEGIN-Rmono 1978 339686 6397 0 0 0 0 0 0
BEGIN-Rreorder 186 13812 16032 0 0 0 0 0 0
END-Lmono 2258 0 0 364121 4251 0 0 0 0
END-Lreorde 699 0 0 4693 8269 1 0 0 0
Lmomo-Rmono 142777 1 0 0 0 4232113 105266 78692 3264
Lreorder-Rmono 96278 0 1 0 0 491989 323272 14635 6698
Lmomo-Rreorder 31118 0 0 0 0 380483 18144 198068 4335
Lreorder-Rreorder 12366 0 1 0 0 50121 25196 17008 22157

Recall 43.13% 97.59% 53.39% 98.24% 60.53% 92.77% 34.65% 31.33% 17.47%
Precision 67.19% 91.61% 68.71% 96.66% 61.16% 73.04% 58.32% 59.54% 55.73%

Table 6: RNN Confusion Matrix. Abbreviations: Lmono(Lm) Lreorder(Lr) Rmono(Rm) Rreorder(Rr)

will show later, the model trained with both CRFs
and RNN help to improve the translation quality.

Table 5 and Table 6 demonstrate the confusion
matrix of the CRFs and RNN errors over the test
corpus. The rows represent the correct tag that the
classifier should have predicted and the columns
are the actually predicted tags. E.g. the number
687724 in first row and first column of Table 5
tells that there are 687724 correctly labeled Un-
align tags. The number 15084 in first row and
second column of Table 5 represents that there are
15084 Unalign tags labeled incorrectly to Begin-
Rmono. Therefore, numbers on the diagonal from
the upper left to the lower right corner represent
the amount of correctly classified tags and all other
numbers show the amount of false labels. The
many zeros show that both classifier rarely make
mistake for the label “BEGIN-∗” which only oc-
cur at the beginning of a sentence. The same is
true for the “END-∗” labels.

5.5 Translation Results

Results are summarized in Table 7. Please read
the caption for the meaning of abbreviations. An
Index column is added for score reference conve-
nience (B for BLEU; T for TER). For the proposed
model, significance testing results on both BLEU
and TER are reported (B2 and B3 compared to B1,
T2 and T3 compared to T1). We perform bootstrap
resampling with bounds estimation as described
in (Koehn, 2004). The 95% confidence threshold

(denoted by ‡ in the table) is used to draw signifi-
cance conclusions. We add a column avg. to show
the average improvements.

From Table 7 we see that the proposed reorder-
ing model using CRFs improves the baseline by
0.98 BLEU and 1.21 TER on average, while the
proposed reordering model using RNN improves
the baseline by 1.32 BLEU and 1.53 TER on av-
erage. For line B2 B3 and T2 T3, most scores
are better than their corresponding baseline values
with more than 95% confidence. The results show
that our proposed idea improves the baseline sys-
tem and RNN trained model performs better than
CRFs trained model, in terms of both automatic
measure and significance test. To investigate why
RNN has lower performance for the tagging task
but achieves better BLEU, we build a 3-gram LM
on the source side of the training corpus in Table
2 and perplexity values are listed in Table 8. The
perplexity of the test corpus for reordering model
comparison is much lower than those NIST cor-
pora for translation experiments. In other words,
there exists mismatch of the data for reordering
model training and actual MT data. This could
explain why CRFs is superior to RNN for labeling
problem while RNN is better for MT tasks.

For the comparative study, the best method is
the tree-based jump model (JUMPTREE). Our
proposed model ranks the second position. The
difference is tiny: on average only 0.08 BLEU (B3
and B10) and 0.15 TER (T3 and T10). Even with

329



Systems NIST02 NIST03 NIST04 NIST05 NIST08 avg. Index

BLEU scores
baseline 33.60 34.29 35.73 32.15 26.34 - B1
baseline+CRFs 34.53 35.19 36.56‡ 33.30‡ 27.41‡ 0.98 B2
baseline+RNN 35.30‡ 35.34‡ 37.03‡ 33.80‡ 27.23‡ 1.32 B3
baseline+LRM 34.87 34.90 36.40 33.43 27.45 0.99 B4
baseline+MERO 34.91 34.83 36.29 33.69 26.66 0.85 B5
baseline+BILM 35.21 35.00 36.83 33.64 27.39 1.19 B6
baseline+SRCLM 34.55 34.52 36.18 32.84 27.03 0.50 B7
baseline+SRL 35.05 34.93 36.71 33.22 26.89 0.93 B8
baseline+SC 34.96 34.52 36.37 33.35 26.90 0.79 B9
baseline+JUMPTREE 35.10 35.53 37.12 34.18 27.19 1.40 B10
baseline+LRM+MERO+BILM+SRCLM+SRL+SC+JUMPTREE 36.77 36.16 38.10 35.67 28.52 2.62 B11
baseline+LRM+MERO+BILM+SRCLM+SRL+SC+JUMPTREE+RNN 36.99 37.00 38.79 35.86 28.99 3.10 B12

TER scores
baseline 61.36 60.48 59.12 60.94 65.17 - T1
baseline+CRFs 60.14‡ 58.91‡ 57.91‡ 59.77‡ 64.30‡ 1.21 T2
baseline+RNN 59.38‡ 58.87‡ 57.60‡ 59.56‡ 63.99‡ 1.53 T3
baseline+LRM 60.07 59.08 58.42 59.74 64.50 1.05 T4
baseline+MERO 60.19 59.58 58.51 59.49 64.68 0.92 T5
baseline+BILM 60.23 59.93 58.59 60.09 64.72 0.70 T6
baseline+SRCLM 60.27 59.55 58.40 60.16 64.61 0.82 T7
baseline+SRL 60.05 59.55 58.14 59.69 64.74 0.98 T8
baseline+SC 59.90 59.37 58.27 59.69 64.44 1.08 T9
baseline+JUMPTREE 59.53 58.54 57.67 58.90 64.04 1.68 T10
baseline+LRM+MERO+BILM+SRCLM+SRL+SC+JUMPTREE 59.16 57.84 56.83 58.03 63.20 2.40 T11
baseline+LRM+MERO+BILM+SRCLM+SRL+SC+JUMPTREE+RNN 58.67 57.67 56.27 58.00 63.09 2.67 T12

Table 7: Experimental results. CRFs and RNN mean the tagging-style model trained with CRFs or RNN; LRM for lexicalized
reordering model (Koehn et al., 2007) ; MERO for maximum entropy reordering model (Zens and Ney, 2006) ; BILM for
bilingual language model (Mariño et al., 2006) and SRCLM for its simpler version source decoding sequence model (Feng et
al., 2010) ; SC for syntactic cohesion model (Cherry, 2008) ; SRL for semantic cohesion model (Feng et al., 2012); JUMPTREE
for our tree-based jump model based on (Wang et al., 2007).

Running Words OOV Perplexity
Test in Table 2 8 382 086 33854 74.364
NIST02 22 749 195 176.806
NIST03 24 180 290 274.679
NIST04 49 612 320 170.507
NIST05 29 966 228 279.402
NIST08 32 502 511 408.067

Table 8: perplexity

a strong system (B11 and T11), our model is still
able to provide improvements (B12 and T12).

6 Conclusion

In this paper, a novel tagging style reordering
model has been proposed. By our method, the re-
ordering problem is converted into a sequence la-
beling problem so that the whole source sentence
is taken into consideration for reordering decision.
By adding an unaligned word tag, the unaligned
word phenomenon is automatically implanted in
the proposed model. The model is utilized as soft
constraints in the decoder. In practice, we do not
experience decoding memory increase nor speed
slow down.

We choose CRFs and RNN to accomplish the
sequence labeling task. The CRFs achieves lower
error rate on the tagging task but RNN trained
model is better for the translation task. Experi-
mental results show that our model is stable and
improves the baseline system by 0.98 BLEU and
1.21 TER (trained by CRFs) and 1.32 BLEU and
1.53 TER (trained by RNN). Most of the scores

are better than their corresponding baseline values
with more than 95% confidence. We also compare
our method with several other popular reorder-
ing models. Our model ranks the second position
which is slightly worse than the tree-based jump
model. However, the tree-based jump model re-
lies on manually designed reordering rules which
does not exist for many language pairs while our
model can be easily adapted to other translation
tasks. We also show that the proposed model is
able to improve a very strong baseline system.

The main contributions of the paper are: pro-
pose the tagging-style reordering model and im-
prove the translation quality; compare two se-
quence labeling techniques CRFs and RNN; com-
pare our method with seven other reordering mod-
els. To our best knowledge, it is the first time that
the above two comparisons have been reported .

Acknowledgments
This work was partly realized as part of the
Quaero Programme, funded by OSEO, French
State agency for innovation, and also partly based
upon work supported by the Defense Advanced
Research Projects Agency (DARPA) under Con-
tract No. HR0011-12-C-0015. Any opinions,
findings and conclusions or recommendations ex-
pressed in this material are those of the authors and
do not necessarily reflect the views of the Defense
Advanced Research Projects Agency (DARPA).

330



References
Yoshua Bengio, Patrice Simard, and Paolo Frasconi.

1994. Learning long-term dependencies with gradi-
ent descent is difficult. IEEE Transactions on Neu-
ral Networks, 5(2):157–166, March.

Adam Berger, Peter F. Brown, Stephen A. Pietra, Vin-
cent J. Pietra, Andrew S. Kehler, and Robert L.
Mercer. 1996. Language translation apparatus and
method of using Context-Based translation models.
United States Patent, No. 5,510,981.

Colin Cherry. 2008. Cohesive phrase-based decoding
for statistical machine translation. In Proceedings
of Annual Meeting of the Association for Computa-
tional Linguistics: Human Language Technologies
(ACL: HLT), pages 72–80, Columbus, Ohio, USA,
June. Association for Computational Linguistics.

Jeffrey L. Elman. 1990. Finding structure in time.
Cognitive Science, 14(2):179–211.

Minwei Feng, Arne Mauser, and Hermann Ney. 2010.
A source-side decoding sequence model for statisti-
cal machine translation. In Proceedings of the As-
sociation for Machine Translation in the Americas
(AMTA), Denver, CO, USA, October.

Minwei Feng, Weiwei Sun, and Hermann Ney. 2012.
Semantic cohesion model for phrase-based SMT.
In Proceedings of the International Conference on
Computational Linguistics (COLING), pages 867–
878, Mumbai, India, December. The COLING 2012
Organizing Committee.

Michel Galley and Christopher D. Manning. 2008.
A simple and effective hierarchical phrase reorder-
ing model. In Proceedings of the Conference on
Empirical Methods in Natural Language Processing
(EMNLP), pages 848–856, Stroudsburg, PA, USA.
Association for Computational Linguistics.

Alex Graves. 2008. Supervised Sequence Labelling
with Recurrent Neural Networks. Ph.D. thesis,
Technical University of Munich, July.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural Computation,
9(8):1735–1780, November.

Michael I. Jordan. 1990. Attractor dynamics and
parallelism in a connectionist sequential machine.
IEEE Computer Society Neural Networks Technol-
ogy Series, pages 112–127.

Kevin Knight. 1999. Decoding complexity in word-
replacement translation models. Computational
Linguistics, 25(4):607–615.

Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003.
Statistical phrase-based translation. In Proceedings
of the Conference of the North American Chapter
of the Association for Computational Linguistics on
Human Language Technology (NAACL) - Volume 1,
pages 48–54, Stroudsburg, PA, USA. Association
for Computational Linguistics.

Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proceedings of the Annual Meeting of the Associ-
ation for Computational Linguistics (ACL), demon-
stration session, pages 177–180, Prague, Czech Re-
public, June.

Philipp Koehn. 2004. Statistical significance tests
for machine translation evaluation. In Proceedings
of the Conference on Empirical Methods in Natu-
ral Language Processing (EMNLP), pages 388–395,
Barcelona, Spain, July. Association for Computa-
tional Linguistics.

John D. Lafferty, Andrew McCallum, and Fernando
C. N. Pereira. 2001. Conditional random fields:
Probabilistic models for segmenting and labeling se-
quence data. In Proceedings of the Eighteenth Inter-
national Conference on Machine Learning (ICML),
pages 282–289, San Francisco, CA, USA. Morgan
Kaufmann Publishers Inc.

Kevin J. Lang, Alex H. Waibel, and Geoffrey E. Hin-
ton. 1990. A time-delay neural network architec-
ture for isolated word recognition. Neural networks,
3(1):23–43, January.

Thomas Lavergne, Olivier Cappé, and François Yvon.
2010. Practical very large scale CRFs. In Proceed-
ings the 48th Annual Meeting of the Association for
Computational Linguistics (ACL), pages 504–513.
Association for Computational Linguistics, July.

Dong C. Liu and Jorge Nocedal. 1989. On the lim-
ited memory bfgs method for large scale optimiza-
tion. Mathematical Programming, 45(3):503–528,
December.

José B. Mariño, Rafael E. Banchs, Josep Maria Crego,
Adrià de Gispert, Patrik Lambert, José A. R. Fonol-
losa, and Marta R. Costa-Jussà. 2006. N-gram-
based machine translation. Computational Linguis-
tics, 32(4):527–549, December.

Franz J. Och and Hermann Ney. 2002. Discriminative
training and maximum entropy models for statisti-
cal machine translation. In Proceedings of Annual
Meeting of the Association for Computational Lin-
guistics (ACL), pages 295–302, Philadelphia, Penn-
sylvania, USA, July.

Franz J. Och, Christoph Tillmann, and Hermann Ney.
1999. Improved alignment models for statistical
machine translation. In Proceedings of the Joint
SIGDAT Conference on Empirical Methods in Nat-
ural Language Processing and Very Large Cor-
pora (EMNLP), pages 20–28, University of Mary-
land, College Park, MD, USA, June. Association for
Computational Linguistics.

331



Franz J. Och, Daniel Gildea, Sanjeev Khudanpur,
Anoop Sarkar, Kenji Yamada, Alex Fraser, Shankar
Kumar, Libin Shen, David Smith, Katherine Eng,
Viren Jain, Zhen Jin, and Dragomir Radev. 2004.
A smorgasbord of features for statistical machine
translation. In Proceedings of the Conference
on Statistical Machine Translation at the North
American Chapter of the Association for Compu-
tational Linguistics on Human Language Technol-
ogy (NAACL-HLT), pages 161–168, Boston, Mas-
sachusetts, USA, May. Association for Computa-
tional Linguistics.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2001. Bleu: a method for automatic eval-
uation of machine translation. IBM Research Re-
port, RC22176 (W0109-022), September.

David. E. Rumelhart, Geoffrey E. Hinton, and
Ronald J. Williams. 1986. Learning internal repre-
sentations by error propagation. In David E. Rumel-
hart and James L. McClelland, editors, Parallel dis-
tributed processing: explorations in the microstruc-
ture of cognition, vol. 1, pages 318–362. MIT Press,
Cambridge, MA, USA.

Mike Schuster and Kuldip K. Paliwal. 1997. Bidirec-
tional recurrent neural networks. IEEE Transactions
on Signal Processing, 45(11):2673–2681, Novem-
ber.

Matthew Snover, Bonnie Dorr, Richard Schwartz, John
Makhoul, Linnea Micciulla, and Ralph Weischedel.
2005. A study of translation error rate with targeted
human annotation. Technical Report LAMP-TR-
126, CS-TR-4755, UMIACS-TR-2005-58, Univer-
sity of Maryland, College Park, MD.

Andreas Stolcke. 2002. Srilm - an extensible lan-
guage modeling toolkit. In Proceedings of Interna-
tional Conference on Spoken Language Processing
(ICSLP), pages 901–904, Denver, Colorado, USA,
September. ISCA.

Charles Sutton and Andrew Mccallum, 2006. In-
troduction to Conditional Random Fields for Rela-
tional Learning, pages 93–128. MIT Press.

Chao Wang, Michael Collins, and Philipp Koehn.
2007. Chinese syntactic reordering for statis-
tical machine translation. In Proceedings of
the Conference on Empirical Methods in Natural
Language Processing (EMNLP), pages 737–745,
Prague, Czech Republic, June. Association for Com-
putational Linguistics.

Dekai Wu. 1995. Stochastic inversion transduction
grammars with application to segmentation, brack-
eting, and alignment of parallel corpora. In Pro-
ceedings of the 14th international joint conference
on Artificial intelligence (IJCAI) - Volume 2, pages
1328–1335, San Francisco, CA, USA, August. Mor-
gan Kaufmann Publishers Inc.

Richard Zens and Hermann Ney. 2003. A compara-
tive study on reordering constraints in statistical ma-
chine translation. In Proceedings of the 41st Annual
Meeting on Association for Computational Linguis-
tics (ACL) - Volume 1, pages 144–151, Stroudsburg,
PA, USA. Association for Computational Linguis-
tics.

Richard Zens and Hermann Ney. 2006. Discrimina-
tive reordering models for statistical machine trans-
lation. In Proceedings of the Workshop on Statistical
Machine Translation at the North American Chapter
of the Association for Computational Linguistics on
Human Language Technology (NAACL-HLT), pages
55–63, New York City, NY, June. Association for
Computational Linguistics.

Richard Zens, Franz J. Och, and Hermann Ney. 2002.
Phrase-based statistical machine translation. In Ger-
man Conference on Artificial Intelligence, pages 18–
32. Springer Verlag, September.

Yuqi Zhang, Richard Zens, and Hermann Ney. 2007.
Chunk-level reordering of source language sen-
tences with automatically learned rules for statistical
machine translation. In Proceedings of the Work-
shop on Syntax and Structure in Statistical Transla-
tion at the North American Chapter of the Associa-
tion for Computational Linguistics on Human Lan-
guage Technology (NAACL-HLT)/Association for
Machine Translation in the Americas (AMTA), pages
1–8, Morristown, NJ, USA, April. Association for
Computational Linguistics.

Yuqi Zhang. 2013. The Application of Source Lan-
guage Information in Chinese-English Statistical
Machine Translation. Ph.D. thesis, Computer Sci-
ence Department, RWTH Aachen University, May.

332


